ğŸš€ GuÃ­a de Inicio RÃ¡pido - CompuNet Chat
Esta guÃ­a te llevarÃ¡ paso a paso desde cero hasta tener el sistema de chat funcionando.
âœ… Pre-requisitos
Antes de empezar, asegÃºrate de tener instalado:

 Java JDK 11 o superior
 Gradle 7.0 o superior
 Node.js 14 o superior
 ZeroC Ice 3.7.x
 Git (opcional)

Verificar instalaciones
bash# Verificar Java
java -version

# Verificar Gradle
gradle -version

# Verificar Node.js
node -version
npm -version

# Verificar Ice
slice2java -version
slice2js -version
ğŸ“¥ Paso 1: Obtener el Proyecto
Si tienes el proyecto en Git:
bashgit clone <url-del-repositorio>
cd compunet-chat
Si tienes los archivos localmente, navega al directorio:
bashcd compunet-chat
ğŸ—ï¸ Paso 2: Crear la Estructura de Directorios
AsegÃºrate de tener la siguiente estructura:
bashmkdir -p server/src/main/slice
mkdir -p server/src/main/java/com/compunet/server
mkdir -p client/src
ğŸ“ Paso 3: Copiar los Archivos
Copia todos los archivos proporcionados a sus ubicaciones correspondientes:
Servidor

chat.ice â†’ server/src/main/slice/
build.gradle â†’ server/
config.properties â†’ server/
ChatCore.java â†’ server/src/main/java/com/compunet/server/
ChatServiceI.java â†’ server/src/main/java/com/compunet/server/
GroupServiceI.java â†’ server/src/main/java/com/compunet/server/
ServerMain.java â†’ server/src/main/java/com/compunet/server/

Cliente

package.json â†’ client/
webpack.config.js â†’ client/
index.html â†’ client/src/
styles.css â†’ client/src/
Todos los archivos .js â†’ client/src/

RaÃ­z

generate-ice-code.sh â†’ raÃ­z del proyecto

ğŸ”¨ Paso 4: Generar CÃ³digo Ice
OpciÃ³n A: Usar el script (Linux/Mac)
bash# Dar permisos de ejecuciÃ³n
chmod +x generate-ice-code.sh

# Ejecutar el script
./generate-ice-code.sh
OpciÃ³n B: Manual
bash# Generar cÃ³digo Java
cd server
mkdir -p build/generated-src
slice2java --output-dir build/generated-src src/main/slice/chat.ice

# Generar cÃ³digo JavaScript
cd ../client/src
mkdir -p generated
slice2js --output-dir generated ../../server/src/main/slice/chat.ice
cd ../..
Importante: Verifica que se hayan creado los archivos:

server/build/generated-src/compunet/*.java
client/src/generated/compunet.js

ğŸƒ Paso 5: Compilar e Instalar
Servidor
bashcd server

# Primera vez: inicializar Gradle wrapper (si no existe)
gradle wrapper

# Compilar el proyecto
./gradlew build

# Si todo va bien, verÃ¡s: BUILD SUCCESSFUL
Cliente
bashcd client

# Instalar dependencias
npm install

# Esto puede tomar unos minutos la primera vez
â–¶ï¸ Paso 6: Ejecutar el Sistema
6.1 Iniciar el Servidor
Abre una terminal y ejecuta:
bashcd server
./gradlew run
DeberÃ­as ver algo como:
===========================================
    Servidor de Chat iniciado
===========================================
WebSocket endpoint: ws://localhost:10000
TCP endpoint: tcp://localhost:10001
Servicios disponibles:
  - ChatService (identity: 'chat')
  - GroupService (identity: 'group')
===========================================
Presiona Ctrl+C para detener el servidor

Inicializando datos de prueba...
Usuario registrado: user1 (Alice)
Usuario registrado: user2 (Bob)
Usuario registrado: user3 (Charlie)
Usuario registrado: user4 (Diana)
...
âš ï¸ IMPORTANTE: Deja esta terminal abierta con el servidor ejecutÃ¡ndose.
6.2 Iniciar el Cliente
Abre OTRA terminal y ejecuta:
bashcd client
npm run serve
DeberÃ­as ver:
<i> [webpack-dev-server] Project is running at:
<i> [webpack-dev-server] Loopback: http://localhost:8080/
...
webpack 5.x.x compiled successfully
El navegador deberÃ­a abrirse automÃ¡ticamente en http://localhost:8080
âœ¨ Paso 7: Probar el Sistema
7.1 Verificar la ConexiÃ³n

El navegador deberÃ­a mostrar la interfaz del chat
En la parte superior izquierda deberÃ­as ver "Alice" como usuario actual
DeberÃ­as ver algunos chats de prueba:

Bob (conversaciÃ³n directa)
Proyecto Universitario (grupo)



7.2 Enviar un Mensaje

Haz clic en "Bob" en la lista de chats
DeberÃ­as ver mensajes previos en el panel derecho
Escribe un mensaje en la caja de texto inferior
Presiona "Enviar" o Enter
El mensaje deberÃ­a aparecer en la conversaciÃ³n

7.3 Crear un Grupo

Haz clic en el botÃ³n "+ Nuevo Grupo"
Ingresa un nombre para el grupo
Selecciona uno o mÃ¡s usuarios
Haz clic en "Crear Grupo"
El nuevo grupo deberÃ­a aparecer en la lista de chats

7.4 Enviar Mensaje a Grupo

Selecciona el grupo que acabas de crear
Escribe un mensaje
EnvÃ­a el mensaje
DeberÃ­a aparecer en el chat del grupo

ğŸ› SoluciÃ³n de Problemas Comunes
Error: "slice2java: command not found"
SoluciÃ³n: Ice no estÃ¡ instalado o no estÃ¡ en el PATH.
En Ubuntu/Debian:
bashsudo apt-get install zeroc-ice-all-dev zeroc-ice-all-runtime
En macOS con Homebrew:
bashbrew install ice
En Windows: Descarga desde ZeroC Downloads

Error: "Cannot find module 'ice'"
SoluciÃ³n: Las dependencias del cliente no estÃ¡n instaladas.
bashcd client
rm -rf node_modules package-lock.json
npm install

Error: "Address already in use" en el servidor
SoluciÃ³n: El puerto 10000 o 10001 estÃ¡ ocupado.
Ver quÃ© proceso estÃ¡ usando el puerto:
bash# Linux/Mac
lsof -i :10000

# Windows
netstat -ano | findstr :10000
Cambiar los puertos en server/src/main/java/com/compunet/server/ServerMain.java y en client/src/IceConnectionManager.js

El cliente no se conecta al servidor
Verificar:

Â¿El servidor estÃ¡ ejecutÃ¡ndose? (verifica la terminal del servidor)
Â¿Hay errores en la consola del navegador? (presiona F12)
Â¿Los puertos son correctos?

SoluciÃ³n: Abre la consola del navegador (F12) y busca mensajes de error de Ice.

Los mensajes no aparecen
SoluciÃ³n:

Verifica que hayas seleccionado un chat (debe estar resaltado)
Haz clic en el botÃ³n "ğŸ”„ Actualizar"
Revisa la consola del navegador para errores


Error de compilaciÃ³n en Gradle
SoluciÃ³n: AsegÃºrate de haber generado el cÃ³digo Ice primero.
bashcd server
mkdir -p build/generated-src
slice2java --output-dir build/generated-src src/main/slice/chat.ice
./gradlew clean build
ğŸ“Š Verificar que Todo Funciona
Lista de verificaciÃ³n final:

 El servidor se inicia sin errores
 El cliente se abre en el navegador
 Puedes ver la lista de chats
 Puedes seleccionar un chat y ver mensajes
 Puedes enviar un mensaje
 El mensaje aparece en la conversaciÃ³n
 Puedes crear un nuevo grupo
 Puedes enviar mensajes al grupo

ğŸ‰ Â¡Listo!
Si llegaste hasta aquÃ­ y todo funciona, Â¡felicitaciones! Tienes un sistema de chat funcional con:
âœ… Mensajes directos 1 a 1
âœ… Grupos con mÃºltiples usuarios
âœ… Interfaz tipo WhatsApp
âœ… ComunicaciÃ³n mediante ZeroC Ice
ğŸ“š PrÃ³ximos Pasos

Lee el README.md para entender la arquitectura
Revisa ESTRUCTURA_PROYECTO.md para ver cÃ³mo estÃ¡ organizado el cÃ³digo
Explora el cÃ³digo para entender cÃ³mo funciona Ice
Intenta agregar nuevas funcionalidades

Sistema de Chat CompuNet - Proyecto Universitario
Sistema de chat tipo WhatsApp desarrollado con ZeroC Ice como middleware entre cliente y servidor.
ğŸ—ï¸ Arquitectura del Proyecto
compunet-chat/
â”œâ”€â”€ server/                  # Servidor Java con Ice
â”‚   â”œâ”€â”€ build.gradle
â”‚   â””â”€â”€ src/
â”‚       â””â”€â”€ main/
â”‚           â”œâ”€â”€ slice/
â”‚           â”‚   â””â”€â”€ chat.ice
â”‚           â””â”€â”€ java/
â”‚               â””â”€â”€ com/compunet/server/
â”‚                   â”œâ”€â”€ ChatCore.java
â”‚                   â”œâ”€â”€ ChatServiceI.java
â”‚                   â”œâ”€â”€ GroupServiceI.java
â”‚                   â””â”€â”€ ServerMain.java
â”‚
â””â”€â”€ client/                  # Cliente web con JavaScript
    â”œâ”€â”€ package.json
    â”œâ”€â”€ webpack.config.js
    â””â”€â”€ src/
        â”œâ”€â”€ index.html
        â”œâ”€â”€ styles.css
        â”œâ”€â”€ index.js
        â”œâ”€â”€ IceConnectionManager.js
        â”œâ”€â”€ ChatStateManager.js
        â”œâ”€â”€ MessageSender.js
        â”œâ”€â”€ MessageReceiver.js
        â”œâ”€â”€ ChatUIController.js
        â””â”€â”€ generated/       # CÃ³digo generado por slice2js
            â””â”€â”€ compunet.js
ğŸ“‹ Requisitos Previos
Servidor

Java JDK 11 o superior
Gradle 7.0 o superior
ZeroC Ice 3.7.x instalado
slice2java en el PATH

Cliente

Node.js 14 o superior
npm o yarn
slice2js en el PATH

ğŸš€ ConfiguraciÃ³n e InstalaciÃ³n
1. Generar cÃ³digo Ice
Primero, genera el cÃ³digo Java desde el archivo .ice:
bashcd server
mkdir -p build/generated-src
slice2java --output-dir build/generated-src src/main/slice/chat.ice
Luego, genera el cÃ³digo JavaScript:
bashcd ../client/src
mkdir -p generated
slice2js --output-dir generated ../../server/src/main/slice/chat.ice
2. Configurar el Servidor
bashcd server
./gradlew build
3. Configurar el Cliente
bashcd client
npm install
â–¶ï¸ EjecuciÃ³n
Iniciar el Servidor
OpciÃ³n 1: Con Gradle
bashcd server
./gradlew run
OpciÃ³n 2: Con Java directamente
bashcd server
./gradlew build
java -cp build/libs/server.jar:$ICE_HOME/lib/* com.compunet.server.ServerMain
El servidor se iniciarÃ¡ en:

WebSocket: ws://localhost:10000
TCP: tcp://localhost:10001

Iniciar el Cliente
OpciÃ³n 1: Servidor de desarrollo (recomendado)
bashcd client
npm run serve
Esto abrirÃ¡ automÃ¡ticamente el navegador en http://localhost:8080
OpciÃ³n 2: Build de producciÃ³n
bashcd client
npm run build
Luego sirve la carpeta dist/ con cualquier servidor HTTP.
ğŸ¯ Funcionalidades Implementadas
âœ… Mensajes Directos

EnvÃ­o de mensajes de texto 1 a 1
VisualizaciÃ³n de historial de mensajes
Lista de conversaciones directas

âœ… Grupos

CreaciÃ³n de grupos con mÃºltiples usuarios
EnvÃ­o de mensajes a grupos
VisualizaciÃ³n de mensajes de grupo con nombre del remitente
Lista de grupos del usuario

âœ… Interfaz de Usuario

Lista de chats (directos y grupos) en panel izquierdo
Ãrea de mensajes en panel derecho
DiferenciaciÃ³n visual entre mensajes enviados y recibidos
Indicadores de tipo de chat (directo/grupo)
Modal para crear nuevos grupos
ActualizaciÃ³n manual de chats

ğŸ§ª Datos de Prueba
El servidor se inicializa con los siguientes datos de prueba:
Usuarios:

user1 - Alice (usuario activo en el cliente)
user2 - Bob
user3 - Charlie
user4 - Diana

Mensajes de prueba:

ConversaciÃ³n directa entre Alice y Bob
Grupo "Proyecto Universitario" con Alice, Bob y Charlie

ğŸ”§ Estructura del CÃ³digo
Servidor (Java)

chat.ice: Define las interfaces Ice (ChatService, GroupService) y estructuras de datos
ChatCore: LÃ³gica central que maneja usuarios, mensajes y grupos en memoria
ChatServiceI: ImplementaciÃ³n del servicio de mensajes directos
GroupServiceI: ImplementaciÃ³n del servicio de grupos
ServerMain: Punto de entrada que inicializa Ice y registra los servicios

Cliente (JavaScript)

IceConnectionManager: Gestiona la conexiÃ³n Ice y expone mÃ©todos para llamar al servidor
ChatStateManager: Mantiene el estado de la aplicaciÃ³n (usuario actual, chats, mensajes)
MessageSender: Maneja el envÃ­o de mensajes (directos y de grupo)
MessageReceiver: Maneja la recepciÃ³n y carga de mensajes
ChatUIController: Controla la interfaz de usuario y eventos
index.js: Punto de entrada que inicializa la aplicaciÃ³n

ğŸ“ Servicios Ice Disponibles
ChatService
icevoid registerUser(string userId, string userName);
User getUser(string userId);
UserSeq getAllUsers();
void sendDirectMessage(string fromUserId, string toUserId, string content);
MessageSeq getDirectChatMessages(string userId, string otherUserId);
ChatSummarySeq getUserDirectChats(string userId);
GroupService
icestring createGroup(string ownerId, string groupName, StringSeq memberIds);
void addMembersToGroup(string groupId, StringSeq memberIds);
StringSeq getGroupMembers(string groupId);
void sendGroupMessage(string fromUserId, string groupId, string content);
MessageSeq getGroupChatMessages(string groupId);
ChatSummarySeq getUserGroupChats(string userId);
ğŸ› SoluciÃ³n de Problemas
El cliente no se conecta al servidor

Verifica que el servidor estÃ© ejecutÃ¡ndose
Revisa que los puertos 10000 y 10001 estÃ©n disponibles
Verifica la consola del navegador para ver errores de Ice

Error al generar cÃ³digo Ice

AsegÃºrate de que slice2java y slice2js estÃ©n en el PATH
Verifica la versiÃ³n de Ice (debe ser 3.7.x)
Revisa que los archivos .ice no tengan errores de sintaxis

Mensajes no se muestran

Abre la consola del navegador (F12) y busca errores
Verifica que el chat estÃ© seleccionado correctamente
Intenta actualizar los chats con el botÃ³n "ğŸ”„ Actualizar"

ğŸ”® PrÃ³ximas Iteraciones
Las siguientes caracterÃ­sticas NO estÃ¡n implementadas en esta iteraciÃ³n:

 Persistencia en base de datos
 Notas de voz
 Audio y llamadas
 Callbacks/WebSocket para actualizaciones en tiempo real
 Notificaciones de mensajes nuevos
 Estado de lectura de mensajes
 MÃºltiples usuarios simultÃ¡neos (actualmente solo user1)

Estructura Completa del Proyecto CompuNet Chat
ğŸ“ Estructura de Directorios
compunet-chat/
â”‚
â”œâ”€â”€ README.md                      # DocumentaciÃ³n principal
â”œâ”€â”€ ESTRUCTURA_PROYECTO.md         # Este archivo
â”œâ”€â”€ generate-ice-code.sh           # Script para generar cÃ³digo Ice
â”‚
â”œâ”€â”€ server/                        # SUBPROYECTO SERVIDOR (Java + Ice)
â”‚   â”œâ”€â”€ build.gradle               # ConfiguraciÃ³n de Gradle
â”‚   â”œâ”€â”€ gradle/                    # Wrapper de Gradle
â”‚   â”‚   â””â”€â”€ wrapper/
â”‚   â”œâ”€â”€ gradlew                    # Script de Gradle (Unix)
â”‚   â”œâ”€â”€ gradlew.bat                # Script de Gradle (Windows)
â”‚   â”œâ”€â”€ config.properties          # ConfiguraciÃ³n del servidor Ice
â”‚   â”‚
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â””â”€â”€ main/
â”‚   â”‚       â”œâ”€â”€ slice/             # Definiciones Ice
â”‚   â”‚       â”‚   â””â”€â”€ chat.ice       # Interfaces y estructuras
â”‚   â”‚       â”‚
â”‚   â”‚       â”œâ”€â”€ java/
â”‚   â”‚       â”‚   â””â”€â”€ com/
â”‚   â”‚       â”‚       â””â”€â”€ compunet/
â”‚   â”‚       â”‚           â””â”€â”€ server/
â”‚   â”‚       â”‚               â”œâ”€â”€ ChatCore.java        # LÃ³gica central
â”‚   â”‚       â”‚               â”œâ”€â”€ ChatServiceI.java    # Servant de ChatService
â”‚   â”‚       â”‚               â”œâ”€â”€ GroupServiceI.java   # Servant de GroupService
â”‚   â”‚       â”‚               â””â”€â”€ ServerMain.java      # Punto de entrada
â”‚   â”‚       â”‚
â”‚   â”‚       â””â”€â”€ resources/
â”‚   â”‚
â”‚   â””â”€â”€ build/                     # Directorio de compilaciÃ³n (generado)
â”‚       â”œâ”€â”€ classes/
â”‚       â”œâ”€â”€ libs/
â”‚       â””â”€â”€ generated-src/         # CÃ³digo Java generado por slice2java
â”‚           â””â”€â”€ compunet/
â”‚
â””â”€â”€ client/                        # SUBPROYECTO CLIENTE (JavaScript + Ice)
    â”œâ”€â”€ package.json               # ConfiguraciÃ³n de npm
    â”œâ”€â”€ webpack.config.js          # ConfiguraciÃ³n de Webpack
    â”‚
    â”œâ”€â”€ src/                       # CÃ³digo fuente
    â”‚   â”œâ”€â”€ index.html             # HTML principal
    â”‚   â”œâ”€â”€ styles.css             # Estilos CSS
    â”‚   â”œâ”€â”€ index.js               # Punto de entrada
    â”‚   â”‚
    â”‚   â”œâ”€â”€ IceConnectionManager.js    # GestiÃ³n de conexiÃ³n Ice
    â”‚   â”œâ”€â”€ ChatStateManager.js        # GestiÃ³n de estado
    â”‚   â”œâ”€â”€ MessageSender.js           # EnvÃ­o de mensajes
    â”‚   â”œâ”€â”€ MessageReceiver.js         # RecepciÃ³n de mensajes
    â”‚   â”œâ”€â”€ ChatUIController.js        # Control de UI
    â”‚   â”‚
    â”‚   â””â”€â”€ generated/                 # CÃ³digo JS generado por slice2js
    â”‚       â””â”€â”€ compunet.js
    â”‚
    â”œâ”€â”€ dist/                      # Build de producciÃ³n (generado)
    â”‚   â”œâ”€â”€ index.html
    â”‚   â””â”€â”€ bundle.js
    â”‚
    â””â”€â”€ node_modules/              # Dependencias npm (generado)
ğŸ“„ DescripciÃ³n de Archivos Clave
RaÃ­z del Proyecto

README.md: DocumentaciÃ³n principal con instrucciones de instalaciÃ³n y uso
generate-ice-code.sh: Script automatizado para generar cÃ³digo Ice
ESTRUCTURA_PROYECTO.md: Este documento

Servidor (Java)
ConfiguraciÃ³n

build.gradle: Define dependencias, tareas de Gradle y generaciÃ³n de cÃ³digo Ice
config.properties: ConfiguraciÃ³n del servidor Ice (endpoints, threads, etc.)

CÃ³digo Fuente

chat.ice: Define las interfaces Ice (ChatService, GroupService) y estructuras de datos (User, Message, ChatSummary)
ChatCore.java: LÃ³gica central del servidor que maneja usuarios, mensajes directos y grupos en memoria
ChatServiceI.java: ImplementaciÃ³n del servant para ChatService
GroupServiceI.java: ImplementaciÃ³n del servant para GroupService
ServerMain.java: Inicializa Ice, registra los servants y arranca el servidor

Cliente (JavaScript)
ConfiguraciÃ³n

package.json: Define dependencias npm (ice, webpack, etc.) y scripts de build
webpack.config.js: ConfiguraciÃ³n de Webpack para empaquetar el cÃ³digo

CÃ³digo Fuente

index.html: Estructura HTML de la aplicaciÃ³n (lista de chats, Ã¡rea de mensajes, modal)
styles.css: Estilos CSS tipo WhatsApp
index.js: Punto de entrada que inicializa la aplicaciÃ³n

MÃ³dulos JavaScript

IceConnectionManager.js:

Inicializa la conexiÃ³n Ice
Crea proxies para ChatService y GroupService
Expone mÃ©todos para llamar al servidor


ChatStateManager.js:

Mantiene el estado de la aplicaciÃ³n
Gestiona usuario actual, lista de chats, chat activo y mensajes
Proporciona utilidades para formatear datos


MessageSender.js:

Maneja el envÃ­o de mensajes
Decide si enviar a chat directo o grupo
Valida contenido antes de enviar


MessageReceiver.js:

Carga mensajes de un chat especÃ­fico
Actualiza la lista de chats
Sincroniza datos con el servidor


ChatUIController.js:

Controla toda la interfaz de usuario
Renderiza lista de chats y mensajes
Maneja eventos (clicks, envÃ­o de mensajes, etc.)
Gestiona el modal de creaciÃ³n de grupos



ğŸ”„ Flujo de Datos
EnvÃ­o de Mensaje
Usuario escribe mensaje
    â†“
ChatUIController captura el evento
    â†“
MessageSender.sendMessage()
    â†“
IceConnectionManager determina tipo (directo/grupo)
    â†“
Llama a ChatService o GroupService via Ice
    â†“
Servidor (ChatCore) procesa y almacena
    â†“
Cliente refresca mensajes
    â†“
ChatUIController re-renderiza
Carga de Chat
Usuario selecciona un chat
    â†“
ChatUIController.handleChatClick()
    â†“
ChatStateManager.setActiveChat()
    â†“
MessageReceiver.loadChatMessages()
    â†“
IceConnectionManager llama al servidor
    â†“
Servidor devuelve mensajes
    â†“
ChatStateManager almacena mensajes
    â†“
ChatUIController renderiza mensajes
ğŸ› ï¸ Archivos Generados
Los siguientes archivos se generan automÃ¡ticamente y NO deben editarse manualmente:
Servidor

server/build/generated-src/compunet/*.java - Clases Java generadas por slice2java

Cliente

client/src/generated/compunet.js - CÃ³digo JavaScript generado por slice2js
client/dist/* - Build de producciÃ³n generado por Webpack
client/node_modules/* - Dependencias npm

ğŸ“¦ Dependencias
Servidor (Java)
gradle- com.zeroc:ice:3.7.10
- com.zeroc:glacier2:3.7.10
Cliente (JavaScript)
json- ice: 3.7.10
- webpack: 5.88.0
- webpack-cli: 5.1.4
- webpack-dev-server: 4.15.1
- html-webpack-plugin: 5.5.3
ğŸš€ Orden de EjecuciÃ³n

Generar cÃ³digo Ice: ./generate-ice-code.sh
Compilar servidor: cd server && ./gradlew build
Instalar dependencias cliente: cd client && npm install
Iniciar servidor: cd server && ./gradlew run
Iniciar cliente: cd client && npm run serve

ğŸ“ Notas Importantes

El cÃ³digo generado por Ice debe crearse antes de compilar
El servidor debe estar ejecutÃ¡ndose antes de iniciar el cliente
Los puertos 10000 (WebSocket) y 10001 (TCP) deben estar libres
El cliente se conecta por defecto a localhost:10000
El almacenamiento es en memoria (se pierde al reiniciar el servidor)

chat.ice
module compunet {
    // Estructuras de datos bÃ¡sicas
    struct User {
        string id;
        string name;
    };

    struct Message {
        string id;
        string senderId;
        string senderName;
        string content;
        long timestamp;
        string chatId; // ID del chat (userId para directos, groupId para grupos)
        bool isGroupMessage;
    };

    struct ChatSummary {
        string chatId;
        string chatName;
        string lastMessageContent;
        long lastMessageTimestamp;
        bool isGroup;
    };

    // Secuencias
    sequence<string> StringSeq;
    sequence<Message> MessageSeq;
    sequence<ChatSummary> ChatSummarySeq;
    sequence<User> UserSeq;

    // Interfaz para gestiÃ³n de mensajes directos
    interface ChatService {
        // Registro bÃ¡sico de usuarios
        void registerUser(string userId, string userName);
        User getUser(string userId);
        UserSeq getAllUsers();
        
        // Mensajes directos
        void sendDirectMessage(string fromUserId, string toUserId, string content);
        MessageSeq getDirectChatMessages(string userId, string otherUserId);
        ChatSummarySeq getUserDirectChats(string userId);
    };

    // Interfaz para gestiÃ³n de grupos
    interface GroupService {
        // GestiÃ³n de grupos
        string createGroup(string ownerId, string groupName, StringSeq memberIds);
        void addMembersToGroup(string groupId, StringSeq memberIds);
        StringSeq getGroupMembers(string groupId);
        
        // Mensajes de grupo
        void sendGroupMessage(string fromUserId, string groupId, string content);
        MessageSeq getGroupChatMessages(string groupId);
        ChatSummarySeq getUserGroupChats(string userId);
    };
};

server/build.gradle
plugins {
    id 'java'
    id 'application'
}

group = 'com.compunet'
version = '1.0.0'
sourceCompatibility = '11'

repositories {
    mavenCentral()
    maven {
        url "https://repo.zeroc.com/releases"
    }
}

dependencies {
    implementation 'com.zeroc:ice:3.7.10'
    implementation 'com.zeroc:glacier2:3.7.10'
    testImplementation 'junit:junit:4.13.2'
}

def generatedSourcesDir = file("${buildDir}/generated-src")

sourceSets {
    main {
        java {
            srcDirs = ['src/main/java', generatedSourcesDir]
        }
    }
}

// Tarea para generar cÃ³digo Java desde archivos .ice
task generateIceCode(type: Exec) {
    def iceFile = file('src/main/slice/chat.ice')
    def outputDir = generatedSourcesDir
    
    inputs.file(iceFile)
    outputs.dir(outputDir)
    
    doFirst {
        outputDir.mkdirs()
    }
    
    commandLine 'slice2java', '--output-dir', outputDir, iceFile
}

// Asegurar que el cÃ³digo Ice se genere antes de compilar
compileJava.dependsOn generateIceCode

application {
    mainClass = 'com.compunet.server.ServerMain'
}

// ConfiguraciÃ³n para ejecutar el servidor
run {
    standardInput = System.in
}

task runServer(type: JavaExec) {
    group = 'application'
    description = 'Runs the Chat Server'
    classpath = sourceSets.main.runtimeClasspath
    mainClass = 'com.compunet.server.ServerMain'
    standardInput = System.in
}

Chat.core.java
package com.compunet.server;

import compunet.*;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicLong;
import java.util.stream.Collectors;

public class ChatCore {
    // Almacenamiento en memoria
    private final Map<String, User> users = new ConcurrentHashMap<>();
    private final Map<String, Group> groups = new ConcurrentHashMap<>();
    private final Map<String, List<Message>> directMessages = new ConcurrentHashMap<>();
    private final Map<String, List<Message>> groupMessages = new ConcurrentHashMap<>();
    
    private final AtomicLong messageIdCounter = new AtomicLong(0);
    private final AtomicLong groupIdCounter = new AtomicLong(0);
    
    // Clase interna para representar un grupo
    private static class Group {
        String id;
        String name;
        String ownerId;
        Set<String> memberIds;
        
        Group(String id, String name, String ownerId, Set<String> memberIds) {
            this.id = id;
            this.name = name;
            this.ownerId = ownerId;
            this.memberIds = memberIds;
        }
    }
    
    // === GestiÃ³n de usuarios ===
    
    public void registerUser(String userId, String userName) {
        if (!users.containsKey(userId)) {
            User user = new User(userId, userName);
            users.put(userId, user);
            System.out.println("Usuario registrado: " + userId + " (" + userName + ")");
        }
    }
    
    public User getUser(String userId) {
        return users.get(userId);
    }
    
    public List<User> getAllUsers() {
        return new ArrayList<>(users.values());
    }
    
    // === Mensajes directos ===
    
    public void sendDirectMessage(String fromUserId, String toUserId, String content) {
        User sender = users.get(fromUserId);
        if (sender == null) {
            throw new RuntimeException("Usuario emisor no encontrado: " + fromUserId);
        }
        
        User receiver = users.get(toUserId);
        if (receiver == null) {
            throw new RuntimeException("Usuario receptor no encontrado: " + toUserId);
        }
        
        String chatKey = getChatKey(fromUserId, toUserId);
        Message message = new Message(
            String.valueOf(messageIdCounter.incrementAndGet()),
            fromUserId,
            sender.name,
            content,
            System.currentTimeMillis(),
            toUserId,
            false
        );
        
        directMessages.computeIfAbsent(chatKey, k -> new ArrayList<>()).add(message);
        System.out.println("Mensaje directo enviado de " + fromUserId + " a " + toUserId);
    }
    
    public List<Message> getDirectChatMessages(String userId, String otherUserId) {
        String chatKey = getChatKey(userId, otherUserId);
        return directMessages.getOrDefault(chatKey, new ArrayList<>());
    }
    
    public List<ChatSummary> getUserDirectChats(String userId) {
        List<ChatSummary> summaries = new ArrayList<>();
        
        for (Map.Entry<String, List<Message>> entry : directMessages.entrySet()) {
            String chatKey = entry.getKey();
            if (chatKey.contains(userId)) {
                List<Message> messages = entry.getValue();
                if (!messages.isEmpty()) {
                    Message lastMessage = messages.get(messages.size() - 1);
                    String otherUserId = getOtherUserId(chatKey, userId);
                    User otherUser = users.get(otherUserId);
                    
                    if (otherUser != null) {
                        ChatSummary summary = new ChatSummary(
                            otherUserId,
                            otherUser.name,
                            lastMessage.content,
                            lastMessage.timestamp,
                            false
                        );
                        summaries.add(summary);
                    }
                }
            }
        }
        
        summaries.sort((a, b) -> Long.compare(b.lastMessageTimestamp, a.lastMessageTimestamp));
        return summaries;
    }
    
    private String getChatKey(String userId1, String userId2) {
        // Clave consistente independiente del orden
        return userId1.compareTo(userId2) < 0 
            ? userId1 + ":" + userId2 
            : userId2 + ":" + userId1;
    }
    
    private String getOtherUserId(String chatKey, String userId) {
        String[] parts = chatKey.split(":");
        return parts[0].equals(userId) ? parts[1] : parts[0];
    }
    
    // === GestiÃ³n de grupos ===
    
    public String createGroup(String ownerId, String groupName, String[] memberIds) {
        User owner = users.get(ownerId);
        if (owner == null) {
            throw new RuntimeException("Usuario propietario no encontrado: " + ownerId);
        }
        
        Set<String> members = new HashSet<>(Arrays.asList(memberIds));
        members.add(ownerId); // El propietario siempre es miembro
        
        String groupId = "group_" + groupIdCounter.incrementAndGet();
        Group group = new Group(groupId, groupName, ownerId, members);
        groups.put(groupId, group);
        
        System.out.println("Grupo creado: " + groupId + " (" + groupName + ") con " + members.size() + " miembros");
        return groupId;
    }
    
    public void addMembersToGroup(String groupId, String[] memberIds) {
        Group group = groups.get(groupId);
        if (group == null) {
            throw new RuntimeException("Grupo no encontrado: " + groupId);
        }
        
        group.memberIds.addAll(Arrays.asList(memberIds));
        System.out.println("Miembros agregados al grupo " + groupId);
    }
    
    public String[] getGroupMembers(String groupId) {
        Group group = groups.get(groupId);
        if (group == null) {
            throw new RuntimeException("Grupo no encontrado: " + groupId);
        }
        
        return group.memberIds.toArray(new String[0]);
    }
    
    // === Mensajes de grupo ===
    
    public void sendGroupMessage(String fromUserId, String groupId, String content) {
        User sender = users.get(fromUserId);
        if (sender == null) {
            throw new RuntimeException("Usuario emisor no encontrado: " + fromUserId);
        }
        
        Group group = groups.get(groupId);
        if (group == null) {
            throw new RuntimeException("Grupo no encontrado: " + groupId);
        }
        
        if (!group.memberIds.contains(fromUserId)) {
            throw new RuntimeException("Usuario no es miembro del grupo: " + fromUserId);
        }
        
        Message message = new Message(
            String.valueOf(messageIdCounter.incrementAndGet()),
            fromUserId,
            sender.name,
            content,
            System.currentTimeMillis(),
            groupId,
            true
        );
        
        groupMessages.computeIfAbsent(groupId, k -> new ArrayList<>()).add(message);
        System.out.println("Mensaje enviado al grupo " + groupId + " por " + fromUserId);
    }
    
    public List<Message> getGroupChatMessages(String groupId) {
        return groupMessages.getOrDefault(groupId, new ArrayList<>());
    }
    
    public List<ChatSummary> getUserGroupChats(String userId) {
        List<ChatSummary> summaries = new ArrayList<>();
        
        for (Group group : groups.values()) {
            if (group.memberIds.contains(userId)) {
                List<Message> messages = groupMessages.getOrDefault(group.id, new ArrayList<>());
                
                String lastMessageContent = messages.isEmpty() 
                    ? "Grupo creado" 
                    : messages.get(messages.size() - 1).content;
                long lastMessageTimestamp = messages.isEmpty() 
                    ? System.currentTimeMillis() 
                    : messages.get(messages.size() - 1).timestamp;
                
                ChatSummary summary = new ChatSummary(
                    group.id,
                    group.name,
                    lastMessageContent,
                    lastMessageTimestamp,
                    true
                );
                summaries.add(summary);
            }
        }
        
        summaries.sort((a, b) -> Long.compare(b.lastMessageTimestamp, a.lastMessageTimestamp));
        return summaries;
    }
}

ChatServiceI.java
package com.compunet.server;

import compunet.*;
import com.zeroc.Ice.Current;
import java.util.List;

public class ChatServiceI implements ChatService {
    private final ChatCore chatCore;
    
    public ChatServiceI(ChatCore chatCore) {
        this.chatCore = chatCore;
    }
    
    @Override
    public void registerUser(String userId, String userName, Current current) {
        try {
            chatCore.registerUser(userId, userName);
        } catch (Exception e) {
            System.err.println("Error al registrar usuario: " + e.getMessage());
            throw e;
        }
    }
    
    @Override
    public User getUser(String userId, Current current) {
        try {
            return chatCore.getUser(userId);
        } catch (Exception e) {
            System.err.println("Error al obtener usuario: " + e.getMessage());
            throw e;
        }
    }
    
    @Override
    public User[] getAllUsers(Current current) {
        try {
            List<User> users = chatCore.getAllUsers();
            return users.toArray(new User[0]);
        } catch (Exception e) {
            System.err.println("Error al obtener usuarios: " + e.getMessage());
            throw e;
        }
    }
    
    @Override
    public void sendDirectMessage(String fromUserId, String toUserId, String content, Current current) {
        try {
            chatCore.sendDirectMessage(fromUserId, toUserId, content);
        } catch (Exception e) {
            System.err.println("Error al enviar mensaje directo: " + e.getMessage());
            throw e;
        }
    }
    
    @Override
    public Message[] getDirectChatMessages(String userId, String otherUserId, Current current) {
        try {
            List<Message> messages = chatCore.getDirectChatMessages(userId, otherUserId);
            return messages.toArray(new Message[0]);
        } catch (Exception e) {
            System.err.println("Error al obtener mensajes directos: " + e.getMessage());
            throw e;
        }
    }
    
    @Override
    public ChatSummary[] getUserDirectChats(String userId, Current current) {
        try {
            List<ChatSummary> chats = chatCore.getUserDirectChats(userId);
            return chats.toArray(new ChatSummary[0]);
        } catch (Exception e) {
            System.err.println("Error al obtener chats directos: " + e.getMessage());
            throw e;
        }
    }
}

GroupServiceI.java
package com.compunet.server;

import compunet.*;
import com.zeroc.Ice.Current;
import java.util.List;

public class GroupServiceI implements GroupService {
    private final ChatCore chatCore;
    
    public GroupServiceI(ChatCore chatCore) {
        this.chatCore = chatCore;
    }
    
    @Override
    public String createGroup(String ownerId, String groupName, String[] memberIds, Current current) {
        try {
            return chatCore.createGroup(ownerId, groupName, memberIds);
        } catch (Exception e) {
            System.err.println("Error al crear grupo: " + e.getMessage());
            throw e;
        }
    }
    
    @Override
    public void addMembersToGroup(String groupId, String[] memberIds, Current current) {
        try {
            chatCore.addMembersToGroup(groupId, memberIds);
        } catch (Exception e) {
            System.err.println("Error al agregar miembros al grupo: " + e.getMessage());
            throw e;
        }
    }
    
    @Override
    public String[] getGroupMembers(String groupId, Current current) {
        try {
            return chatCore.getGroupMembers(groupId);
        } catch (Exception e) {
            System.err.println("Error al obtener miembros del grupo: " + e.getMessage());
            throw e;
        }
    }
    
    @Override
    public void sendGroupMessage(String fromUserId, String groupId, String content, Current current) {
        try {
            chatCore.sendGroupMessage(fromUserId, groupId, content);
        } catch (Exception e) {
            System.err.println("Error al enviar mensaje al grupo: " + e.getMessage());
            throw e;
        }
    }
    
    @Override
    public Message[] getGroupChatMessages(String groupId, Current current) {
        try {
            List<Message> messages = chatCore.getGroupChatMessages(groupId);
            return messages.toArray(new Message[0]);
        } catch (Exception e) {
            System.err.println("Error al obtener mensajes del grupo: " + e.getMessage());
            throw e;
        }
    }
    
    @Override
    public ChatSummary[] getUserGroupChats(String userId, Current current) {
        try {
            List<ChatSummary> chats = chatCore.getUserGroupChats(userId);
            return chats.toArray(new ChatSummary[0]);
        } catch (Exception e) {
            System.err.println("Error al obtener grupos del usuario: " + e.getMessage());
            throw e;
        }
    }
}

ServerMain.java
package com.compunet.server;

import com.zeroc.Ice.*;

public class ServerMain {
    public static void main(String[] args) {
        int status = 0;
        Communicator communicator = null;
        
        try {
            // Inicializar Ice
            communicator = Util.initialize(args);
            
            // Crear el adapter
            ObjectAdapter adapter = communicator.createObjectAdapterWithEndpoints(
                "ChatAdapter", 
                "ws -h localhost -p 10000:tcp -h localhost -p 10001"
            );
            
            // Crear la lÃ³gica central compartida
            ChatCore chatCore = new ChatCore();
            
            // Inicializar usuarios de prueba
            initializeTestData(chatCore);
            
            // Crear e instalar los servants
            ChatServiceI chatService = new ChatServiceI(chatCore);
            GroupServiceI groupService = new GroupServiceI(chatCore);
            
            adapter.add(chatService, Util.stringToIdentity("chat"));
            adapter.add(groupService, Util.stringToIdentity("group"));
            
            // Activar el adapter
            adapter.activate();
            
            System.out.println("===========================================");
            System.out.println("    Servidor de Chat iniciado");
            System.out.println("===========================================");
            System.out.println("WebSocket endpoint: ws://localhost:10000");
            System.out.println("TCP endpoint: tcp://localhost:10001");
            System.out.println("Servicios disponibles:");
            System.out.println("  - ChatService (identity: 'chat')");
            System.out.println("  - GroupService (identity: 'group')");
            System.out.println("===========================================");
            System.out.println("Presiona Ctrl+C para detener el servidor");
            System.out.println();
            
            // Esperar hasta que se apague el servidor
            communicator.waitForShutdown();
            
        } catch (Exception e) {
            System.err.println("Error en el servidor: " + e.getMessage());
            e.printStackTrace();
            status = 1;
        } finally {
            if (communicator != null) {
                try {
                    communicator.destroy();
                } catch (Exception e) {
                    System.err.println("Error al destruir el comunicador: " + e.getMessage());
                    status = 1;
                }
            }
        }
        
        System.exit(status);
    }
    
    private static void initializeTestData(ChatCore chatCore) {
        System.out.println("Inicializando datos de prueba...");
        
        // Crear usuarios de prueba
        chatCore.registerUser("user1", "Alice");
        chatCore.registerUser("user2", "Bob");
        chatCore.registerUser("user3", "Charlie");
        chatCore.registerUser("user4", "Diana");
        
        // Crear un grupo de prueba
        String groupId = chatCore.createGroup("user1", "Proyecto Universitario", 
            new String[]{"user2", "user3"});
        
        // Enviar algunos mensajes de prueba
        chatCore.sendDirectMessage("user2", "user1", "Hola Alice, Â¿cÃ³mo estÃ¡s?");
        chatCore.sendDirectMessage("user1", "user2", "Â¡Hola Bob! Todo bien, Â¿y tÃº?");
        
        chatCore.sendGroupMessage("user1", groupId, "Â¡Bienvenidos al grupo del proyecto!");
        chatCore.sendGroupMessage("user2", groupId, "Gracias Alice, listo para trabajar.");
        
        System.out.println("Datos de prueba inicializados correctamente.");
        System.out.println();
    }
}

client/package.json
{
  "name": "compunet-chat-client",
  "version": "1.0.0",
  "description": "Cliente web para sistema de chat con ZeroC Ice",
  "main": "src/index.js",
  "scripts": {
    "build": "webpack --mode production",
    "dev": "webpack --mode development --watch",
    "serve": "webpack serve --mode development --open"
  },
  "keywords": ["chat", "ice", "zeroc"],
  "author": "",
  "license": "MIT",
  "devDependencies": {
    "webpack": "^5.88.0",
    "webpack-cli": "^5.1.4",
    "webpack-dev-server": "^4.15.1",
    "html-webpack-plugin": "^5.5.3",
    "css-loader": "^6.8.1",
    "style-loader": "^3.3.3"
  },
  "dependencies": {
    "ice": "^3.7.10"
  }
}

client/webpack.config.js
const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');

module.exports = {
  entry: './src/index.js',
  output: {
    filename: 'bundle.js',
    path: path.resolve(__dirname, 'dist'),
    clean: true
  },
  module: {
    rules: [
      {
        test: /\.css$/i,
        use: ['style-loader', 'css-loader']
      }
    ]
  },
  plugins: [
    new HtmlWebpackPlugin({
      template: './src/index.html',
      filename: 'index.html'
    })
  ],
  devServer: {
    static: {
      directory: path.join(__dirname, 'dist')
    },
    compress: true,
    port: 8080,
    hot: true
  },
  resolve: {
    extensions: ['.js'],
    fallback: {
      "buffer": false,
      "crypto": false,
      "stream": false,
      "util": false,
      "path": false,
      "fs": false
    }
  },
  mode: 'development'
};


client/src/index.html
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CompuNet Chat</title>
</head>
<body>
    <div class="app-container">
        <!-- Sidebar con lista de chats -->
        <div class="sidebar">
            <div class="sidebar-header">
                <h2>Chats</h2>
                <div class="user-info">
                    <span id="current-user-name">Usuario</span>
                </div>
            </div>
            
            <div class="sidebar-actions">
                <button id="btn-new-group" class="btn-action">+ Nuevo Grupo</button>
                <button id="btn-refresh-chats" class="btn-action">ğŸ”„ Actualizar</button>
            </div>
            
            <div class="chat-list" id="chat-list">
                <!-- La lista de chats se renderizarÃ¡ dinÃ¡micamente aquÃ­ -->
            </div>
        </div>
        
        <!-- Ãrea principal de chat -->
        <div class="chat-area">
            <div class="chat-header" id="chat-header">
                <h3 id="chat-name">Selecciona un chat</h3>
                <span id="chat-type" class="chat-type-badge"></span>
            </div>
            
            <div class="messages-container" id="messages-container">
                <div class="empty-state">
                    <p>Selecciona un chat para ver los mensajes</p>
                </div>
            </div>
            
            <div class="message-input-container">
                <input 
                    type="text" 
                    id="message-input" 
                    placeholder="Escribe un mensaje..." 
                    disabled
                />
                <button id="btn-send-message" class="btn-send" disabled>Enviar</button>
            </div>
        </div>
    </div>
    
    <!-- Modal para crear grupos -->
    <div id="modal-new-group" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Crear Nuevo Grupo</h3>
                <button class="modal-close" id="modal-close">&times;</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="group-name">Nombre del grupo:</label>
                    <input type="text" id="group-name" placeholder="Ej: Proyecto Universitario" />
                </div>
                <div class="form-group">
                    <label>Selecciona miembros:</label>
                    <div id="users-list" class="users-list">
                        <!-- Lista de usuarios disponibles -->
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button id="btn-cancel-group" class="btn-secondary">Cancelar</button>
                <button id="btn-create-group" class="btn-primary">Crear Grupo</button>
            </div>
        </div>
    </div>
    
    <!-- Loading indicator -->
    <div id="loading" class="loading-overlay">
        <div class="spinner"></div>
        <p>Conectando al servidor...</p>
    </div>
</body>
</html>

client/src/styles.css
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
    background-color: #f0f2f5;
    height: 100vh;
    overflow: hidden;
}

.app-container {
    display: flex;
    height: 100vh;
    max-width: 1600px;
    margin: 0 auto;
    background-color: white;
    box-shadow: 0 0 20px rgba(0, 0, 0, 0.1);
}

/* Sidebar */
.sidebar {
    width: 350px;
    background-color: #fff;
    border-right: 1px solid #e9edef;
    display: flex;
    flex-direction: column;
}

.sidebar-header {
    padding: 20px;
    background-color: #008069;
    color: white;
}

.sidebar-header h2 {
    font-size: 20px;
    margin-bottom: 8px;
}

.user-info {
    font-size: 14px;
    opacity: 0.9;
}

.sidebar-actions {
    padding: 10px;
    display: flex;
    gap: 10px;
    border-bottom: 1px solid #e9edef;
}

.btn-action {
    flex: 1;
    padding: 8px 12px;
    background-color: #008069;
    color: white;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-size: 13px;
    transition: background-color 0.2s;
}

.btn-action:hover {
    background-color: #00695c;
}

.chat-list {
    flex: 1;
    overflow-y: auto;
}

.chat-item {
    padding: 15px 20px;
    border-bottom: 1px solid #e9edef;
    cursor: pointer;
    transition: background-color 0.2s;
}

.chat-item:hover {
    background-color: #f5f6f6;
}

.chat-item.active {
    background-color: #e9edef;
}

.chat-item-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 5px;
}

.chat-item-name {
    font-weight: 600;
    font-size: 16px;
    color: #111b21;
}

.chat-item-time {
    font-size: 12px;
    color: #667781;
}

.chat-item-preview {
    font-size: 14px;
    color: #667781;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.chat-item-badge {
    display: inline-block;
    padding: 2px 6px;
    background-color: #008069;
    color: white;
    border-radius: 10px;
    font-size: 10px;
    margin-left: 8px;
}

/* Chat Area */
.chat-area {
    flex: 1;
    display: flex;
    flex-direction: column;
    background-color: #efeae2;
}

.chat-header {
    padding: 15px 20px;
    background-color: #f0f2f5;
    border-bottom: 1px solid #d1d7db;
    display: flex;
    align-items: center;
    justify-content: space-between;
}

.chat-header h3 {
    font-size: 18px;
    color: #111b21;
}

.chat-type-badge {
    padding: 4px 10px;
    background-color: #008069;
    color: white;
    border-radius: 12px;
    font-size: 12px;
}

.messages-container {
    flex: 1;
    overflow-y: auto;
    padding: 20px;
    background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAYAAACNMs+9AAAAGElEQVQYlWNgYGD4z0AEYBxVOKpwUBUCAEfGAgHWqMl7AAAAAElFTkSuQmCC');
}

.empty-state {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100%;
    color: #667781;
    font-size: 16px;
}

.message {
    margin-bottom: 12px;
    display: flex;
}

.message.sent {
    justify-content: flex-end;
}

.message.received {
    justify-content: flex-start;
}

.message-bubble {
    max-width: 65%;
    padding: 8px 12px;
    border-radius: 8px;
    box-shadow: 0 1px 1px rgba(0, 0, 0, 0.1);
}

.message.sent .message-bubble {
    background-color: #d9fdd3;
}

.message.received .message-bubble {
    background-color: #ffffff;
}

.message-sender {
    font-weight: 600;
    color: #008069;
    font-size: 13px;
    margin-bottom: 4px;
}

.message-content {
    color: #111b21;
    font-size: 14px;
    word-wrap: break-word;
    margin-bottom: 4px;
}

.message-time {
    font-size: 11px;
    color: #667781;
    text-align: right;
}

.message-input-container {
    padding: 10px 20px;
    background-color: #f0f2f5;
    display: flex;
    gap: 10px;
}

#message-input {
    flex: 1;
    padding: 12px 16px;
    border: none;
    border-radius: 8px;
    font-size: 15px;
    outline: none;
}

#message-input:disabled {
    background-color: #e9edef;
    cursor: not-allowed;
}

.btn-send {
    padding: 12px 24px;
    background-color: #008069;
    color: white;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-size: 15px;
    font-weight: 600;
    transition: background-color 0.2s;
}

.btn-send:hover:not(:disabled) {
    background-color: #00695c;
}

.btn-send:disabled {
    background-color: #d1d7db;
    cursor: not-allowed;
}

/* Modal */
.modal {
    display: none;
    position: fixed;
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.5);
}

.modal.show {
    display: flex;
    justify-content: center;
    align-items: center;
}

.modal-content {
    background-color: white;
    border-radius: 12px;
    width: 500px;
    max-width: 90%;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
}

.modal-header {
    padding: 20px;
    border-bottom: 1px solid #e9edef;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.modal-header h3 {
    font-size: 18px;
    color: #111b21;
}

.modal-close {
    background: none;
    border: none;
    font-size: 28px;
    color: #667781;
    cursor: pointer;
}

.modal-body {
    padding: 20px;
}

.form-group {
    margin-bottom: 20px;
}

.form-group label {
    display: block;
    margin-bottom: 8px;
    font-weight: 600;
    color: #111b21;
}

.form-group input {
    width: 100%;
    padding: 10px;
    border: 1px solid #d1d7db;
    border-radius: 6px;
    font-size: 14px;
}

.users-list {
    max-height: 200px;
    overflow-y: auto;
    border: 1px solid #e9edef;
    border-radius: 6px;
    padding: 10px;
}

.user-checkbox {
    display: flex;
    align-items: center;
    padding: 8px;
    cursor: pointer;
    border-radius: 4px;
}

.user-checkbox:hover {
    background-color: #f5f6f6;
}

.user-checkbox input {
    margin-right: 10px;
}

.modal-footer {
    padding: 15px 20px;
    border-top: 1px solid #e9edef;
    display: flex;
    justify-content: flex-end;
    gap: 10px;
}

.btn-primary, .btn-secondary {
    padding: 10px 20px;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    font-size: 14px;
    font-weight: 600;
}

.btn-primary {
    background-color: #008069;
    color: white;
}

.btn-primary:hover {
    background-color: #00695c;
}

.btn-secondary {
    background-color: #e9edef;
    color: #111b21;
}

.btn-secondary:hover {
    background-color: #d1d7db;
}

/* Loading */
.loading-overlay {
    display: none;
    position: fixed;
    z-index: 2000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.7);
    justify-content: center;
    align-items: center;
    flex-direction: column;
}

.loading-overlay.show {
    display: flex;
}

.spinner {
    border: 4px solid #f3f3f3;
    border-top: 4px solid #008069;
    border-radius: 50%;
    width: 50px;
    height: 50px;
    animation: spin 1s linear infinite;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

.loading-overlay p {
    color: white;
    margin-top: 20px;
    font-size: 16px;
}

/* Scrollbar personalizado */
::-webkit-scrollbar {
    width: 6px;
}

::-webkit-scrollbar-track {
    background: #f1f1f1;
}

::-webkit-scrollbar-thumb {
    background: #888;
    border-radius: 3px;
}

::-webkit-scrollbar-thumb:hover {
    background: #555;
}

client/src/IceConnectionManager.js
const Ice = require('ice').Ice;

// Importar las clases generadas desde los archivos .ice
// Nota: Estos archivos deben ser generados con slice2js y copiados al proyecto cliente
const compunet = require('./generated/compunet');

class IceConnectionManager {
    constructor() {
        this.communicator = null;
        this.chatServicePrx = null;
        this.groupServicePrx = null;
        this.isConnected = false;
    }

    async initialize() {
        try {
            console.log('Inicializando conexiÃ³n Ice...');
            
            // Inicializar el comunicador Ice
            this.communicator = Ice.initialize();
            
            // Crear proxies para los servicios
            const chatBase = this.communicator.stringToProxy("chat:ws -h localhost -p 10000");
            this.chatServicePrx = await compunet.ChatServicePrx.checkedCast(chatBase);
            
            const groupBase = this.communicator.stringToProxy("group:ws -h localhost -p 10000");
            this.groupServicePrx = await compunet.GroupServicePrx.checkedCast(groupBase);
            
            if (!this.chatServicePrx || !this.groupServicePrx) {
                throw new Error("No se pudieron crear los proxies de los servicios");
            }
            
            this.isConnected = true;
            console.log('ConexiÃ³n Ice establecida correctamente');
            
            return true;
        } catch (error) {
            console.error('Error al inicializar Ice:', error);
            this.isConnected = false;
            throw error;
        }
    }

    async shutdown() {
        if (this.communicator) {
            try {
                await this.communicator.destroy();
                this.isConnected = false;
                console.log('ConexiÃ³n Ice cerrada');
            } catch (error) {
                console.error('Error al cerrar la conexiÃ³n Ice:', error);
            }
        }
    }

    // === MÃ©todos de ChatService ===

    async registerUser(userId, userName) {
        if (!this.isConnected) throw new Error('No hay conexiÃ³n con el servidor');
        try {
            await this.chatServicePrx.registerUser(userId, userName);
            console.log(`Usuario registrado: ${userId}`);
        } catch (error) {
            console.error('Error al registrar usuario:', error);
            throw error;
        }
    }

    async getUser(userId) {
        if (!this.isConnected) throw new Error('No hay conexiÃ³n con el servidor');
        try {
            return await this.chatServicePrx.getUser(userId);
        } catch (error) {
            console.error('Error al obtener usuario:', error);
            throw error;
        }
    }

    async getAllUsers() {
        if (!this.isConnected) throw new Error('No hay conexiÃ³n con el servidor');
        try {
            return await this.chatServicePrx.getAllUsers();
        } catch (error) {
            console.error('Error al obtener usuarios:', error);
            throw error;
        }
    }

    async sendDirectMessage(fromUserId, toUserId, content) {
        if (!this.isConnected) throw new Error('No hay conexiÃ³n con el servidor');
        try {
            await this.chatServicePrx.sendDirectMessage(fromUserId, toUserId, content);
            console.log(`Mensaje enviado de ${fromUserId} a ${toUserId}`);
        } catch (error) {
            console.error('Error al enviar mensaje directo:', error);
            throw error;
        }
    }

    async getDirectChatMessages(userId, otherUserId) {
        if (!this.isConnected) throw new Error('No hay conexiÃ³n con el servidor');
        try {
            return await this.chatServicePrx.getDirectChatMessages(userId, otherUserId);
        } catch (error) {
            console.error('Error al obtener mensajes directos:', error);
            throw error;
        }
    }

    async getUserDirectChats(userId) {
        if (!this.isConnected) throw new Error('No hay conexiÃ³n con el servidor');
        try {
            return await this.chatServicePrx.getUserDirectChats(userId);
        } catch (error) {
            console.error('Error al obtener chats directos:', error);
            throw error;
        }
    }

    // === MÃ©todos de GroupService ===

    async createGroup(ownerId, groupName, memberIds) {
        if (!this.isConnected) throw new Error('No hay conexiÃ³n con el servidor');
        try {
            const groupId = await this.groupServicePrx.createGroup(ownerId, groupName, memberIds);
            console.log(`Grupo creado: ${groupId}`);
            return groupId;
        } catch (error) {
            console.error('Error al crear grupo:', error);
            throw error;
        }
    }

    async addMembersToGroup(groupId, memberIds) {
        if (!this.isConnected) throw new Error('No hay conexiÃ³n con el servidor');
        try {
            await this.groupServicePrx.addMembersToGroup(groupId, memberIds);
            console.log(`Miembros agregados al grupo ${groupId}`);
        } catch (error) {
            console.error('Error al agregar miembros al grupo:', error);
            throw error;
        }
    }

    async getGroupMembers(groupId) {
        if (!this.isConnected) throw new Error('No hay conexiÃ³n con el servidor');
        try {
            return await this.groupServicePrx.getGroupMembers(groupId);
        } catch (error) {
            console.error('Error al obtener miembros del grupo:', error);
            throw error;
        }
    }

    async sendGroupMessage(fromUserId, groupId, content) {
        if (!this.isConnected) throw new Error('No hay conexiÃ³n con el servidor');
        try {
            await this.groupServicePrx.sendGroupMessage(fromUserId, groupId, content);
            console.log(`Mensaje enviado al grupo ${groupId}`);
        } catch (error) {
            console.error('Error al enviar mensaje al grupo:', error);
            throw error;
        }
    }

    async getGroupChatMessages(groupId) {
        if (!this.isConnected) throw new Error('No hay conexiÃ³n con el servidor');
        try {
            return await this.groupServicePrx.getGroupChatMessages(groupId);
        } catch (error) {
            console.error('Error al obtener mensajes del grupo:', error);
            throw error;
        }
    }

    async getUserGroupChats(userId) {
        if (!this.isConnected) throw new Error('No hay conexiÃ³n con el servidor');
        try {
            return await this.groupServicePrx.getUserGroupChats(userId);
        } catch (error) {
            console.error('Error al obtener grupos del usuario:', error);
            throw error;
        }
    }
}

// Exportar una instancia singleton
const iceManager = new IceConnectionManager();
module.exports = iceManager;

client/src/ChatStateManager.js
class ChatStateManager {
    constructor() {
        this.currentUserId = 'user1'; // Usuario fijo para esta iteraciÃ³n
        this.currentUserName = 'Alice';
        this.chats = []; // Array de ChatSummary (directos + grupos)
        this.activeChat = null; // {id, name, isGroup}
        this.activeMessages = []; // Array de Messages del chat activo
        this.allUsers = []; // Todos los usuarios disponibles
    }

    // === GestiÃ³n de usuario actual ===

    setCurrentUser(userId, userName) {
        this.currentUserId = userId;
        this.currentUserName = userName;
    }

    getCurrentUserId() {
        return this.currentUserId;
    }

    getCurrentUserName() {
        return this.currentUserName;
    }

    // === GestiÃ³n de chats ===

    setChats(chats) {
        // Combinar chats directos y de grupo, ordenados por timestamp
        this.chats = chats.sort((a, b) => 
            b.lastMessageTimestamp - a.lastMessageTimestamp
        );
    }

    getChats() {
        return this.chats;
    }

    addChat(chatSummary) {
        // Verificar si el chat ya existe
        const existingIndex = this.chats.findIndex(c => c.chatId === chatSummary.chatId);
        
        if (existingIndex >= 0) {
            // Actualizar el chat existente
            this.chats[existingIndex] = chatSummary;
        } else {
            // Agregar nuevo chat
            this.chats.push(chatSummary);
        }
        
        // Reordenar por timestamp
        this.chats.sort((a, b) => 
            b.lastMessageTimestamp - a.lastMessageTimestamp
        );
    }

    // === GestiÃ³n de chat activo ===

    setActiveChat(chatId, chatName, isGroup) {
        this.activeChat = {
            id: chatId,
            name: chatName,
            isGroup: isGroup
        };
        this.activeMessages = []; // Limpiar mensajes al cambiar de chat
    }

    getActiveChat() {
        return this.activeChat;
    }

    clearActiveChat() {
        this.activeChat = null;
        this.activeMessages = [];
    }

    // === GestiÃ³n de mensajes ===

    setActiveMessages(messages) {
        this.activeMessages = messages;
    }

    getActiveMessages() {
        return this.activeMessages;
    }

    addMessage(message) {
        this.activeMessages.push(message);
        
        // Actualizar el resumen del chat en la lista
        if (this.activeChat) {
            const chatIndex = this.chats.findIndex(c => c.chatId === this.activeChat.id);
            if (chatIndex >= 0) {
                this.chats[chatIndex].lastMessageContent = message.content;
                this.chats[chatIndex].lastMessageTimestamp = message.timestamp;
                
                // Reordenar
                this.chats.sort((a, b) => 
                    b.lastMessageTimestamp - a.lastMessageTimestamp
                );
            }
        }
    }

    // === GestiÃ³n de usuarios ===

    setAllUsers(users) {
        this.allUsers = users;
    }

    getAllUsers() {
        return this.allUsers;
    }

    getUsersExceptCurrent() {
        return this.allUsers.filter(u => u.id !== this.currentUserId);
    }

    // === Utilidades ===

    isChatActive(chatId) {
        return this.activeChat && this.activeChat.id === chatId;
    }

    formatTimestamp(timestamp) {
        const date = new Date(timestamp);
        const now = new Date();
        
        // Si es hoy, mostrar solo hora
        if (date.toDateString() === now.toDateString()) {
            return date.toLocaleTimeString('es-ES', { 
                hour: '2-digit', 
                minute: '2-digit' 
            });
        }
        
        // Si es de esta semana, mostrar dÃ­a de la semana
        const daysDiff = Math.floor((now - date) / (1000 * 60 * 60 * 24));
        if (daysDiff < 7) {
            return date.toLocaleDateString('es-ES', { weekday: 'short' });
        }
        
        // De lo contrario, mostrar fecha completa
        return date.toLocaleDateString('es-ES', { 
            day: '2-digit', 
            month: '2-digit' 
        });
    }
}

// Exportar instancia singleton
const chatState = new ChatStateManager();
module.exports = chatState;

client/src/MessageSender.js
const iceManager = require('./IceConnectionManager');
const chatState = require('./ChatStateManager');

class MessageSender {
    async sendMessage(content) {
        const activeChat = chatState.getActiveChat();
        
        if (!activeChat) {
            throw new Error('No hay un chat activo');
        }

        if (!content || content.trim() === '') {
            throw new Error('El mensaje no puede estar vacÃ­o');
        }

        const userId = chatState.getCurrentUserId();

        try {
            if (activeChat.isGroup) {
                // Enviar mensaje a grupo
                await iceManager.sendGroupMessage(userId, activeChat.id, content.trim());
            } else {
                // Enviar mensaje directo
                await iceManager.sendDirectMessage(userId, activeChat.id, content.trim());
            }

            console.log(`Mensaje enviado exitosamente a ${activeChat.name}`);
            return true;
        } catch (error) {
            console.error('Error al enviar mensaje:', error);
            throw error;
        }
    }

    async sendDirectMessage(toUserId, content) {
        if (!content || content.trim() === '') {
            throw new Error('El mensaje no puede estar vacÃ­o');
        }

        const fromUserId = chatState.getCurrentUserId();

        try {
            await iceManager.sendDirectMessage(fromUserId, toUserId, content.trim());
            console.log(`Mensaje directo enviado a ${toUserId}`);
            return true;
        } catch (error) {
            console.error('Error al enviar mensaje directo:', error);
            throw error;
        }
    }

    async sendGroupMessage(groupId, content) {
        if (!content || content.trim() === '') {
            throw new Error('El mensaje no puede estar vacÃ­o');
        }

        const fromUserId = chatState.getCurrentUserId();

        try {
            await iceManager.sendGroupMessage(fromUserId, groupId, content.trim());
            console.log(`Mensaje enviado al grupo ${groupId}`);
            return true;
        } catch (error) {
            console.error('Error al enviar mensaje al grupo:', error);
            throw error;
        }
    }
}

// Exportar instancia singleton
const messageSender = new MessageSender();
module.exports = messageSender;

client/src/MessageReceiver.js
const iceManager = require('./IceConnectionManager');
const chatState = require('./ChatStateManager');

class MessageReceiver {
    async loadChatMessages(chatId, isGroup) {
        const userId = chatState.getCurrentUserId();

        try {
            let messages;

            if (isGroup) {
                // Obtener mensajes del grupo
                messages = await iceManager.getGroupChatMessages(chatId);
            } else {
                // Obtener mensajes del chat directo
                messages = await iceManager.getDirectChatMessages(userId, chatId);
            }

            chatState.setActiveMessages(messages);
            console.log(`Mensajes cargados: ${messages.length}`);
            
            return messages;
        } catch (error) {
            console.error('Error al cargar mensajes:', error);
            throw error;
        }
    }

    async refreshChats() {
        const userId = chatState.getCurrentUserId();

        try {
            // Obtener chats directos y de grupo en paralelo
            const [directChats, groupChats] = await Promise.all([
                iceManager.getUserDirectChats(userId),
                iceManager.getUserGroupChats(userId)
            ]);

            // Combinar ambos tipos de chats
            const allChats = [...directChats, ...groupChats];
            
            chatState.setChats(allChats);
            console.log(`Chats actualizados: ${allChats.length} total`);
            
            return allChats;
        } catch (error) {
            console.error('Error al actualizar chats:', error);
            throw error;
        }
    }

    async loadAllUsers() {
        try {
            const users = await iceManager.getAllUsers();
            chatState.setAllUsers(users);
            console.log(`Usuarios cargados: ${users.length}`);
            return users;
        } catch (error) {
            console.error('Error al cargar usuarios:', error);
            throw error;
        }
    }

    async refreshActiveChat() {
        const activeChat = chatState.getActiveChat();
        
        if (!activeChat) {
            console.log('No hay chat activo para actualizar');
            return null;
        }

        try {
            await this.loadChatMessages(activeChat.id, activeChat.isGroup);
            return chatState.getActiveMessages();
        } catch (error) {
            console.error('Error al actualizar el chat activo:', error);
            throw error;
        }
    }
}

// Exportar instancia singleton
const messageReceiver = new MessageReceiver();
module.exports = messageReceiver;

client/src/ChatController.js
const chatState = require('./ChatStateManager');
const messageSender = require('./MessageSender');
const messageReceiver = require('./MessageReceiver');
const iceManager = require('./IceConnectionManager');

class ChatUIController {
    constructor() {
        this.elements = {};
    }

    initialize() {
        // Obtener referencias a elementos del DOM
        this.elements = {
            chatList: document.getElementById('chat-list'),
            messagesContainer: document.getElementById('messages-container'),
            messageInput: document.getElementById('message-input'),
            btnSendMessage: document.getElementById('btn-send-message'),
            chatName: document.getElementById('chat-name'),
            chatType: document.getElementById('chat-type'),
            currentUserName: document.getElementById('current-user-name'),
            btnNewGroup: document.getElementById('btn-new-group'),
            btnRefreshChats: document.getElementById('btn-refresh-chats'),
            modalNewGroup: document.getElementById('modal-new-group'),
            modalClose: document.getElementById('modal-close'),
            btnCancelGroup: document.getElementById('btn-cancel-group'),
            btnCreateGroup: document.getElementById('btn-create-group'),
            groupNameInput: document.getElementById('group-name'),
            usersList: document.getElementById('users-list'),
            loading: document.getElementById('loading')
        };

        this.attachEventListeners();
        this.updateUserInfo();
    }

    attachEventListeners() {
        // Enviar mensaje
        this.elements.btnSendMessage.addEventListener('click', () => this.handleSendMessage());
        this.elements.messageInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                this.handleSendMessage();
            }
        });

        // Actualizar chats
        this.elements.btnRefreshChats.addEventListener('click', () => this.handleRefreshChats());

        // Modal de nuevo grupo
        this.elements.btnNewGroup.addEventListener('click', () => this.showNewGroupModal());
        this.elements.modalClose.addEventListener('click', () => this.hideNewGroupModal());
        this.elements.btnCancelGroup.addEventListener('click', () => this.hideNewGroupModal());
        this.elements.btnCreateGroup.addEventListener('click', () => this.handleCreateGroup());

        // Cerrar modal al hacer click fuera
        this.elements.modalNewGroup.addEventListener('click', (e) => {
            if (e.target === this.elements.modalNewGroup) {
                this.hideNewGroupModal();
            }
        });
    }

    updateUserInfo() {
        this.elements.currentUserName.textContent = chatState.getCurrentUserName();
    }

    // === Renderizado de chats ===

    renderChatList() {
        const chats = chatState.getChats();
        
        if (chats.length === 0) {
            this.elements.chatList.innerHTML = `
                <div style="padding: 20px; text-align: center; color: #667781;">
                    No tienes chats aÃºn.<br>
                    Crea un grupo para empezar.
                </div>
            `;
            return;
        }

        this.elements.chatList.innerHTML = '';

        chats.forEach(chat => {
            const chatItem = this.createChatItemElement(chat);
            this.elements.chatList.appendChild(chatItem);
        });
    }

    createChatItemElement(chat) {
        const div = document.createElement('div');
        div.className = 'chat-item';
        
        if (chatState.isChatActive(chat.chatId)) {
            div.classList.add('active');
        }

        const time = chatState.formatTimestamp(chat.lastMessageTimestamp);
        const badge = chat.isGroup ? '<span class="chat-item-badge">Grupo</span>' : '';

        div.innerHTML = `
            <div class="chat-item-header">
                <span class="chat-item-name">${chat.chatName}${badge}</span>
                <span class="chat-item-time">${time}</span>
            </div>
            <div class="chat-item-preview">${chat.lastMessageContent}</div>
        `;

        div.addEventListener('click', () => this.handleChatClick(chat));

        return div;
    }

    async handleChatClick(chat) {
        try {
            this.showLoading('Cargando mensajes...');
            
            // Establecer chat activo
            chatState.setActiveChat(chat.chatId, chat.chatName, chat.isGroup);
            
            // Cargar mensajes
            await messageReceiver.loadChatMessages(chat.chatId, chat.isGroup);
            
            // Actualizar UI
            this.updateChatHeader();
            this.renderMessages();
            this.enableMessageInput();
            this.renderChatList(); // Re-renderizar para actualizar selecciÃ³n
            
            this.hideLoading();
        } catch (error) {
            console.error('Error al seleccionar chat:', error);
            this.hideLoading();
            alert('Error al cargar el chat');
        }
    }

    // === Renderizado de mensajes ===

    renderMessages() {
        const messages = chatState.getActiveMessages();
        const activeChat = chatState.getActiveChat();
        
        if (!activeChat) {
            this.showEmptyState();
            return;
        }

        if (messages.length === 0) {
            this.elements.messagesContainer.innerHTML = `
                <div class="empty-state">
                    <p>No hay mensajes en este chat</p>
                </div>
            `;
            return;
        }

        this.elements.messagesContainer.innerHTML = '';

        messages.forEach(message => {
            const messageElement = this.createMessageElement(message);
            this.elements.messagesContainer.appendChild(messageElement);
        });

        // Scroll hacia abajo
        this.scrollToBottom();
    }

    createMessageElement(message) {
        const div = document.createElement('div');
        const isSent = message.senderId === chatState.getCurrentUserId();
        div.className = `message ${isSent ? 'sent' : 'received'}`;

        const time = chatState.formatTimestamp(message.timestamp);
        const showSender = !isSent && chatState.getActiveChat().isGroup;

        div.innerHTML = `
            <div class="message-bubble">
                ${showSender ? `<div class="message-sender">${message.senderName}</div>` : ''}
                <div class="message-content">${this.escapeHtml(message.content)}</div>
                <div class="message-time">${time}</div>
            </div>
        `;

        return div;
    }

    escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    scrollToBottom() {
        this.elements.messagesContainer.scrollTop = this.elements.messagesContainer.scrollHeight;
    }

    showEmptyState() {
        this.elements.messagesContainer.innerHTML = `
            <div class="empty-state">
                <p>Selecciona un chat para ver los mensajes</p>
            </div>
        `;
    }

    // === EnvÃ­o de mensajes ===

    async handleSendMessage() {
        const content = this.elements.messageInput.value.trim();
        
        if (!content) return;

        try {
            // Enviar mensaje
            await messageSender.sendMessage(content);
            
            // Limpiar input
            this.elements.messageInput.value = '';
            
            // Recargar mensajes del chat activo
            await messageReceiver.refreshActiveChat();
            
            // Re-renderizar mensajes
            this.renderMessages();
            
            // Actualizar lista de chats
            await this.handleRefreshChats();
            
        } catch (error) {
            console.error('Error al enviar mensaje:', error);
            alert('Error al enviar el mensaje');
        }
    }

    // === ActualizaciÃ³n de chats ===

    async handleRefreshChats() {
        try {
            await messageReceiver.refreshChats();
            this.renderChatList();
        } catch (error) {
            console.error('Error al actualizar chats:', error);
        }
    }

    // === Modal de nuevo grupo ===

    async showNewGroupModal() {
        try {
            // Cargar usuarios disponibles
            await messageReceiver.loadAllUsers();
            const users = chatState.getUsersExceptCurrent();
            
            // Renderizar lista de usuarios
            this.elements.usersList.innerHTML = '';
            users.forEach(user => {
                const label = document.createElement('label');
                label.className = 'user-checkbox';
                label.innerHTML = `
                    <input type="checkbox" value="${user.id}">
                    <span>${user.name} (${user.id})</span>
                `;
                this.elements.usersList.appendChild(label);
            });
            
            // Limpiar campo de nombre
            this.elements.groupNameInput.value = '';
            
            // Mostrar modal
            this.elements.modalNewGroup.classList.add('show');
        } catch (error) {
            console.error('Error al abrir modal de grupo:', error);
            alert('Error al cargar usuarios');
        }
    }

    hideNewGroupModal() {
        this.elements.modalNewGroup.classList.remove('show');
    }

    async handleCreateGroup() {
        const groupName = this.elements.groupNameInput.value.trim();
        
        if (!groupName) {
            alert('Debes ingresar un nombre para el grupo');
            return;
        }

        // Obtener miembros seleccionados
        const checkboxes = this.elements.usersList.querySelectorAll('input[type="checkbox"]:checked');
        const memberIds = Array.from(checkboxes).map(cb => cb.value);

        if (memberIds.length === 0) {
            alert('Debes seleccionar al menos un miembro');
            return;
        }

        try {
            this.showLoading('Creando grupo...');
            
            const ownerId = chatState.getCurrentUserId();
            await iceManager.createGroup(ownerId, groupName, memberIds);
            
            this.hideNewGroupModal();
            
            // Actualizar lista de chats
            await this.handleRefreshChats();
            
            this.hideLoading();
            
            alert('Grupo creado exitosamente');
        } catch (error) {
            console.error('Error al crear grupo:', error);
            this.hideLoading();
            alert('Error al crear el grupo');
        }
    }

    // === UI Helpers ===

    updateChatHeader() {
        const activeChat = chatState.getActiveChat();
        
        if (!activeChat) {
            this.elements.chatName.textContent = 'Selecciona un chat';
            this.elements.chatType.textContent = '';
            return;
        }

        this.elements.chatName.textContent = activeChat.name;
        this.elements.chatType.textContent = activeChat.isGroup ? 'Grupo' : 'Directo';
    }

    enableMessageInput() {
        this.elements.messageInput.disabled = false;
        this.elements.btnSendMessage.disabled = false;
        this.elements.messageInput.focus();
    }

    disableMessageInput() {
        this.elements.messageInput.disabled = true;
        this.elements.btnSendMessage.disabled = true;
    }

    showLoading(message = 'Cargando...') {
        this.elements.loading.querySelector('p').textContent = message;
        this.elements.loading.classList.add('show');
    }

    hideLoading() {
        this.elements.loading.classList.remove('show');
    }
}

// Exportar instancia singleton
const uiController = new ChatUIController();
module.exports = uiController;

client/src/index.js
// Importar estilos
import './styles.css';

// Importar mÃ³dulos
const iceManager = require('./IceConnectionManager');
const chatState = require('./ChatStateManager');
const messageReceiver = require('./MessageReceiver');
const uiController = require('./ChatUIController');

// FunciÃ³n principal de inicializaciÃ³n
async function initializeApp() {
    try {
        // Mostrar loading
        uiController.showLoading('Conectando al servidor...');
        
        // Inicializar UI
        uiController.initialize();
        
        // Conectar al servidor Ice
        await iceManager.initialize();
        
        console.log('AplicaciÃ³n inicializada correctamente');
        
        // Cargar datos iniciales
        await loadInitialData();
        
        // Ocultar loading
        uiController.hideLoading();
        
    } catch (error) {
        console.error('Error al inicializar la aplicaciÃ³n:', error);
        uiController.hideLoading();
        
        // Mostrar error al usuario
        alert('No se pudo conectar al servidor. Por favor, asegÃºrate de que el servidor estÃ¡ ejecutÃ¡ndose en localhost:10000');
    }
}

async function loadInitialData() {
    try {
        console.log('Cargando datos iniciales...');
        
        // Cargar chats del usuario
        await messageReceiver.refreshChats();
        
        // Renderizar lista de chats
        uiController.renderChatList();
        
        console.log('Datos iniciales cargados');
    } catch (error) {
        console.error('Error al cargar datos iniciales:', error);
        throw error;
    }
}

// Manejar cierre de ventana
window.addEventListener('beforeunload', async () => {
    try {
        await iceManager.shutdown();
    } catch (error) {
        console.error('Error al cerrar conexiÃ³n:', error);
    }
});

// Inicializar cuando el DOM estÃ© listo
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeApp);
} else {
    initializeApp();
}

// Exportar para depuraciÃ³n en consola
window.chatDebug = {
    iceManager,
    chatState,
    messageReceiver,
    uiController
};


generate-ice-code.sh
#!/bin/bash

# Script para generar cÃ³digo Ice para el servidor y cliente
# Uso: ./generate-ice-code.sh

set -e

echo "======================================"
echo "  Generador de CÃ³digo Ice"
echo "======================================"
echo ""

# Verificar que slice2java y slice2js estÃ©n disponibles
if ! command -v slice2java &> /dev/null; then
    echo "âŒ Error: slice2java no estÃ¡ instalado o no estÃ¡ en el PATH"
    echo "   Por favor instala ZeroC Ice 3.7.x"
    exit 1
fi

if ! command -v slice2js &> /dev/null; then
    echo "âŒ Error: slice2js no estÃ¡ instalado o no estÃ¡ en el PATH"
    echo "   Por favor instala ZeroC Ice 3.7.x"
    exit 1
fi

echo "âœ… Herramientas Ice encontradas"
echo ""

# Rutas
ICE_FILE="server/src/main/slice/chat.ice"
SERVER_OUTPUT="server/build/generated-src"
CLIENT_OUTPUT="client/src/generated"

# Verificar que el archivo .ice existe
if [ ! -f "$ICE_FILE" ]; then
    echo "âŒ Error: No se encuentra el archivo $ICE_FILE"
    exit 1
fi

echo "ğŸ“„ Archivo Ice: $ICE_FILE"
echo ""

# Generar cÃ³digo Java para el servidor
echo "ğŸ”¨ Generando cÃ³digo Java para el servidor..."
mkdir -p "$SERVER_OUTPUT"
slice2java --output-dir "$SERVER_OUTPUT" "$ICE_FILE"

if [ $? -eq 0 ]; then
    echo "âœ… CÃ³digo Java generado en: $SERVER_OUTPUT"
else
    echo "âŒ Error al generar cÃ³digo Java"
    exit 1
fi

echo ""

# Generar cÃ³digo JavaScript para el cliente
echo "ğŸ”¨ Generando cÃ³digo JavaScript para el cliente..."
mkdir -p "$CLIENT_OUTPUT"
slice2js --output-dir "$CLIENT_OUTPUT" "$ICE_FILE"

if [ $? -eq 0 ]; then
    echo "âœ… CÃ³digo JavaScript generado en: $CLIENT_OUTPUT"
else
    echo "âŒ Error al generar cÃ³digo JavaScript"
    exit 1
fi

echo ""
echo "======================================"
echo "  âœ… GeneraciÃ³n completada"
echo "======================================"
echo ""
echo "Siguiente paso:"
echo "  1. Compilar el servidor: cd server && ./gradlew build"
echo "  2. Instalar dependencias del cliente: cd client && npm install"
echo "  3. Ejecutar el servidor: cd server && ./gradlew run"
echo "  4. Ejecutar el cliente: cd client && npm run serve"
echo ""

server/config.properties
# ConfiguraciÃ³n del servidor Ice para CompuNet Chat

# Endpoints del adaptador
ChatAdapter.Endpoints=ws -h localhost -p 10000:tcp -h localhost -p 10001

# ConfiguraciÃ³n de Ice
Ice.ThreadPool.Server.Size=4
Ice.ThreadPool.Server.SizeMax=10

# Nivel de advertencias y errores
Ice.Warn.Connections=1
Ice.Warn.Dispatch=1

# Timeout para operaciones (en milisegundos)
Ice.Connection.IdleTimeout=60

# ConfiguraciÃ³n de protocolo
Ice.Default.Protocol=tcp

# Logging
Ice.Trace.Network=0
Ice.Trace.Protocol=0

# CompresiÃ³n de mensajes
Ice.Compression.Level=1

# TamaÃ±o mÃ¡ximo de mensajes (en KB)
Ice.MessageSizeMax=1024