/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/css-loader/dist/cjs.js!./src/styles.css":
/*!**************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/styles.css ***!
  \**************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/noSourceMaps.js */ \"./node_modules/css-loader/dist/runtime/noSourceMaps.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/getUrl.js */ \"./node_modules/css-loader/dist/runtime/getUrl.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__);\n// Imports\n\n\n\nvar ___CSS_LOADER_URL_IMPORT_0___ = new URL(/* asset import */ __webpack_require__(/*! data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAYAAACNMs+9AAAAGElEQVQYlWNgYGD4z0AEYBxVOKpwUBUCAEfGAgHWqMl7AAAAAElFTkSuQmCC */ \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAYAAACNMs+9AAAAGElEQVQYlWNgYGD4z0AEYBxVOKpwUBUCAEfGAgHWqMl7AAAAAElFTkSuQmCC\"), __webpack_require__.b);\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\nvar ___CSS_LOADER_URL_REPLACEMENT_0___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_0___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `* {\r\n    margin: 0;\r\n    padding: 0;\r\n    box-sizing: border-box;\r\n}\r\n\r\nbody {\r\n    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;\r\n    background-color: #f0f2f5;\r\n    height: 100vh;\r\n    overflow: hidden;\r\n}\r\n\r\n.app-container {\r\n    display: flex;\r\n    height: 100vh;\r\n    max-width: 1600px;\r\n    margin: 0 auto;\r\n    background-color: white;\r\n    box-shadow: 0 0 20px rgba(0, 0, 0, 0.1);\r\n}\r\n\r\n/* Sidebar */\r\n.sidebar {\r\n    width: 350px;\r\n    background-color: #fff;\r\n    border-right: 1px solid #e9edef;\r\n    display: flex;\r\n    flex-direction: column;\r\n}\r\n\r\n.sidebar-header {\r\n    padding: 20px;\r\n    background-color: #008069;\r\n    color: white;\r\n}\r\n\r\n.sidebar-header h2 {\r\n    font-size: 20px;\r\n    margin-bottom: 8px;\r\n}\r\n\r\n.user-info {\r\n    font-size: 14px;\r\n    opacity: 0.9;\r\n}\r\n\r\n.sidebar-actions {\r\n    padding: 10px;\r\n    display: flex;\r\n    gap: 10px;\r\n    border-bottom: 1px solid #e9edef;\r\n}\r\n\r\n.btn-action {\r\n    flex: 1;\r\n    padding: 8px 12px;\r\n    background-color: #008069;\r\n    color: white;\r\n    border: none;\r\n    border-radius: 8px;\r\n    cursor: pointer;\r\n    font-size: 13px;\r\n    transition: background-color 0.2s;\r\n}\r\n\r\n.btn-action:hover {\r\n    background-color: #00695c;\r\n}\r\n\r\n.chat-list {\r\n    flex: 1;\r\n    overflow-y: auto;\r\n}\r\n\r\n.chat-item {\r\n    padding: 15px 20px;\r\n    border-bottom: 1px solid #e9edef;\r\n    cursor: pointer;\r\n    transition: background-color 0.2s;\r\n}\r\n\r\n.chat-item:hover {\r\n    background-color: #f5f6f6;\r\n}\r\n\r\n.chat-item.active {\r\n    background-color: #e9edef;\r\n}\r\n\r\n.chat-item-header {\r\n    display: flex;\r\n    justify-content: space-between;\r\n    align-items: center;\r\n    margin-bottom: 5px;\r\n}\r\n\r\n.chat-item-name {\r\n    font-weight: 600;\r\n    font-size: 16px;\r\n    color: #111b21;\r\n}\r\n\r\n.chat-item-time {\r\n    font-size: 12px;\r\n    color: #667781;\r\n}\r\n\r\n.chat-item-preview {\r\n    font-size: 14px;\r\n    color: #667781;\r\n    white-space: nowrap;\r\n    overflow: hidden;\r\n    text-overflow: ellipsis;\r\n}\r\n\r\n.chat-item-badge {\r\n    display: inline-block;\r\n    padding: 2px 6px;\r\n    background-color: #008069;\r\n    color: white;\r\n    border-radius: 10px;\r\n    font-size: 10px;\r\n    margin-left: 8px;\r\n}\r\n\r\n/* Chat Area */\r\n.chat-area {\r\n    flex: 1;\r\n    display: flex;\r\n    flex-direction: column;\r\n    background-color: #efeae2;\r\n}\r\n\r\n.chat-header {\r\n    padding: 15px 20px;\r\n    background-color: #f0f2f5;\r\n    border-bottom: 1px solid #d1d7db;\r\n    display: flex;\r\n    align-items: center;\r\n    justify-content: space-between;\r\n}\r\n\r\n.chat-header h3 {\r\n    font-size: 18px;\r\n    color: #111b21;\r\n}\r\n\r\n.chat-type-badge {\r\n    padding: 4px 10px;\r\n    background-color: #008069;\r\n    color: white;\r\n    border-radius: 12px;\r\n    font-size: 12px;\r\n}\r\n\r\n.messages-container {\r\n    flex: 1;\r\n    overflow-y: auto;\r\n    padding: 20px;\r\n    background-image: url(${___CSS_LOADER_URL_REPLACEMENT_0___});\r\n}\r\n\r\n.empty-state {\r\n    display: flex;\r\n    justify-content: center;\r\n    align-items: center;\r\n    height: 100%;\r\n    color: #667781;\r\n    font-size: 16px;\r\n}\r\n\r\n.message {\r\n    margin-bottom: 12px;\r\n    display: flex;\r\n}\r\n\r\n.message.sent {\r\n    justify-content: flex-end;\r\n}\r\n\r\n.message.received {\r\n    justify-content: flex-start;\r\n}\r\n\r\n.message-bubble {\r\n    max-width: 65%;\r\n    padding: 8px 12px;\r\n    border-radius: 8px;\r\n    box-shadow: 0 1px 1px rgba(0, 0, 0, 0.1);\r\n}\r\n\r\n.message.sent .message-bubble {\r\n    background-color: #d9fdd3;\r\n}\r\n\r\n.message.received .message-bubble {\r\n    background-color: #ffffff;\r\n}\r\n\r\n.message-sender {\r\n    font-weight: 600;\r\n    color: #008069;\r\n    font-size: 13px;\r\n    margin-bottom: 4px;\r\n}\r\n\r\n.message-content {\r\n    color: #111b21;\r\n    font-size: 14px;\r\n    word-wrap: break-word;\r\n    margin-bottom: 4px;\r\n}\r\n\r\n.message-time {\r\n    font-size: 11px;\r\n    color: #667781;\r\n    text-align: right;\r\n}\r\n\r\n.message-input-container {\r\n    padding: 10px 20px;\r\n    background-color: #f0f2f5;\r\n    display: flex;\r\n    gap: 10px;\r\n}\r\n\r\n#message-input {\r\n    flex: 1;\r\n    padding: 12px 16px;\r\n    border: none;\r\n    border-radius: 8px;\r\n    font-size: 15px;\r\n    outline: none;\r\n}\r\n\r\n#message-input:disabled {\r\n    background-color: #e9edef;\r\n    cursor: not-allowed;\r\n}\r\n\r\n.btn-send {\r\n    padding: 12px 24px;\r\n    background-color: #008069;\r\n    color: white;\r\n    border: none;\r\n    border-radius: 8px;\r\n    cursor: pointer;\r\n    font-size: 15px;\r\n    font-weight: 600;\r\n    transition: background-color 0.2s;\r\n}\r\n\r\n.btn-send:hover:not(:disabled) {\r\n    background-color: #00695c;\r\n}\r\n\r\n.btn-send:disabled {\r\n    background-color: #d1d7db;\r\n    cursor: not-allowed;\r\n}\r\n\r\n/* Modal */\r\n.modal {\r\n    display: none;\r\n    position: fixed;\r\n    z-index: 1000;\r\n    left: 0;\r\n    top: 0;\r\n    width: 100%;\r\n    height: 100%;\r\n    background-color: rgba(0, 0, 0, 0.5);\r\n}\r\n\r\n.modal.show {\r\n    display: flex;\r\n    justify-content: center;\r\n    align-items: center;\r\n}\r\n\r\n.modal-content {\r\n    background-color: white;\r\n    border-radius: 12px;\r\n    width: 500px;\r\n    max-width: 90%;\r\n    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);\r\n}\r\n\r\n.modal-header {\r\n    padding: 20px;\r\n    border-bottom: 1px solid #e9edef;\r\n    display: flex;\r\n    justify-content: space-between;\r\n    align-items: center;\r\n}\r\n\r\n.modal-header h3 {\r\n    font-size: 18px;\r\n    color: #111b21;\r\n}\r\n\r\n.modal-close {\r\n    background: none;\r\n    border: none;\r\n    font-size: 28px;\r\n    color: #667781;\r\n    cursor: pointer;\r\n}\r\n\r\n.modal-body {\r\n    padding: 20px;\r\n}\r\n\r\n.form-group {\r\n    margin-bottom: 20px;\r\n}\r\n\r\n.form-group label {\r\n    display: block;\r\n    margin-bottom: 8px;\r\n    font-weight: 600;\r\n    color: #111b21;\r\n}\r\n\r\n.form-group input {\r\n    width: 100%;\r\n    padding: 10px;\r\n    border: 1px solid #d1d7db;\r\n    border-radius: 6px;\r\n    font-size: 14px;\r\n}\r\n\r\n.users-list {\r\n    max-height: 200px;\r\n    overflow-y: auto;\r\n    border: 1px solid #e9edef;\r\n    border-radius: 6px;\r\n    padding: 10px;\r\n}\r\n\r\n.user-checkbox {\r\n    display: flex;\r\n    align-items: center;\r\n    padding: 8px;\r\n    cursor: pointer;\r\n    border-radius: 4px;\r\n}\r\n\r\n.user-checkbox:hover {\r\n    background-color: #f5f6f6;\r\n}\r\n\r\n.user-checkbox input {\r\n    margin-right: 10px;\r\n}\r\n\r\n.modal-footer {\r\n    padding: 15px 20px;\r\n    border-top: 1px solid #e9edef;\r\n    display: flex;\r\n    justify-content: flex-end;\r\n    gap: 10px;\r\n}\r\n\r\n.btn-primary, .btn-secondary {\r\n    padding: 10px 20px;\r\n    border: none;\r\n    border-radius: 6px;\r\n    cursor: pointer;\r\n    font-size: 14px;\r\n    font-weight: 600;\r\n}\r\n\r\n.btn-primary {\r\n    background-color: #008069;\r\n    color: white;\r\n}\r\n\r\n.btn-primary:hover {\r\n    background-color: #00695c;\r\n}\r\n\r\n.btn-secondary {\r\n    background-color: #e9edef;\r\n    color: #111b21;\r\n}\r\n\r\n.btn-secondary:hover {\r\n    background-color: #d1d7db;\r\n}\r\n\r\n/* Loading */\r\n.loading-overlay {\r\n    display: none;\r\n    position: fixed;\r\n    z-index: 2000;\r\n    left: 0;\r\n    top: 0;\r\n    width: 100%;\r\n    height: 100%;\r\n    background-color: rgba(0, 0, 0, 0.7);\r\n    justify-content: center;\r\n    align-items: center;\r\n    flex-direction: column;\r\n}\r\n\r\n.loading-overlay.show {\r\n    display: flex;\r\n}\r\n\r\n.spinner {\r\n    border: 4px solid #f3f3f3;\r\n    border-top: 4px solid #008069;\r\n    border-radius: 50%;\r\n    width: 50px;\r\n    height: 50px;\r\n    animation: spin 1s linear infinite;\r\n}\r\n\r\n@keyframes spin {\r\n    0% { transform: rotate(0deg); }\r\n    100% { transform: rotate(360deg); }\r\n}\r\n\r\n.loading-overlay p {\r\n    color: white;\r\n    margin-top: 20px;\r\n    font-size: 16px;\r\n}\r\n\r\n/* Scrollbar personalizado */\r\n::-webkit-scrollbar {\r\n    width: 6px;\r\n}\r\n\r\n::-webkit-scrollbar-track {\r\n    background: #f1f1f1;\r\n}\r\n\r\n::-webkit-scrollbar-thumb {\r\n    background: #888;\r\n    border-radius: 3px;\r\n}\r\n\r\n::-webkit-scrollbar-thumb:hover {\r\n    background: #555;\r\n}`, \"\"]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack://compunet-chat-client/./src/styles.css?./node_modules/css-loader/dist/cjs.js\n}");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";
eval("{\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\nmodule.exports = function (cssWithMappingToString) {\n  var list = [];\n\n  // return the list of modules as css string\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = \"\";\n      var needLayer = typeof item[5] !== \"undefined\";\n      if (item[4]) {\n        content += \"@supports (\".concat(item[4], \") {\");\n      }\n      if (item[2]) {\n        content += \"@media \".concat(item[2], \" {\");\n      }\n      if (needLayer) {\n        content += \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\");\n      }\n      content += cssWithMappingToString(item);\n      if (needLayer) {\n        content += \"}\";\n      }\n      if (item[2]) {\n        content += \"}\";\n      }\n      if (item[4]) {\n        content += \"}\";\n      }\n      return content;\n    }).join(\"\");\n  };\n\n  // import a list of modules into the list\n  list.i = function i(modules, media, dedupe, supports, layer) {\n    if (typeof modules === \"string\") {\n      modules = [[null, modules, undefined]];\n    }\n    var alreadyImportedModules = {};\n    if (dedupe) {\n      for (var k = 0; k < this.length; k++) {\n        var id = this[k][0];\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n    for (var _k = 0; _k < modules.length; _k++) {\n      var item = [].concat(modules[_k]);\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        continue;\n      }\n      if (typeof layer !== \"undefined\") {\n        if (typeof item[5] === \"undefined\") {\n          item[5] = layer;\n        } else {\n          item[1] = \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\").concat(item[1], \"}\");\n          item[5] = layer;\n        }\n      }\n      if (media) {\n        if (!item[2]) {\n          item[2] = media;\n        } else {\n          item[1] = \"@media \".concat(item[2], \" {\").concat(item[1], \"}\");\n          item[2] = media;\n        }\n      }\n      if (supports) {\n        if (!item[4]) {\n          item[4] = \"\".concat(supports);\n        } else {\n          item[1] = \"@supports (\".concat(item[4], \") {\").concat(item[1], \"}\");\n          item[4] = supports;\n        }\n      }\n      list.push(item);\n    }\n  };\n  return list;\n};\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/css-loader/dist/runtime/api.js?\n}");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/getUrl.js":
/*!********************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/getUrl.js ***!
  \********************************************************/
/***/ ((module) => {

"use strict";
eval("{\n\nmodule.exports = function (url, options) {\n  if (!options) {\n    options = {};\n  }\n  if (!url) {\n    return url;\n  }\n  url = String(url.__esModule ? url.default : url);\n\n  // If url is already wrapped in quotes, remove them\n  if (/^['\"].*['\"]$/.test(url)) {\n    url = url.slice(1, -1);\n  }\n  if (options.hash) {\n    url += options.hash;\n  }\n\n  // Should url be wrapped?\n  // See https://drafts.csswg.org/css-values-3/#urls\n  if (/[\"'() \\t\\n]|(%20)/.test(url) || options.needQuotes) {\n    return \"\\\"\".concat(url.replace(/\"/g, '\\\\\"').replace(/\\n/g, \"\\\\n\"), \"\\\"\");\n  }\n  return url;\n};\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/css-loader/dist/runtime/getUrl.js?\n}");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/noSourceMaps.js":
/*!**************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/noSourceMaps.js ***!
  \**************************************************************/
/***/ ((module) => {

"use strict";
eval("{\n\nmodule.exports = function (i) {\n  return i[1];\n};\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/css-loader/dist/runtime/noSourceMaps.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Glacier2/Glacier2.js":
/*!***************************************************!*\
  !*** ./node_modules/ice/src/Glacier2/Glacier2.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nconst _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\n\n__webpack_require__(/*! ../Glacier2/PermissionsVerifier */ \"./node_modules/ice/src/Glacier2/PermissionsVerifier.js\");\n__webpack_require__(/*! ../Glacier2/Router */ \"./node_modules/ice/src/Glacier2/Router.js\");\n__webpack_require__(/*! ../Glacier2/SSLInfo */ \"./node_modules/ice/src/Glacier2/SSLInfo.js\");\n__webpack_require__(/*! ../Glacier2/Session */ \"./node_modules/ice/src/Glacier2/Session.js\");\n\nmodule.exports.Glacier2 = _ModuleRegistry.module(\"Glacier2\");\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Glacier2/Glacier2.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Glacier2/PermissionsVerifier.js":
/*!**************************************************************!*\
  !*** ./node_modules/ice/src/Glacier2/PermissionsVerifier.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n//\n// Ice version 3.7.10\n//\n// <auto-generated>\n//\n// Generated from file `PermissionsVerifier.ice'\n//\n// Warning: do not edit this file.\n//\n// </auto-generated>\n//\n\n/* eslint-disable */\n/* jshint ignore: start */\n\n/* slice2js browser-bundle-skip */\nconst _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\nconst Glacier2 = (__webpack_require__(/*! ../Glacier2/SSLInfo */ \"./node_modules/ice/src/Glacier2/SSLInfo.js\").Glacier2);\n__webpack_require__(/*! ../Ice/Object */ \"./node_modules/ice/src/Ice/Object.js\");\n__webpack_require__(/*! ../Ice/Value */ \"./node_modules/ice/src/Ice/Value.js\");\n__webpack_require__(/*! ../Ice/ObjectPrx */ \"./node_modules/ice/src/Ice/ObjectPrx.js\");\n__webpack_require__(/*! ../Ice/Operation */ \"./node_modules/ice/src/Ice/Operation.js\");\n__webpack_require__(/*! ../Ice/Exception */ \"./node_modules/ice/src/Ice/Exception.js\");\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\nconst Ice = _ModuleRegistry.module(\"Ice\");\n\nconst Slice = Ice.Slice;\n/* slice2js browser-bundle-skip-end */\n\n/**\n * This exception is raised if a client is denied the ability to create\n * a session with the router.\n *\n **/\nGlacier2.PermissionDeniedException = class extends Ice.UserException\n{\n    constructor(reason = \"\", _cause = \"\")\n    {\n        super(_cause);\n        this.reason = reason;\n    }\n\n    static get _parent()\n    {\n        return Ice.UserException;\n    }\n\n    static get _id()\n    {\n        return \"::Glacier2::PermissionDeniedException\";\n    }\n\n    _mostDerivedType()\n    {\n        return Glacier2.PermissionDeniedException;\n    }\n\n    _writeMemberImpl(ostr)\n    {\n        ostr.writeString(this.reason);\n    }\n\n    _readMemberImpl(istr)\n    {\n        this.reason = istr.readString();\n    }\n};\n\nSlice.PreservedUserException(Glacier2.PermissionDeniedException);\n\nconst iceC_Glacier2_PermissionsVerifier_ids = [\n    \"::Glacier2::PermissionsVerifier\",\n    \"::Ice::Object\"\n];\n\n/**\n * The Glacier2 permissions verifier. This is called through the\n * process of establishing a session.\n *\n * @see Router\n *\n **/\nGlacier2.PermissionsVerifier = class extends Ice.Object\n{\n};\n\nGlacier2.PermissionsVerifierPrx = class extends Ice.ObjectPrx\n{\n};\n\nSlice.defineOperations(Glacier2.PermissionsVerifier, Glacier2.PermissionsVerifierPrx, iceC_Glacier2_PermissionsVerifier_ids, 0,\n{\n    \"checkPermissions\": [, 2, 1, 2, [1], [[7], [7]], [[7]],\n    [\n        Glacier2.PermissionDeniedException\n    ], , ]\n});\n\nconst iceC_Glacier2_SSLPermissionsVerifier_ids = [\n    \"::Glacier2::SSLPermissionsVerifier\",\n    \"::Ice::Object\"\n];\n\n/**\n * The SSL Glacier2 permissions verifier. This is called through the\n * process of establishing a session.\n *\n * @see Router\n *\n **/\nGlacier2.SSLPermissionsVerifier = class extends Ice.Object\n{\n};\n\nGlacier2.SSLPermissionsVerifierPrx = class extends Ice.ObjectPrx\n{\n};\n\nSlice.defineOperations(Glacier2.SSLPermissionsVerifier, Glacier2.SSLPermissionsVerifierPrx, iceC_Glacier2_SSLPermissionsVerifier_ids, 0,\n{\n    \"authorize\": [, 2, 1, 2, [1], [[Glacier2.SSLInfo]], [[7]],\n    [\n        Glacier2.PermissionDeniedException\n    ], , ]\n});\n/* slice2js browser-bundle-skip */\nexports.Glacier2 = Glacier2;\n/* slice2js browser-bundle-skip-end */\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Glacier2/PermissionsVerifier.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Glacier2/Router.js":
/*!*************************************************!*\
  !*** ./node_modules/ice/src/Glacier2/Router.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n//\n// Ice version 3.7.10\n//\n// <auto-generated>\n//\n// Generated from file `Router.ice'\n//\n// Warning: do not edit this file.\n//\n// </auto-generated>\n//\n\n/* eslint-disable */\n/* jshint ignore: start */\n\n/* slice2js browser-bundle-skip */\nconst _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\n__webpack_require__(/*! ../Glacier2/Session */ \"./node_modules/ice/src/Glacier2/Session.js\");\n__webpack_require__(/*! ../Glacier2/PermissionsVerifier */ \"./node_modules/ice/src/Glacier2/PermissionsVerifier.js\");\nconst Glacier2 = _ModuleRegistry.module(\"Glacier2\");\n\n__webpack_require__(/*! ../Ice/Object */ \"./node_modules/ice/src/Ice/Object.js\");\n__webpack_require__(/*! ../Ice/Value */ \"./node_modules/ice/src/Ice/Value.js\");\n__webpack_require__(/*! ../Ice/ObjectPrx */ \"./node_modules/ice/src/Ice/ObjectPrx.js\");\n__webpack_require__(/*! ../Ice/Operation */ \"./node_modules/ice/src/Ice/Operation.js\");\n__webpack_require__(/*! ../Ice/Exception */ \"./node_modules/ice/src/Ice/Exception.js\");\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\n__webpack_require__(/*! ../Ice/Router */ \"./node_modules/ice/src/Ice/Router.js\");\nconst Ice = _ModuleRegistry.module(\"Ice\");\n\nconst Slice = Ice.Slice;\n/* slice2js browser-bundle-skip-end */\n\n/**\n * This exception is raised if a client tries to destroy a session\n * with a router, but no session exists for the client.\n *\n * @see Router#destroySession\n *\n **/\nGlacier2.SessionNotExistException = class extends Ice.UserException\n{\n    constructor(_cause = \"\")\n    {\n        super(_cause);\n    }\n\n    static get _parent()\n    {\n        return Ice.UserException;\n    }\n\n    static get _id()\n    {\n        return \"::Glacier2::SessionNotExistException\";\n    }\n\n    _mostDerivedType()\n    {\n        return Glacier2.SessionNotExistException;\n    }\n};\n\nconst iceC_Glacier2_Router_ids = [\n    \"::Glacier2::Router\",\n    \"::Ice::Object\",\n    \"::Ice::Router\"\n];\n\n/**\n * The Glacier2 specialization of the <code>Ice::Router</code> interface.\n *\n **/\nGlacier2.Router = class extends Ice.Object\n{\n    static get _iceImplements()\n    {\n        return [\n            Ice.Router\n        ];\n    }\n};\n\nGlacier2.RouterPrx = class extends Ice.ObjectPrx\n{\n    static get _implements()\n    {\n        return [\n            Ice.RouterPrx];\n    }\n};\n\nSlice.defineOperations(Glacier2.Router, Glacier2.RouterPrx, iceC_Glacier2_Router_ids, 0,\n{\n    \"getCategoryForClient\": [, 2, 1, , [7], , , , , ],\n    \"createSession\": [, , , 2, [\"Glacier2.SessionPrx\"], [[7], [7]], ,\n    [\n        Glacier2.CannotCreateSessionException,\n        Glacier2.PermissionDeniedException\n    ], , ],\n    \"createSessionFromSecureConnection\": [, , , 2, [\"Glacier2.SessionPrx\"], , ,\n    [\n        Glacier2.CannotCreateSessionException,\n        Glacier2.PermissionDeniedException\n    ], , ],\n    \"refreshSession\": [, , , , , , ,\n    [\n        Glacier2.SessionNotExistException\n    ], , ],\n    \"destroySession\": [, , , , , , ,\n    [\n        Glacier2.SessionNotExistException\n    ], , ],\n    \"getSessionTimeout\": [, 2, 1, , [4], , , , , ],\n    \"getACMTimeout\": [, 2, 1, , [3], , , , , ]\n});\n/* slice2js browser-bundle-skip */\nexports.Glacier2 = Glacier2;\n/* slice2js browser-bundle-skip-end */\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Glacier2/Router.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Glacier2/SSLInfo.js":
/*!**************************************************!*\
  !*** ./node_modules/ice/src/Glacier2/SSLInfo.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n//\n// Ice version 3.7.10\n//\n// <auto-generated>\n//\n// Generated from file `SSLInfo.ice'\n//\n// Warning: do not edit this file.\n//\n// </auto-generated>\n//\n\n/* eslint-disable */\n/* jshint ignore: start */\n\n/* slice2js browser-bundle-skip */\nconst _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\n__webpack_require__(/*! ../Ice/Struct */ \"./node_modules/ice/src/Ice/Struct.js\");\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\n__webpack_require__(/*! ../Ice/BuiltinSequences */ \"./node_modules/ice/src/Ice/BuiltinSequences.js\");\nconst Ice = _ModuleRegistry.module(\"Ice\");\n\nconst Slice = Ice.Slice;\n/* slice2js browser-bundle-skip-end */\n/* slice2js browser-bundle-skip */\n\nlet Glacier2 = _ModuleRegistry.module(\"Glacier2\");\n/* slice2js browser-bundle-skip-end */\n\n/**\n * Information taken from an SSL connection used for permissions\n * verification.\n *\n * @see PermissionsVerifier\n *\n **/\nGlacier2.SSLInfo = class\n{\n    constructor(remoteHost = \"\", remotePort = 0, localHost = \"\", localPort = 0, cipher = \"\", certs = null)\n    {\n        this.remoteHost = remoteHost;\n        this.remotePort = remotePort;\n        this.localHost = localHost;\n        this.localPort = localPort;\n        this.cipher = cipher;\n        this.certs = certs;\n    }\n\n    _write(ostr)\n    {\n        ostr.writeString(this.remoteHost);\n        ostr.writeInt(this.remotePort);\n        ostr.writeString(this.localHost);\n        ostr.writeInt(this.localPort);\n        ostr.writeString(this.cipher);\n        Ice.StringSeqHelper.write(ostr, this.certs);\n    }\n\n    _read(istr)\n    {\n        this.remoteHost = istr.readString();\n        this.remotePort = istr.readInt();\n        this.localHost = istr.readString();\n        this.localPort = istr.readInt();\n        this.cipher = istr.readString();\n        this.certs = Ice.StringSeqHelper.read(istr);\n    }\n\n    static get minWireSize()\n    {\n        return  12;\n    }\n};\n\nSlice.defineStruct(Glacier2.SSLInfo, true, true);\n/* slice2js browser-bundle-skip */\nexports.Glacier2 = Glacier2;\n/* slice2js browser-bundle-skip-end */\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Glacier2/SSLInfo.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Glacier2/Session.js":
/*!**************************************************!*\
  !*** ./node_modules/ice/src/Glacier2/Session.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n//\n// Ice version 3.7.10\n//\n// <auto-generated>\n//\n// Generated from file `Session.ice'\n//\n// Warning: do not edit this file.\n//\n// </auto-generated>\n//\n\n/* eslint-disable */\n/* jshint ignore: start */\n\n/* slice2js browser-bundle-skip */\nconst _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\nconst Glacier2 = (__webpack_require__(/*! ../Glacier2/SSLInfo */ \"./node_modules/ice/src/Glacier2/SSLInfo.js\").Glacier2);\n__webpack_require__(/*! ../Ice/Object */ \"./node_modules/ice/src/Ice/Object.js\");\n__webpack_require__(/*! ../Ice/Value */ \"./node_modules/ice/src/Ice/Value.js\");\n__webpack_require__(/*! ../Ice/ObjectPrx */ \"./node_modules/ice/src/Ice/ObjectPrx.js\");\n__webpack_require__(/*! ../Ice/Operation */ \"./node_modules/ice/src/Ice/Operation.js\");\n__webpack_require__(/*! ../Ice/Exception */ \"./node_modules/ice/src/Ice/Exception.js\");\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\n__webpack_require__(/*! ../Ice/BuiltinSequences */ \"./node_modules/ice/src/Ice/BuiltinSequences.js\");\n__webpack_require__(/*! ../Ice/Identity */ \"./node_modules/ice/src/Ice/Identity.js\");\nconst Ice = _ModuleRegistry.module(\"Ice\");\n\nconst Slice = Ice.Slice;\n/* slice2js browser-bundle-skip-end */\n\n/**\n * This exception is raised if an attempt to create a new session failed.\n *\n **/\nGlacier2.CannotCreateSessionException = class extends Ice.UserException\n{\n    constructor(reason = \"\", _cause = \"\")\n    {\n        super(_cause);\n        this.reason = reason;\n    }\n\n    static get _parent()\n    {\n        return Ice.UserException;\n    }\n\n    static get _id()\n    {\n        return \"::Glacier2::CannotCreateSessionException\";\n    }\n\n    _mostDerivedType()\n    {\n        return Glacier2.CannotCreateSessionException;\n    }\n\n    _writeMemberImpl(ostr)\n    {\n        ostr.writeString(this.reason);\n    }\n\n    _readMemberImpl(istr)\n    {\n        this.reason = istr.readString();\n    }\n};\n\nSlice.PreservedUserException(Glacier2.CannotCreateSessionException);\n\nconst iceC_Glacier2_Session_ids = [\n    \"::Glacier2::Session\",\n    \"::Ice::Object\"\n];\n\n/**\n * A client-visible session object, which is tied to the lifecycle of a {@link Router}.\n *\n * @see Router\n * @see SessionManager\n *\n **/\nGlacier2.Session = class extends Ice.Object\n{\n};\n\nGlacier2.SessionPrx = class extends Ice.ObjectPrx\n{\n};\n\nSlice.defineOperations(Glacier2.Session, Glacier2.SessionPrx, iceC_Glacier2_Session_ids, 0,\n{\n    \"destroy\": [, , , , , , , , , ]\n});\n\nconst iceC_Glacier2_StringSet_ids = [\n    \"::Glacier2::StringSet\",\n    \"::Ice::Object\"\n];\n\n/**\n * An object for managing the set of identity constraints for specific\n * parts of object identity on a\n * {@link Session}.\n *\n * @see Session\n * @see SessionControl\n *\n **/\nGlacier2.StringSet = class extends Ice.Object\n{\n};\n\nGlacier2.StringSetPrx = class extends Ice.ObjectPrx\n{\n};\n\nSlice.defineOperations(Glacier2.StringSet, Glacier2.StringSetPrx, iceC_Glacier2_StringSet_ids, 0,\n{\n    \"add\": [, 2, 2, , , [[\"Ice.StringSeqHelper\"]], , , , ],\n    \"remove\": [, 2, 2, , , [[\"Ice.StringSeqHelper\"]], , , , ],\n    \"get\": [, 2, 2, , [\"Ice.StringSeqHelper\"], , , , , ]\n});\n\nconst iceC_Glacier2_IdentitySet_ids = [\n    \"::Glacier2::IdentitySet\",\n    \"::Ice::Object\"\n];\n\n/**\n * An object for managing the set of object identity constraints on a\n * {@link Session}.\n *\n * @see Session\n * @see SessionControl\n *\n **/\nGlacier2.IdentitySet = class extends Ice.Object\n{\n};\n\nGlacier2.IdentitySetPrx = class extends Ice.ObjectPrx\n{\n};\n\nSlice.defineOperations(Glacier2.IdentitySet, Glacier2.IdentitySetPrx, iceC_Glacier2_IdentitySet_ids, 0,\n{\n    \"add\": [, 2, 2, , , [[\"Ice.IdentitySeqHelper\"]], , , , ],\n    \"remove\": [, 2, 2, , , [[\"Ice.IdentitySeqHelper\"]], , , , ],\n    \"get\": [, 2, 2, , [\"Ice.IdentitySeqHelper\"], , , , , ]\n});\n\nconst iceC_Glacier2_SessionControl_ids = [\n    \"::Glacier2::SessionControl\",\n    \"::Ice::Object\"\n];\n\n/**\n * An administrative session control object, which is tied to the\n * lifecycle of a {@link Session}.\n *\n * @see Session\n *\n **/\nGlacier2.SessionControl = class extends Ice.Object\n{\n};\n\nGlacier2.SessionControlPrx = class extends Ice.ObjectPrx\n{\n};\n\nSlice.defineOperations(Glacier2.SessionControl, Glacier2.SessionControlPrx, iceC_Glacier2_SessionControl_ids, 0,\n{\n    \"categories\": [, , , , [\"Glacier2.StringSetPrx\"], , , , , ],\n    \"adapterIds\": [, , , , [\"Glacier2.StringSetPrx\"], , , , , ],\n    \"identities\": [, , , , [\"Glacier2.IdentitySetPrx\"], , , , , ],\n    \"getSessionTimeout\": [, 2, 2, , [3], , , , , ],\n    \"destroy\": [, , , , , , , , , ]\n});\n\nconst iceC_Glacier2_SessionManager_ids = [\n    \"::Glacier2::SessionManager\",\n    \"::Ice::Object\"\n];\n\n/**\n * The session manager for username/password authenticated users that\n * is responsible for managing {@link Session} objects. New session objects\n * are created by the {@link Router} object calling on an application-provided\n * session manager. If no session manager is provided by the application,\n * no client-visible sessions are passed to the client.\n *\n * @see Router\n * @see Session\n *\n **/\nGlacier2.SessionManager = class extends Ice.Object\n{\n};\n\nGlacier2.SessionManagerPrx = class extends Ice.ObjectPrx\n{\n};\n\nSlice.defineOperations(Glacier2.SessionManager, Glacier2.SessionManagerPrx, iceC_Glacier2_SessionManager_ids, 0,\n{\n    \"create\": [, , , 2, [\"Glacier2.SessionPrx\"], [[7], [\"Glacier2.SessionControlPrx\"]], ,\n    [\n        Glacier2.CannotCreateSessionException\n    ], , ]\n});\n\nconst iceC_Glacier2_SSLSessionManager_ids = [\n    \"::Glacier2::SSLSessionManager\",\n    \"::Ice::Object\"\n];\n\n/**\n * The session manager for SSL authenticated users that is\n * responsible for managing {@link Session} objects. New session objects are\n * created by the {@link Router} object calling on an application-provided\n * session manager. If no session manager is provided by the\n * application, no client-visible sessions are passed to the client.\n *\n * @see Router\n * @see Session\n *\n **/\nGlacier2.SSLSessionManager = class extends Ice.Object\n{\n};\n\nGlacier2.SSLSessionManagerPrx = class extends Ice.ObjectPrx\n{\n};\n\nSlice.defineOperations(Glacier2.SSLSessionManager, Glacier2.SSLSessionManagerPrx, iceC_Glacier2_SSLSessionManager_ids, 0,\n{\n    \"create\": [, , , 2, [\"Glacier2.SessionPrx\"], [[Glacier2.SSLInfo], [\"Glacier2.SessionControlPrx\"]], ,\n    [\n        Glacier2.CannotCreateSessionException\n    ], , ]\n});\n/* slice2js browser-bundle-skip */\nexports.Glacier2 = Glacier2;\n/* slice2js browser-bundle-skip-end */\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Glacier2/Session.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/ACM.js":
/*!*****************************************!*\
  !*** ./node_modules/ice/src/Ice/ACM.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nconst Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n\n__webpack_require__(/*! ../Ice/Connection */ \"./node_modules/ice/src/Ice/Connection.js\");\n__webpack_require__(/*! ../Ice/Debug */ \"./node_modules/ice/src/Ice/Debug.js\");\n\nconst Debug = Ice.Debug;\n\nclass ACMConfig\n{\n    constructor(p, l, prefix, dflt)\n    {\n        if(p === undefined)\n        {\n            this.timeout = 60 * 1000;\n            this.heartbeat = Ice.ACMHeartbeat.HeartbeatOnDispatch;\n            this.close = Ice.ACMClose.CloseOnInvocationAndIdle;\n            return;\n        }\n\n        let timeoutProperty;\n        if((prefix == \"Ice.ACM.Client\" || prefix == \"Ice.ACM.Server\") &&\n            p.getProperty(prefix + \".Timeout\").length === 0)\n        {\n            timeoutProperty = prefix; // Deprecated property.\n        }\n        else\n        {\n            timeoutProperty = prefix + \".Timeout\";\n        }\n\n        this.timeout = p.getPropertyAsIntWithDefault(timeoutProperty, dflt.timeout / 1000) * 1000; // To ms\n        if(this.timeout < 0)\n        {\n            l.warning(\"invalid value for property `\" + timeoutProperty + \"', default value will be used instead\");\n            this.timeout = dflt.timeout;\n        }\n\n        const hb = p.getPropertyAsIntWithDefault(prefix + \".Heartbeat\", dflt.heartbeat.value);\n        if(hb >= 0 && hb <= Ice.ACMHeartbeat.maxValue)\n        {\n            this.heartbeat = Ice.ACMHeartbeat.valueOf(hb);\n        }\n        else\n        {\n            l.warning(\"invalid value for property `\" + prefix + \".Heartbeat\" +\n                        \"', default value will be used instead\");\n            this.heartbeat = dflt.heartbeat;\n        }\n\n        const cl = p.getPropertyAsIntWithDefault(prefix + \".Close\", dflt.close.value);\n        if(cl >= 0 && cl <= Ice.ACMClose.maxValue)\n        {\n            this.close = Ice.ACMClose.valueOf(cl);\n        }\n        else\n        {\n            l.warning(\"invalid value for property `\" + prefix + \".Close\" +\n                        \"', default value will be used instead\");\n            this.close = dflt.close;\n        }\n    }\n}\n\nclass FactoryACMMonitor\n{\n    constructor(instance, config)\n    {\n        this._instance = instance;\n        this._config = config;\n        this._reapedConnections = [];\n        this._connections = [];\n    }\n\n    destroy()\n    {\n        if(this._instance === null)\n        {\n            return;\n        }\n        this._instance = null;\n    }\n\n    add(connection)\n    {\n        if(this._config.timeout === 0)\n        {\n            return;\n        }\n\n        this._connections.push(connection);\n        if(this._connections.length == 1)\n        {\n            this._timerToken = this._instance.timer().scheduleRepeated(\n                () => this.runTimerTask(), this._config.timeout / 2);\n        }\n    }\n\n    remove(connection)\n    {\n        if(this._config.timeout === 0)\n        {\n            return;\n        }\n\n        const i = this._connections.indexOf(connection);\n        Debug.assert(i >= 0);\n        this._connections.splice(i, 1);\n        if(this._connections.length === 0)\n        {\n            this._instance.timer().cancel(this._timerToken);\n        }\n    }\n\n    reap(connection)\n    {\n        this._reapedConnections.push(connection);\n    }\n\n    acm(timeout, close, heartbeat)\n    {\n        Debug.assert(this._instance !== null);\n\n        const config = new ACMConfig();\n        config.timeout = this._config.timeout;\n        config.close = this._config.close;\n        config.heartbeat = this._config.heartbeat;\n        if(timeout !== undefined)\n        {\n            config.timeout = timeout * 1000; // To milliseconds\n        }\n        if(close !== undefined)\n        {\n            config.close = close;\n        }\n        if(heartbeat !== undefined)\n        {\n            config.heartbeat = heartbeat;\n        }\n        return new ConnectionACMMonitor(this, this._instance.timer(), config);\n    }\n\n    getACM()\n    {\n        return new Ice.ACM(this._config.timeout / 1000, this._config.close, this._config.heartbeat);\n    }\n\n    swapReapedConnections()\n    {\n        if(this._reapedConnections.length === 0)\n        {\n            return null;\n        }\n        const connections = this._reapedConnections;\n        this._reapedConnections = [];\n        return connections;\n    }\n\n    runTimerTask()\n    {\n        if(this._instance === null)\n        {\n            this._connections = null;\n            return;\n        }\n\n        //\n        // Monitor connections outside the thread synchronization, so\n        // that connections can be added or removed during monitoring.\n        //\n        const now = Date.now();\n        this._connections.forEach(connection =>\n            {\n                try\n                {\n                    connection.monitor(now, this._config);\n                }\n                catch(ex)\n                {\n                    this.handleException(ex);\n                }\n            });\n    }\n\n    handleException(ex)\n    {\n        if(this._instance === null)\n        {\n            return;\n        }\n        this._instance.initializationData().logger.error(\"exception in connection monitor:\\n\" + ex);\n    }\n}\n\nclass ConnectionACMMonitor\n{\n    constructor(parent, timer, config)\n    {\n        this._parent = parent;\n        this._timer = timer;\n        this._config = config;\n        this._connection = null;\n    }\n\n    add(connection)\n    {\n        Debug.assert(this._connection === null);\n        this._connection = connection;\n        if(this._config.timeout > 0)\n        {\n            this._timerToken = this._timer.scheduleRepeated(() => this.runTimerTask(), this._config.timeout / 2);\n        }\n    }\n\n    remove(connection)\n    {\n        Debug.assert(this._connection === connection);\n        this._connection = null;\n        if(this._config.timeout > 0)\n        {\n            this._timer.cancel(this._timerToken);\n        }\n    }\n\n    reap(connection)\n    {\n        this._parent.reap(connection);\n    }\n\n    acm(timeout, close, heartbeat)\n    {\n        return this._parent.acm(timeout, close, heartbeat);\n    }\n\n    getACM()\n    {\n        return new Ice.ACM(this._config.timeout / 1000, this._config.close, this._config.heartbeat);\n    }\n\n    runTimerTask()\n    {\n        try\n        {\n            this._connection.monitor(Date.now(), this._config);\n        }\n        catch(ex)\n        {\n            this._parent.handleException(ex);\n        }\n    }\n}\n\nIce.FactoryACMMonitor = FactoryACMMonitor;\nIce.ACMConfig = ACMConfig;\nmodule.exports.Ice = Ice;\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/ACM.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/Address.js":
/*!*********************************************!*\
  !*** ./node_modules/ice/src/Ice/Address.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nconst Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n\nclass Address\n{\n    constructor(host, port)\n    {\n        this.host = host;\n        this.port = port;\n    }\n}\n\nIce.Address = Address;\nmodule.exports.Ice = Ice;\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/Address.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/ArrayUtil.js":
/*!***********************************************!*\
  !*** ./node_modules/ice/src/Ice/ArrayUtil.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nconst Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\nconst _ModuleRegistry = Ice._ModuleRegistry;\n\nconst eq = function(e1, e2)\n{\n    if(e1 === e2)\n    {\n        return true; // If identity compare equals members are equal.\n    }\n    else if(e1 === null || e1 === undefined || e2 === null || e2 === undefined)\n    {\n        return false;\n    }\n    else if(e1.prototype !== e2.prototype)\n    {\n        return false;\n    }\n    else if(typeof e1.equals == \"function\")\n    {\n        return e1.equals(e2);\n    }\n    else if(e1 instanceof Array || e1 instanceof Uint8Array)\n    {\n        return ArrayUtil.equals(e1, e2, eq);\n    }\n    return false;\n};\n\nclass ArrayUtil\n{\n    static clone(arr)\n    {\n        if(arr === undefined)\n        {\n            return arr;\n        }\n        else if(arr === null)\n        {\n            return [];\n        }\n        else\n        {\n            return arr.slice();\n        }\n    }\n\n    static equals(v1, v2, valuesEqual)\n    {\n        if(v1.length != v2.length)\n        {\n            return false;\n        }\n\n        const equalFn = valuesEqual || eq;\n        for(let i = 0; i < v1.length; ++i)\n        {\n            if(!equalFn.call(equalFn, v1[i], v2[i]))\n            {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    static shuffle(arr)\n    {\n        for(let i = arr.length; i > 1; --i)\n        {\n            const e = arr[i - 1];\n            const rand = Math.floor(Math.random() * i);\n            arr[i - 1] = arr[rand];\n            arr[rand] = e;\n        }\n    }\n}\n\nArrayUtil.eq = eq;\n\nIce.Slice.defineSequence = function(module, name, valueHelper, fixed, elementType)\n{\n    let helper = null;\n    Object.defineProperty(module, name,\n        {\n            get: () =>\n                {\n                    if(helper === null)\n                    {\n                        helper = Ice.StreamHelpers.generateSeqHelper(_ModuleRegistry.type(valueHelper),\n                                                                     fixed,\n                                                                     _ModuleRegistry.type(elementType));\n                    }\n                    return helper;\n                }\n        });\n};\n\nIce.ArrayUtil = ArrayUtil;\nmodule.exports.Ice = Ice;\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/ArrayUtil.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/AsyncResult.js":
/*!*************************************************!*\
  !*** ./node_modules/ice/src/Ice/AsyncResult.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nconst Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n\n__webpack_require__(/*! ../Ice/AsyncResultBase */ \"./node_modules/ice/src/Ice/AsyncResultBase.js\");\n__webpack_require__(/*! ../Ice/Debug */ \"./node_modules/ice/src/Ice/Debug.js\");\n__webpack_require__(/*! ../Ice/Exception */ \"./node_modules/ice/src/Ice/Exception.js\");\n__webpack_require__(/*! ../Ice/Protocol */ \"./node_modules/ice/src/Ice/Protocol.js\");\n__webpack_require__(/*! ../Ice/Stream */ \"./node_modules/ice/src/Ice/Stream.js\");\n\nconst AsyncResultBase = Ice.AsyncResultBase;\nconst Debug = Ice.Debug;\nconst Protocol = Ice.Protocol;\nconst UserException = Ice.UserException;\nconst OutputStream = Ice.OutputStream;\n\nclass AsyncResult extends AsyncResultBase\n{\n    constructor(com, op, connection, proxy, adapter, completedFn)\n    {\n        super(com, op, connection, proxy, adapter);\n        this._completed = completedFn;\n        this._is = null;\n        this._os = com !== null ? new OutputStream(this._instance, Protocol.currentProtocolEncoding) : null;\n        this._state = 0;\n        this._exception = null;\n        this._sentSynchronously = false;\n    }\n\n    cancel()\n    {\n        this.cancelWithException(new Ice.InvocationCanceledException());\n    }\n\n    isCompleted()\n    {\n        return (this._state & AsyncResult.Done) > 0;\n    }\n\n    isSent()\n    {\n        return (this._state & AsyncResult.Sent) > 0;\n    }\n\n    throwLocalException()\n    {\n        if(this._exception !== null)\n        {\n            throw this._exception;\n        }\n    }\n\n    sentSynchronously()\n    {\n        return this._sentSynchronously;\n    }\n\n    markSent(done)\n    {\n        Debug.assert((this._state & AsyncResult.Done) === 0);\n        this._state |= AsyncResult.Sent;\n        if(done)\n        {\n            this._state |= AsyncResult.Done | AsyncResult.OK;\n            this._cancellationHandler = null;\n            this.resolve();\n        }\n    }\n\n    markFinished(ok, completed)\n    {\n        Debug.assert((this._state & AsyncResult.Done) === 0);\n        this._state |= AsyncResult.Done;\n        if(ok)\n        {\n            this._state |= AsyncResult.OK;\n        }\n        this._cancellationHandler = null;\n        if(completed)\n        {\n            completed(this);\n        }\n        else\n        {\n            this.resolve();\n        }\n    }\n\n    markFinishedEx(ex)\n    {\n        Debug.assert((this._state & AsyncResult.Done) === 0);\n        this._exception = ex;\n        this._state |= AsyncResult.Done;\n        this._cancellationHandler = null;\n        this.reject(ex);\n    }\n\n    cancelWithException(ex)\n    {\n        if(this._cancellationHandler)\n        {\n            this._cancellationHandler.asyncRequestCanceled(this, ex);\n        }\n        else\n        {\n            this._cancellationException = ex;\n        }\n    }\n\n    cancelable(handler)\n    {\n        if(this._cancellationException)\n        {\n            try\n            {\n                throw this._cancellationException;\n            }\n            finally\n            {\n                this._cancellationException = null;\n            }\n        }\n        this._cancellationHandler = handler;\n    }\n\n    getOs()\n    {\n        return this._os;\n    }\n\n    startReadParams()\n    {\n        this._is.startEncapsulation();\n        return this._is;\n    }\n\n    endReadParams()\n    {\n        this._is.endEncapsulation();\n    }\n\n    readEmptyParams()\n    {\n        this._is.skipEmptyEncapsulation();\n    }\n\n    throwUserException()\n    {\n        Debug.assert((this._state & AsyncResult.Done) !== 0);\n        if((this._state & AsyncResult.OK) === 0)\n        {\n            try\n            {\n                this._is.startEncapsulation();\n                this._is.throwException();\n            }\n            catch(ex)\n            {\n                if(ex instanceof UserException)\n                {\n                    this._is.endEncapsulation();\n                }\n                throw ex;\n            }\n        }\n    }\n\n}\n\nAsyncResult.OK = 0x1;\nAsyncResult.Done = 0x2;\nAsyncResult.Sent = 0x4;\n\nIce.AsyncResult = AsyncResult;\nmodule.exports.Ice = Ice;\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/AsyncResult.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/AsyncResultBase.js":
/*!*****************************************************!*\
  !*** ./node_modules/ice/src/Ice/AsyncResultBase.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nconst Ice = (__webpack_require__(/*! ../Ice/Promise */ \"./node_modules/ice/src/Ice/Promise.js\").Ice);\n\nclass AsyncResultBase extends Ice.Promise\n{\n    constructor(communicator, op, connection, proxy, adapter)\n    {\n        super();\n        this._communicator = communicator;\n        this._instance = communicator ? communicator.instance : null;\n        this._operation = op;\n        this._connection = connection;\n        this._proxy = proxy;\n        this._adapter = adapter;\n    }\n\n    get communicator()\n    {\n        return this._communicator;\n    }\n\n    get connection()\n    {\n        return this._connection;\n    }\n\n    get proxy()\n    {\n        return this._proxy;\n    }\n\n    get adapter()\n    {\n        return this._adapter;\n    }\n\n    get operation()\n    {\n        return this._operation;\n    }\n}\n\nIce.AsyncResultBase = AsyncResultBase;\n\nmodule.exports.Ice = Ice;\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/AsyncResultBase.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/AsyncStatus.js":
/*!*************************************************!*\
  !*** ./node_modules/ice/src/Ice/AsyncStatus.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nconst Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\nIce.AsyncStatus = {Queued: 0, Sent: 1};\nmodule.exports.Ice = Ice;\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/AsyncStatus.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/Base64.js":
/*!********************************************!*\
  !*** ./node_modules/ice/src/Ice/Base64.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nconst Ice = (__webpack_require__(/*! ../Ice/Buffer */ \"./node_modules/ice/src/Ice/Buffer.js\").Ice);\n\nconst _codeA = \"A\".charCodeAt(0);\nconst _codea = \"a\".charCodeAt(0);\nconst _code0 = \"0\".charCodeAt(0);\n\nfunction encodeChar(uc)\n{\n    if(uc < 26)\n    {\n        return String.fromCharCode(_codeA + uc);\n    }\n\n    if(uc < 52)\n    {\n        return String.fromCharCode(_codea + (uc - 26));\n    }\n\n    if(uc < 62)\n    {\n        return String.fromCharCode(_code0 + (uc - 52));\n    }\n\n    if(uc == 62)\n    {\n        return \"+\";\n    }\n\n    return \"/\";\n}\n\nfunction decodeChar(c)\n{\n    if(c >= 'A' && c <= 'Z')\n    {\n        return c.charCodeAt(0) - _codeA;\n    }\n\n    if(c >= 'a' && c <= 'z')\n    {\n        return c.charCodeAt(0) - _codea + 26;\n    }\n\n    if(c >= '0' && c <= '9')\n    {\n        return c.charCodeAt(0) - _code0 + 52;\n    }\n\n    if(c == '+')\n    {\n        return 62;\n    }\n\n    return 63;\n}\n\nclass Base64\n{\n    // Expects native Buffer\n    static encode(buf)\n    {\n        if(buf === null || buf.length === 0)\n        {\n            return \"\";\n        }\n\n        const v = [];\n\n        let by1;\n        let by2;\n        let by3;\n        let by4;\n        let by5;\n        let by6;\n        let by7;\n\n        for(let i = 0; i < buf.length; i += 3)\n        {\n            by1 = buf[i] & 0xff;\n            by2 = 0;\n            by3 = 0;\n\n            if((i + 1) < buf.length)\n            {\n                by2 = buf[i + 1] & 0xff;\n            }\n\n            if((i + 2) < buf.length)\n            {\n                by3 = buf[i + 2] & 0xff;\n            }\n\n            by4 = (by1 >> 2) & 0xff;\n            by5 = (((by1 & 0x3) << 4) | (by2 >> 4)) & 0xff;\n            by6 = (((by2 & 0xf) << 2) | (by3 >> 6)) & 0xff;\n            by7 = by3 & 0x3f;\n\n            v.push(encodeChar(by4));\n            v.push(encodeChar(by5));\n\n            if((i + 1) < buf.length)\n            {\n                v.push(encodeChar(by6));\n            }\n            else\n            {\n                v.push(\"=\");\n            }\n\n            if((i + 2) < buf.length)\n            {\n                v.push(encodeChar(by7));\n            }\n            else\n            {\n                v.push(\"=\");\n            }\n        }\n\n        const retval = v.join(\"\");\n        const outString = [];\n        let iter = 0;\n\n        while((retval.length - iter) > 76)\n        {\n            outString.push(retval.substring(iter, iter + 76));\n            outString.push(\"\\r\\n\");\n            iter += 76;\n        }\n\n        outString.push(retval.substring(iter));\n\n        return outString.join(\"\");\n    }\n\n    static decode(str) // Returns native Buffer\n    {\n        const newStr = [];\n\n        for(let j = 0; j < str.length; j++)\n        {\n            const c = str.charAt(j);\n            if(Base64.isBase64(c))\n            {\n                newStr.push(c);\n            }\n        }\n\n        if(newStr.length === 0)\n        {\n            return null;\n        }\n\n        // Note: This is how we were previously computing the size of the return\n        //       sequence.  The method below is more efficient (and correct).\n        // size_t lines = str.size() / 78;\n        // size_t totalBytes = (lines * 76) + (((str.size() - (lines * 78)) * 3) / 4);\n\n        // Figure out how long the final sequence is going to be.\n        const totalBytes = (newStr.length * 3 / 4) + 1;\n\n        const retval = new Ice.Buffer();\n        retval.resize(totalBytes);\n\n        let by1;\n        let by2;\n        let by3;\n        let by4;\n\n        let c1;\n        let c2;\n        let c3;\n        let c4;\n\n        for(let i = 0; i < newStr.length; i += 4)\n        {\n            c1 = \"A\";\n            c2 = \"A\";\n            c3 = \"A\";\n            c4 = \"A\";\n\n            c1 = newStr[i];\n\n            if((i + 1) < newStr.length)\n            {\n                c2 = newStr[i + 1];\n            }\n\n            if((i + 2) < newStr.length)\n            {\n                c3 = newStr[i + 2];\n            }\n\n            if((i + 3) < newStr.length)\n            {\n                c4 = newStr[i + 3];\n            }\n\n            by1 = decodeChar(c1) & 0xff;\n            by2 = decodeChar(c2) & 0xff;\n            by3 = decodeChar(c3) & 0xff;\n            by4 = decodeChar(c4) & 0xff;\n\n            retval.put((by1 << 2) | (by2 >> 4));\n\n            if(c3 != \"=\")\n            {\n                retval.put(((by2 & 0xf) << 4) | (by3 >> 2));\n            }\n\n            if(c4 != \"=\")\n            {\n                retval.put(((by3 & 0x3) << 6) | by4);\n            }\n        }\n\n        return retval.remaining > 0 ? retval.getArrayAt(0, retval.position) : retval.getArrayAt(0);\n    }\n\n    static isBase64(c)\n    {\n        if(c >= 'A' && c <= 'Z')\n        {\n            return true;\n        }\n\n        if(c >= 'a' && c <= 'z')\n        {\n            return true;\n        }\n\n        if(c >= '0' && c <= '9')\n        {\n            return true;\n        }\n\n        if(c == '+')\n        {\n            return true;\n        }\n\n        if(c == '/')\n        {\n            return true;\n        }\n\n        if(c == '=')\n        {\n            return true;\n        }\n\n        return false;\n    }\n}\n\nIce.Base64 = Base64;\nmodule.exports.Ice = Ice;\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/Base64.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/BatchRequestQueue.js":
/*!*******************************************************!*\
  !*** ./node_modules/ice/src/Ice/BatchRequestQueue.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nconst Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n\n__webpack_require__(/*! ../Ice/Debug */ \"./node_modules/ice/src/Ice/Debug.js\");\n__webpack_require__(/*! ../Ice/Protocol */ \"./node_modules/ice/src/Ice/Protocol.js\");\n__webpack_require__(/*! ../Ice/Stream */ \"./node_modules/ice/src/Ice/Stream.js\");\n\nconst OutputStream = Ice.OutputStream;\nconst Debug = Ice.Debug;\nconst Protocol = Ice.Protocol;\n\nconst udpOverhead = 20 + 8;\n\nclass BatchRequestQueue\n{\n    constructor(instance, datagram)\n    {\n        this._batchStreamInUse = false;\n        this._batchRequestNum = 0;\n        this._batchStream = new OutputStream(instance, Protocol.currentProtocolEncoding);\n        this._batchStream.writeBlob(Protocol.requestBatchHdr);\n        this._batchMarker = this._batchStream.size;\n        this._exception = null;\n\n        this._maxSize = instance.batchAutoFlushSize();\n        if(this._maxSize > 0 && datagram)\n        {\n            const udpSndSize = instance.initializationData().properties.getPropertyAsIntWithDefault(\n                \"Ice.UDP.SndSize\", 65535 - udpOverhead);\n            if(udpSndSize < this._maxSize)\n            {\n                this._maxSize = udpSndSize;\n            }\n        }\n    }\n\n    prepareBatchRequest(os)\n    {\n        if(this._exception)\n        {\n            throw this._exception;\n        }\n        this._batchStream.swap(os);\n    }\n\n    finishBatchRequest(os, proxy, operation)\n    {\n        //\n        // No need for synchronization, no other threads are supposed\n        // to modify the queue since we set this._batchStreamInUse to true.\n        //\n        this._batchStream.swap(os);\n\n        try\n        {\n            if(this._maxSize > 0 && this._batchStream.size >= this._maxSize)\n            {\n                proxy.ice_flushBatchRequests(); // Auto flush\n            }\n\n            Debug.assert(this._batchMarker < this._batchStream.size);\n            this._batchMarker = this._batchStream.size;\n            ++this._batchRequestNum;\n        }\n        finally\n        {\n            this._batchStream.resize(this._batchMarker);\n        }\n    }\n\n    abortBatchRequest(os)\n    {\n        this._batchStream.swap(os);\n        this._batchStream.resize(this._batchMarker);\n    }\n\n    swap(os)\n    {\n        if(this._batchRequestNum === 0)\n        {\n            return 0;\n        }\n\n        let lastRequest = null;\n        if(this._batchMarker < this._batchStream.size)\n        {\n            const length = this._batchStream.size - this._batchMarker;\n            this._batchStream.pos = this._batchMarker;\n            lastRequest = this._batchStream.buffer.getArray(length);\n            this._batchStream.resize(this._batchMarker);\n        }\n\n        const requestNum = this._batchRequestNum;\n        this._batchStream.swap(os);\n\n        //\n        // Reset the batch.\n        //\n        this._batchRequestNum = 0;\n        this._batchStream.writeBlob(Protocol.requestBatchHdr);\n        this._batchMarker = this._batchStream.size;\n        if(lastRequest !== null)\n        {\n            this._batchStream.writeBlob(lastRequest);\n        }\n        return requestNum;\n    }\n\n    destroy(ex)\n    {\n        this._exception = ex;\n    }\n\n    isEmpty()\n    {\n        return this._batchStream.size === Protocol.requestBatchHdr.length;\n    }\n}\n\nIce.BatchRequestQueue = BatchRequestQueue;\nmodule.exports.Ice = Ice;\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/BatchRequestQueue.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/Buffer.js":
/*!********************************************!*\
  !*** ./node_modules/ice/src/Ice/Buffer.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nconst Ice = (__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\").Ice);\nconst Long = Ice.Long;\n\nconst bufferOverflowExceptionMsg = \"BufferOverflowException\";\nconst bufferUnderflowExceptionMsg = \"BufferUnderflowException\";\nconst indexOutOfBoundsExceptionMsg = \"IndexOutOfBoundsException\";\n\nclass Buffer\n{\n    constructor(buffer)\n    {\n        if(buffer !== undefined)\n        {\n            this.b = buffer;\n            this.v = new DataView(this.b);\n            this._limit = this.b.byteLength;\n        }\n        else\n        {\n            this.b = null; // ArrayBuffer\n            this.v = null; // DataView\n            this._limit = 0;\n        }\n        this._position = 0;\n        this._shrinkCounter = 0;\n    }\n\n    empty()\n    {\n        return this._limit === 0;\n    }\n\n    resize(n)\n    {\n        if(n === 0)\n        {\n            this.clear();\n        }\n        else if(n > this.capacity)\n        {\n            this.reserve(n);\n        }\n        this._limit = n;\n    }\n\n    clear()\n    {\n        this.b = null;\n        this.v = null;\n        this._position = 0;\n        this._limit = 0;\n    }\n\n    //\n    // Call expand(n) to add room for n additional bytes. Note that expand()\n    // examines the current position of the buffer first; we don't want to\n    // expand the buffer if the caller is writing to a location that is\n    // already in the buffer.\n    //\n    expand(n)\n    {\n        const sz = this.capacity === 0 ? n : this._position + n;\n        if(sz > this._limit)\n        {\n            this.resize(sz);\n        }\n    }\n\n    reset()\n    {\n        if(this._limit > 0 && this._limit * 2 < this.capacity)\n        {\n            //\n            // If the current buffer size is smaller than the\n            // buffer capacity, we shrink the buffer memory to the\n            // current size. This is to avoid holding on to too much\n            // memory if it's not needed anymore.\n            //\n            if(++this._shrinkCounter > 2)\n            {\n                this.reserve(this._limit);\n                this._shrinkCounter = 0;\n            }\n        }\n        else\n        {\n            this._shrinkCounter = 0;\n        }\n        this._limit = this.capacity();\n        this._position = 0;\n    }\n\n    reserve(n)\n    {\n        if(n > this.capacity)\n        {\n            const capacity = Math.max(1024, Math.max(n, 2 * this.capacity));\n            if(!this.b)\n            {\n                this.b = new ArrayBuffer(capacity);\n            }\n            else\n            {\n                const b = new Uint8Array(capacity);\n                b.set(new Uint8Array(this.b));\n                this.b = b.buffer;\n            }\n            this.v = new DataView(this.b);\n        }\n        else if(n < this.capacity)\n        {\n            this.b = this.b.slice(0, n);\n            this.v = new DataView(this.b);\n        }\n    }\n\n    put(v)\n    {\n        if(this._position === this._limit)\n        {\n            throw new RangeError(bufferOverflowExceptionMsg);\n        }\n        this.v.setUint8(this._position, v);\n        this._position++;\n    }\n\n    putAt(i, v)\n    {\n        if(i >= this._limit)\n        {\n            throw new RangeError(indexOutOfBoundsExceptionMsg);\n        }\n        this.v.setUint8(i, v);\n    }\n\n    putArray(v)\n    {\n        // Expects an Uint8Array\n        if(!(v instanceof Uint8Array))\n        {\n            throw new TypeError('argument is not a Uint8Array');\n        }\n        if(v.byteLength > 0)\n        {\n            if(this._position + v.length > this._limit)\n            {\n                throw new RangeError(bufferOverflowExceptionMsg);\n            }\n            new Uint8Array(this.b, 0, this.b.byteLength).set(v, this._position);\n            this._position += v.byteLength;\n        }\n    }\n\n    putShort(v)\n    {\n        if(this._position + 2 > this._limit)\n        {\n            throw new RangeError(bufferOverflowExceptionMsg);\n        }\n        this.v.setInt16(this._position, v, true);\n        this._position += 2;\n    }\n\n    putInt(v)\n    {\n        if(this._position + 4 > this._limit)\n        {\n            throw new RangeError(bufferOverflowExceptionMsg);\n        }\n        this.v.setInt32(this._position, v, true);\n        this._position += 4;\n    }\n\n    putIntAt(i, v)\n    {\n        if(i + 4 > this._limit || i < 0)\n        {\n            throw new RangeError(indexOutOfBoundsExceptionMsg);\n        }\n        this.v.setInt32(i, v, true);\n    }\n\n    putFloat(v)\n    {\n        if(this._position + 4 > this._limit)\n        {\n            throw new RangeError(bufferOverflowExceptionMsg);\n        }\n        this.v.setFloat32(this._position, v, true);\n        this._position += 4;\n    }\n\n    putDouble(v)\n    {\n        if(this._position + 8 > this._limit)\n        {\n            throw new RangeError(bufferOverflowExceptionMsg);\n        }\n        this.v.setFloat64(this._position, v, true);\n        this._position += 8;\n    }\n\n    putLong(v)\n    {\n        if(this._position + 8 > this._limit)\n        {\n            throw new RangeError(bufferOverflowExceptionMsg);\n        }\n        this.v.setInt32(this._position, v.low, true);\n        this._position += 4;\n        this.v.setInt32(this._position, v.high, true);\n        this._position += 4;\n    }\n\n    writeString(stream, v)\n    {\n        //\n        // Encode the string as utf8\n        //\n        const encoded = unescape(encodeURIComponent(v));\n\n        stream.writeSize(encoded.length);\n        stream.expand(encoded.length);\n        this.putString(encoded, encoded.length);\n    }\n\n    putString(v, sz)\n    {\n        if(this._position + sz > this._limit)\n        {\n            throw new RangeError(bufferOverflowExceptionMsg);\n        }\n        for(let i = 0; i < sz; ++i)\n        {\n            this.v.setUint8(this._position, v.charCodeAt(i));\n            this._position++;\n        }\n    }\n\n    get()\n    {\n        if(this._position >= this._limit)\n        {\n            throw new RangeError(bufferUnderflowExceptionMsg);\n        }\n        const v = this.v.getUint8(this._position);\n        this._position++;\n        return v;\n    }\n\n    getAt(i)\n    {\n        if(i < 0 || i >= this._limit)\n        {\n            throw new RangeError(indexOutOfBoundsExceptionMsg);\n        }\n        return this.v.getUint8(i);\n    }\n\n    getArray(length)\n    {\n        if(this._position + length > this._limit)\n        {\n            throw new RangeError(bufferUnderflowExceptionMsg);\n        }\n        const buffer = this.b.slice(this._position, this._position + length);\n        this._position += length;\n        return new Uint8Array(buffer);\n    }\n\n    getArrayAt(position, length)\n    {\n        if(position + length > this._limit)\n        {\n            throw new RangeError(bufferUnderflowExceptionMsg);\n        }\n        return new Uint8Array(\n            this.b.slice(position, position + length === undefined ?\n                         (this.b.byteLength - position) : length));\n    }\n\n    getShort()\n    {\n        if(this._limit - this._position < 2)\n        {\n            throw new RangeError(bufferUnderflowExceptionMsg);\n        }\n        const v = this.v.getInt16(this._position, true);\n        this._position += 2;\n        return v;\n    }\n\n    getInt()\n    {\n        if(this._limit - this._position < 4)\n        {\n            throw new RangeError(bufferUnderflowExceptionMsg);\n        }\n        const v = this.v.getInt32(this._position, true);\n        this._position += 4;\n        return v;\n    }\n\n    getFloat()\n    {\n        if(this._limit - this._position < 4)\n        {\n            throw new RangeError(bufferUnderflowExceptionMsg);\n        }\n        const v = this.v.getFloat32(this._position, true);\n        this._position += 4;\n        return v;\n    }\n\n    getDouble()\n    {\n        if(this._limit - this._position < 8)\n        {\n            throw new RangeError(bufferUnderflowExceptionMsg);\n        }\n        const v = this.v.getFloat64(this._position, true);\n        this._position += 8;\n        return v;\n    }\n\n    getLong()\n    {\n        if(this._limit - this._position < 8)\n        {\n            throw new RangeError(bufferUnderflowExceptionMsg);\n        }\n        const low = this.v.getUint32(this._position, true);\n        this._position += 4;\n        const high = this.v.getUint32(this._position, true);\n        this._position += 4;\n\n        return new Long(high, low);\n    }\n\n    getString(length)\n    {\n        if(this._position + length > this._limit)\n        {\n            throw new RangeError(bufferUnderflowExceptionMsg);\n        }\n\n        const data = new DataView(this.b, this._position, length);\n        let s = \"\";\n        for(let i = 0; i < length; ++i)\n        {\n            s += String.fromCharCode(data.getUint8(i));\n        }\n        this._position += length;\n        return decodeURIComponent(escape(s));\n    }\n\n    get position()\n    {\n        return this._position;\n    }\n\n    set position(value)\n    {\n        if(value >= 0 && value <= this._limit)\n        {\n            this._position = value;\n        }\n    }\n\n    get limit()\n    {\n        return this._limit;\n    }\n\n    set limit(value)\n    {\n        if(value <= this.capacity)\n        {\n            this._limit = value;\n            if(this._position > value)\n            {\n                this._position = value;\n            }\n        }\n    }\n\n    get capacity()\n    {\n        return this.b === null ? 0 : this.b.byteLength;\n    }\n\n    get remaining()\n    {\n        return this._limit - this._position;\n    }\n}\n\nIce.Buffer = Buffer;\nmodule.exports.Ice = Ice;\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/Buffer.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/BuiltinSequences.js":
/*!******************************************************!*\
  !*** ./node_modules/ice/src/Ice/BuiltinSequences.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n//\n// Ice version 3.7.10\n//\n// <auto-generated>\n//\n// Generated from file `BuiltinSequences.ice'\n//\n// Warning: do not edit this file.\n//\n// </auto-generated>\n//\n\n/* eslint-disable */\n/* jshint ignore: start */\n\n/* slice2js browser-bundle-skip */\nconst _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\n__webpack_require__(/*! ../Ice/Object */ \"./node_modules/ice/src/Ice/Object.js\");\n__webpack_require__(/*! ../Ice/Value */ \"./node_modules/ice/src/Ice/Value.js\");\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\nconst Ice = _ModuleRegistry.module(\"Ice\");\n\nconst Slice = Ice.Slice;\n/* slice2js browser-bundle-skip-end */\n\nSlice.defineSequence(Ice, \"BoolSeqHelper\", \"Ice.BoolHelper\", true);\n\nSlice.defineSequence(Ice, \"ByteSeqHelper\", \"Ice.ByteHelper\", true);\n\nSlice.defineSequence(Ice, \"ShortSeqHelper\", \"Ice.ShortHelper\", true);\n\nSlice.defineSequence(Ice, \"IntSeqHelper\", \"Ice.IntHelper\", true);\n\nSlice.defineSequence(Ice, \"LongSeqHelper\", \"Ice.LongHelper\", true);\n\nSlice.defineSequence(Ice, \"FloatSeqHelper\", \"Ice.FloatHelper\", true);\n\nSlice.defineSequence(Ice, \"DoubleSeqHelper\", \"Ice.DoubleHelper\", true);\n\nSlice.defineSequence(Ice, \"StringSeqHelper\", \"Ice.StringHelper\", false);\n\nSlice.defineSequence(Ice, \"ObjectSeqHelper\", \"Ice.ObjectHelper\", false, \"Ice.Value\");\n\nSlice.defineSequence(Ice, \"ObjectProxySeqHelper\", \"Ice.ObjectPrx\", false);\n/* slice2js browser-bundle-skip */\nexports.Ice = Ice;\n/* slice2js browser-bundle-skip-end */\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/BuiltinSequences.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/Communicator.js":
/*!**************************************************!*\
  !*** ./node_modules/ice/src/Ice/Communicator.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n//\n// Ice version 3.7.10\n//\n// <auto-generated>\n//\n// Generated from file `Communicator.ice'\n//\n// Warning: do not edit this file.\n//\n// </auto-generated>\n//\n\n/* eslint-disable */\n/* jshint ignore: start */\n\n/* slice2js browser-bundle-skip */\nconst _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\n__webpack_require__(/*! ../Ice/Object */ \"./node_modules/ice/src/Ice/Object.js\");\n__webpack_require__(/*! ../Ice/Value */ \"./node_modules/ice/src/Ice/Value.js\");\n__webpack_require__(/*! ../Ice/ObjectPrx */ \"./node_modules/ice/src/Ice/ObjectPrx.js\");\n__webpack_require__(/*! ../Ice/EnumBase */ \"./node_modules/ice/src/Ice/EnumBase.js\");\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\n__webpack_require__(/*! ../Ice/LoggerF */ \"./node_modules/ice/src/Ice/LoggerF.js\");\n__webpack_require__(/*! ../Ice/InstrumentationF */ \"./node_modules/ice/src/Ice/InstrumentationF.js\");\n__webpack_require__(/*! ../Ice/ObjectAdapterF */ \"./node_modules/ice/src/Ice/ObjectAdapterF.js\");\n__webpack_require__(/*! ../Ice/ObjectFactory */ \"./node_modules/ice/src/Ice/ObjectFactory.js\");\n__webpack_require__(/*! ../Ice/ValueFactory */ \"./node_modules/ice/src/Ice/ValueFactory.js\");\n__webpack_require__(/*! ../Ice/Router */ \"./node_modules/ice/src/Ice/Router.js\");\n__webpack_require__(/*! ../Ice/Locator */ \"./node_modules/ice/src/Ice/Locator.js\");\n__webpack_require__(/*! ../Ice/PluginF */ \"./node_modules/ice/src/Ice/PluginF.js\");\n__webpack_require__(/*! ../Ice/ImplicitContextF */ \"./node_modules/ice/src/Ice/ImplicitContextF.js\");\n__webpack_require__(/*! ../Ice/Current */ \"./node_modules/ice/src/Ice/Current.js\");\n__webpack_require__(/*! ../Ice/Properties */ \"./node_modules/ice/src/Ice/Properties.js\");\n__webpack_require__(/*! ../Ice/FacetMap */ \"./node_modules/ice/src/Ice/FacetMap.js\");\n__webpack_require__(/*! ../Ice/Connection */ \"./node_modules/ice/src/Ice/Connection.js\");\nconst Ice = _ModuleRegistry.module(\"Ice\");\n\nconst Slice = Ice.Slice;\n/* slice2js browser-bundle-skip-end */\n\n/**\n * The output mode for xxxToString method such as identityToString and proxyToString.\n * The actual encoding format for the string is the same for all modes: you\n * don't need to specify an encoding format or mode when reading such a string.\n *\n **/\nIce.ToStringMode = Slice.defineEnum([\n    ['Unicode', 0], ['ASCII', 1], ['Compat', 2]]);\n/* slice2js browser-bundle-skip */\nexports.Ice = Ice;\n/* slice2js browser-bundle-skip-end */\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/Communicator.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/CommunicatorI.js":
/*!***************************************************!*\
  !*** ./node_modules/ice/src/Ice/CommunicatorI.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nconst Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n\n__webpack_require__(/*! ../Ice/AsyncResultBase */ \"./node_modules/ice/src/Ice/AsyncResultBase.js\");\n__webpack_require__(/*! ../Ice/Debug */ \"./node_modules/ice/src/Ice/Debug.js\");\n__webpack_require__(/*! ../Ice/Instance */ \"./node_modules/ice/src/Ice/Instance.js\");\n__webpack_require__(/*! ../Ice/LocalException */ \"./node_modules/ice/src/Ice/LocalException.js\");\n__webpack_require__(/*! ../Ice/UUID */ \"./node_modules/ice/src/Ice/UUID.js\");\n\nconst Instance = Ice.Instance;\nconst Debug = Ice.Debug;\n\n//\n// Ice.Communicator\n//\nclass Communicator\n{\n    constructor(initData)\n    {\n        this._instance = new Instance(initData);\n    }\n\n    //\n    // Certain initialization tasks need to be completed after the\n    // constructor.\n    //\n    finishSetup(promise)\n    {\n        this._instance.finishSetup(this, promise);\n    }\n\n    destroy()\n    {\n        return this._instance.destroy();\n    }\n\n    shutdown()\n    {\n        try\n        {\n            return this._instance.objectAdapterFactory().shutdown();\n        }\n        catch(ex)\n        {\n            Debug.assert(ex instanceof Ice.CommunicatorDestroyedException);\n            return Ice.Promise.resolve();\n        }\n    }\n\n    waitForShutdown()\n    {\n        try\n        {\n            return this._instance.objectAdapterFactory().waitForShutdown();\n        }\n        catch(ex)\n        {\n            Debug.assert(ex instanceof Ice.CommunicatorDestroyedException);\n            return Ice.Promise.resolve();\n        }\n    }\n\n    isShutdown()\n    {\n        try\n        {\n            return this._instance.objectAdapterFactory().isShutdown();\n        }\n        catch(ex)\n        {\n            if(!(ex instanceof Ice.CommunicatorDestroyedException))\n            {\n                throw ex;\n            }\n            return true;\n        }\n    }\n\n    stringToProxy(s)\n    {\n        return this._instance.proxyFactory().stringToProxy(s);\n    }\n\n    proxyToString(proxy)\n    {\n        return this._instance.proxyFactory().proxyToString(proxy);\n    }\n\n    propertyToProxy(s)\n    {\n        return this._instance.proxyFactory().propertyToProxy(s);\n    }\n\n    proxyToProperty(proxy, prefix)\n    {\n        return this._instance.proxyFactory().proxyToProperty(proxy, prefix);\n    }\n\n    stringToIdentity(s)\n    {\n        return Ice.stringToIdentity(s);\n    }\n\n    identityToString(ident)\n    {\n        return Ice.identityToString(ident, this._instance.toStringMode());\n    }\n\n    createObjectAdapter(name)\n    {\n        const promise = new Ice.AsyncResultBase(this, \"createObjectAdapter\", this, null, null);\n        this._instance.objectAdapterFactory().createObjectAdapter(name, null, promise);\n        return promise;\n    }\n\n    createObjectAdapterWithEndpoints(name, endpoints)\n    {\n        if(name.length === 0)\n        {\n            name = Ice.generateUUID();\n        }\n\n        this.getProperties().setProperty(name + \".Endpoints\", endpoints);\n        const promise = new Ice.AsyncResultBase(this, \"createObjectAdapterWithEndpoints\", this, null, null);\n        this._instance.objectAdapterFactory().createObjectAdapter(name, null, promise);\n        return promise;\n    }\n\n    createObjectAdapterWithRouter(name, router)\n    {\n        if(name.length === 0)\n        {\n            name = Ice.generateUUID();\n        }\n\n        const promise = new Ice.AsyncResultBase(this, \"createObjectAdapterWithRouter\", this, null, null);\n\n        //\n        // We set the proxy properties here, although we still use the proxy supplied.\n        //\n        this.proxyToProperty(router, name + \".Router\").forEach((value, key) =>\n            {\n                this.getProperties().setProperty(key, value);\n            });\n\n        this._instance.objectAdapterFactory().createObjectAdapter(name, router, promise);\n        return promise;\n    }\n\n    addObjectFactory(factory, id)\n    {\n        this._instance.addObjectFactory(factory, id);\n    }\n\n    findObjectFactory(id)\n    {\n        return this._instance.findObjectFactory(id);\n    }\n\n    getValueFactoryManager()\n    {\n        return this._instance.initializationData().valueFactoryManager;\n    }\n\n    getImplicitContext()\n    {\n        return this._instance.getImplicitContext();\n    }\n\n    getProperties()\n    {\n        return this._instance.initializationData().properties;\n    }\n\n    getLogger()\n    {\n        return this._instance.initializationData().logger;\n    }\n\n    getDefaultRouter()\n    {\n        return this._instance.referenceFactory().getDefaultRouter();\n    }\n\n    setDefaultRouter(router)\n    {\n        this._instance.setDefaultRouter(router);\n    }\n\n    getDefaultLocator()\n    {\n        return this._instance.referenceFactory().getDefaultLocator();\n    }\n\n    setDefaultLocator(locator)\n    {\n        this._instance.setDefaultLocator(locator);\n    }\n\n    flushBatchRequests()\n    {\n        return this._instance.outgoingConnectionFactory().flushAsyncBatchRequests();\n    }\n\n    get instance()\n    {\n        return this._instance;\n    }\n}\n\nIce.Communicator = Communicator;\nmodule.exports.Ice = Ice;\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/CommunicatorI.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/CompactIdRegistry.js":
/*!*******************************************************!*\
  !*** ./node_modules/ice/src/Ice/CompactIdRegistry.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nconst Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\nIce.CompactIdRegistry = new Map();\nmodule.exports.Ice = Ice;\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/CompactIdRegistry.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/ConnectRequestHandler.js":
/*!***********************************************************!*\
  !*** ./node_modules/ice/src/Ice/ConnectRequestHandler.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nconst Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n\n__webpack_require__(/*! ../Ice/AsyncStatus */ \"./node_modules/ice/src/Ice/AsyncStatus.js\");\n__webpack_require__(/*! ../Ice/ConnectionRequestHandler */ \"./node_modules/ice/src/Ice/ConnectionRequestHandler.js\");\n__webpack_require__(/*! ../Ice/Debug */ \"./node_modules/ice/src/Ice/Debug.js\");\n__webpack_require__(/*! ../Ice/Exception */ \"./node_modules/ice/src/Ice/Exception.js\");\n__webpack_require__(/*! ../Ice/ReferenceMode */ \"./node_modules/ice/src/Ice/ReferenceMode.js\");\n__webpack_require__(/*! ../Ice/RetryException */ \"./node_modules/ice/src/Ice/RetryException.js\");\n\nconst AsyncStatus = Ice.AsyncStatus;\nconst ConnectionRequestHandler = Ice.ConnectionRequestHandler;\nconst Debug = Ice.Debug;\nconst RetryException = Ice.RetryException;\nconst ReferenceMode = Ice.ReferenceMode;\nconst LocalException = Ice.LocalException;\n\nclass ConnectRequestHandler\n{\n    constructor(ref, proxy)\n    {\n        this._reference = ref;\n        this._response = ref.getMode() === ReferenceMode.ModeTwoway;\n        this._proxy = proxy;\n        this._proxies = [];\n        this._initialized = false;\n\n        this._connection = null;\n        this._exception = null;\n        this._requests = [];\n    }\n\n    connect(proxy)\n    {\n        if(!this.initialized())\n        {\n            this._proxies.push(proxy);\n        }\n        return this._requestHandler ? this._requestHandler : this;\n    }\n\n    update(previousHandler, newHandler)\n    {\n        return previousHandler === this ? newHandler : this;\n    }\n\n    sendAsyncRequest(out)\n    {\n        if(!this._initialized)\n        {\n            out.cancelable(this); // This will throw if the request is canceled\n        }\n\n        if(!this.initialized())\n        {\n            this._requests.push(out);\n            return AsyncStatus.Queued;\n        }\n        return out.invokeRemote(this._connection, this._response);\n    }\n\n    asyncRequestCanceled(out, ex)\n    {\n        if(this._exception !== null)\n        {\n            return; // The request has been notified of a failure already.\n        }\n\n        if(!this.initialized())\n        {\n            for(let i = 0; i < this._requests.length; i++)\n            {\n                if(this._requests[i] === out)\n                {\n                    out.completedEx(ex);\n                    this._requests.splice(i, 1);\n                    return;\n                }\n            }\n            Debug.assert(false); // The request has to be queued if it timed out and we're not initialized yet.\n        }\n        this._connection.asyncRequestCanceled(out, ex);\n    }\n\n    getReference()\n    {\n        return this._reference;\n    }\n\n    getConnection()\n    {\n        if(this._exception !== null)\n        {\n            throw this._exception;\n        }\n        else\n        {\n            return this._connection;\n        }\n    }\n\n    //\n    // Implementation of Reference_GetConnectionCallback\n    //\n    setConnection(connection)\n    {\n        Debug.assert(this._exception === null && this._connection === null);\n\n        this._connection = connection;\n\n        //\n        // If this proxy is for a non-local object, and we are using a router, then\n        // add this proxy to the router info object.\n        //\n        const ri = this._reference.getRouterInfo();\n        if(ri !== null)\n        {\n            ri.addProxy(this._proxy).then(\n                //\n                // The proxy was added to the router\n                // info, we're now ready to send the\n                // queued requests.\n                //\n                () => this.flushRequests(),\n                ex => this.setException(ex));\n            return; // The request handler will be initialized once addProxy completes.\n        }\n\n        //\n        // We can now send the queued requests.\n        //\n        this.flushRequests();\n    }\n\n    setException(ex)\n    {\n        Debug.assert(!this._initialized && this._exception === null);\n\n        this._exception = ex;\n        this._proxies.length = 0;\n        this._proxy = null; // Break cyclic reference count.\n\n        //\n        // NOTE: remove the request handler *before* notifying the\n        // requests that the connection failed. It's important to ensure\n        // that future invocations will obtain a new connect request\n        // handler once invocations are notified.\n        //\n        try\n        {\n            this._reference.getInstance().requestHandlerFactory().removeRequestHandler(this._reference, this);\n        }\n        catch(exc)\n        {\n            // Ignore\n        }\n\n        this._requests.forEach(request =>\n            {\n                if(request !== null)\n                {\n                    request.completedEx(this._exception);\n                }\n            });\n        this._requests.length = 0;\n    }\n\n    initialized()\n    {\n        if(this._initialized)\n        {\n            Debug.assert(this._connection !== null);\n            return true;\n        }\n        else if(this._exception !== null)\n        {\n            if(this._connection !== null)\n            {\n                //\n                // Only throw if the connection didn't get established. If\n                // it died after being established, we allow the caller to\n                // retry the connection establishment by not throwing here\n                // (the connection will throw RetryException).\n                //\n                return true;\n            }\n            throw this._exception;\n        }\n        else\n        {\n            return this._initialized;\n        }\n    }\n\n    flushRequests()\n    {\n        Debug.assert(this._connection !== null && !this._initialized);\n\n        let exception = null;\n        this._requests.forEach(request =>\n            {\n                try\n                {\n                    request.invokeRemote(this._connection, this._response);\n                }\n                catch(ex)\n                {\n                    if(ex instanceof RetryException)\n                    {\n                        exception = ex.inner;\n\n                        // Remove the request handler before retrying.\n                        this._reference.getInstance().requestHandlerFactory().removeRequestHandler(this._reference, this);\n                        request.retryException(ex.inner);\n                    }\n                    else\n                    {\n                        Debug.assert(ex instanceof LocalException);\n                        exception = ex;\n                        request.out.completedEx(ex);\n                    }\n                }\n            });\n        this._requests.length = 0;\n\n        if(this._reference.getCacheConnection() && exception === null)\n        {\n            this._requestHandler = new ConnectionRequestHandler(this._reference, this._connection);\n            this._proxies.forEach(proxy => proxy._updateRequestHandler(this, this._requestHandler));\n        }\n\n        Debug.assert(!this._initialized);\n        this._exception = exception;\n        this._initialized = this._exception === null;\n\n        //\n        // Only remove once all the requests are flushed to\n        // guarantee serialization.\n        //\n        this._reference.getInstance().requestHandlerFactory().removeRequestHandler(this._reference, this);\n\n        this._proxies.length = 0;\n        this._proxy = null; // Break cyclic reference count.\n    }\n}\n\nIce.ConnectRequestHandler = ConnectRequestHandler;\nmodule.exports.Ice = Ice;\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/ConnectRequestHandler.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/Connection.js":
/*!************************************************!*\
  !*** ./node_modules/ice/src/Ice/Connection.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n//\n// Ice version 3.7.10\n//\n// <auto-generated>\n//\n// Generated from file `Connection.ice'\n//\n// Warning: do not edit this file.\n//\n// </auto-generated>\n//\n\n/* eslint-disable */\n/* jshint ignore: start */\n\n/* slice2js browser-bundle-skip */\nconst _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\n__webpack_require__(/*! ../Ice/Object */ \"./node_modules/ice/src/Ice/Object.js\");\n__webpack_require__(/*! ../Ice/Value */ \"./node_modules/ice/src/Ice/Value.js\");\n__webpack_require__(/*! ../Ice/ObjectPrx */ \"./node_modules/ice/src/Ice/ObjectPrx.js\");\n__webpack_require__(/*! ../Ice/Struct */ \"./node_modules/ice/src/Ice/Struct.js\");\n__webpack_require__(/*! ../Ice/EnumBase */ \"./node_modules/ice/src/Ice/EnumBase.js\");\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\n__webpack_require__(/*! ../Ice/ObjectAdapterF */ \"./node_modules/ice/src/Ice/ObjectAdapterF.js\");\n__webpack_require__(/*! ../Ice/Identity */ \"./node_modules/ice/src/Ice/Identity.js\");\n__webpack_require__(/*! ../Ice/Endpoint */ \"./node_modules/ice/src/Ice/Endpoint.js\");\nconst Ice = _ModuleRegistry.module(\"Ice\");\n\nconst Slice = Ice.Slice;\n/* slice2js browser-bundle-skip-end */\n\n/**\n * The batch compression option when flushing queued batch requests.\n *\n **/\nIce.CompressBatch = Slice.defineEnum([\n    ['Yes', 0], ['No', 1], ['BasedOnProxy', 2]]);\n\n/**\n * Base class providing access to the connection details.\n *\n **/\nIce.ConnectionInfo = class\n{\n    constructor(underlying = null, incoming = false, adapterName = \"\", connectionId = \"\")\n    {\n        this.underlying = underlying;\n        this.incoming = incoming;\n        this.adapterName = adapterName;\n        this.connectionId = connectionId;\n    }\n};\n\n\n/**\n * Specifies the close semantics for Active Connection Management.\n **/\nIce.ACMClose = Slice.defineEnum([\n    ['CloseOff', 0], ['CloseOnIdle', 1], ['CloseOnInvocation', 2], ['CloseOnInvocationAndIdle', 3], ['CloseOnIdleForceful', 4]]);\n\n/**\n * Specifies the heartbeat semantics for Active Connection Management.\n **/\nIce.ACMHeartbeat = Slice.defineEnum([\n    ['HeartbeatOff', 0], ['HeartbeatOnDispatch', 1], ['HeartbeatOnIdle', 2], ['HeartbeatAlways', 3]]);\n\n/**\n * A collection of Active Connection Management configuration settings.\n **/\nIce.ACM = class\n{\n    constructor(timeout = 0, close = Ice.ACMClose.CloseOff, heartbeat = Ice.ACMHeartbeat.HeartbeatOff)\n    {\n        this.timeout = timeout;\n        this.close = close;\n        this.heartbeat = heartbeat;\n    }\n};\n\nSlice.defineStruct(Ice.ACM, true, true);\n\n/**\n * Determines the behavior when manually closing a connection.\n **/\nIce.ConnectionClose = Slice.defineEnum([\n    ['Forcefully', 0], ['Gracefully', 1], ['GracefullyWithWait', 2]]);\n\n/**\n * Provides access to the connection details of an IP connection\n *\n **/\nIce.IPConnectionInfo = class extends Ice.ConnectionInfo\n{\n    constructor(underlying, incoming, adapterName, connectionId, localAddress = \"\", localPort = -1, remoteAddress = \"\", remotePort = -1)\n    {\n        super(underlying, incoming, adapterName, connectionId);\n        this.localAddress = localAddress;\n        this.localPort = localPort;\n        this.remoteAddress = remoteAddress;\n        this.remotePort = remotePort;\n    }\n};\n\n\n/**\n * Provides access to the connection details of a TCP connection\n *\n **/\nIce.TCPConnectionInfo = class extends Ice.IPConnectionInfo\n{\n    constructor(underlying, incoming, adapterName, connectionId, localAddress, localPort, remoteAddress, remotePort, rcvSize = 0, sndSize = 0)\n    {\n        super(underlying, incoming, adapterName, connectionId, localAddress, localPort, remoteAddress, remotePort);\n        this.rcvSize = rcvSize;\n        this.sndSize = sndSize;\n    }\n};\n\n\n/**\n * Provides access to the connection details of a UDP connection\n *\n **/\nIce.UDPConnectionInfo = class extends Ice.IPConnectionInfo\n{\n    constructor(underlying, incoming, adapterName, connectionId, localAddress, localPort, remoteAddress, remotePort, mcastAddress = \"\", mcastPort = -1, rcvSize = 0, sndSize = 0)\n    {\n        super(underlying, incoming, adapterName, connectionId, localAddress, localPort, remoteAddress, remotePort);\n        this.mcastAddress = mcastAddress;\n        this.mcastPort = mcastPort;\n        this.rcvSize = rcvSize;\n        this.sndSize = sndSize;\n    }\n};\n\n\nSlice.defineDictionary(Ice, \"HeaderDict\", \"HeaderDictHelper\", \"Ice.StringHelper\", \"Ice.StringHelper\", false, undefined, undefined);\n\n/**\n * Provides access to the connection details of a WebSocket connection\n *\n **/\nIce.WSConnectionInfo = class extends Ice.ConnectionInfo\n{\n    constructor(underlying, incoming, adapterName, connectionId, headers = null)\n    {\n        super(underlying, incoming, adapterName, connectionId);\n        this.headers = headers;\n    }\n};\n\n/* slice2js browser-bundle-skip */\nexports.Ice = Ice;\n/* slice2js browser-bundle-skip-end */\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/Connection.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/ConnectionF.js":
/*!*************************************************!*\
  !*** ./node_modules/ice/src/Ice/ConnectionF.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n//\n// Ice version 3.7.10\n//\n// <auto-generated>\n//\n// Generated from file `ConnectionF.ice'\n//\n// Warning: do not edit this file.\n//\n// </auto-generated>\n//\n\n/* eslint-disable */\n/* jshint ignore: start */\n\n/* slice2js browser-bundle-skip */\nconst _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\nconst Ice = _ModuleRegistry.module(\"Ice\");\n\nconst Slice = Ice.Slice;\n/* slice2js browser-bundle-skip-end */\n/* slice2js browser-bundle-skip */\nexports.Ice = Ice;\n/* slice2js browser-bundle-skip-end */\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/ConnectionF.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/ConnectionI.js":
/*!*************************************************!*\
  !*** ./node_modules/ice/src/Ice/ConnectionI.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nconst Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n__webpack_require__(/*! ../Ice/AsyncStatus */ \"./node_modules/ice/src/Ice/AsyncStatus.js\");\n__webpack_require__(/*! ../Ice/Stream */ \"./node_modules/ice/src/Ice/Stream.js\");\n__webpack_require__(/*! ../Ice/OutgoingAsync */ \"./node_modules/ice/src/Ice/OutgoingAsync.js\");\n__webpack_require__(/*! ../Ice/Debug */ \"./node_modules/ice/src/Ice/Debug.js\");\n__webpack_require__(/*! ../Ice/ExUtil */ \"./node_modules/ice/src/Ice/ExUtil.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/IncomingAsync */ \"./node_modules/ice/src/Ice/IncomingAsync.js\");\n__webpack_require__(/*! ../Ice/RetryException */ \"./node_modules/ice/src/Ice/RetryException.js\");\n__webpack_require__(/*! ../Ice/Promise */ \"./node_modules/ice/src/Ice/Promise.js\");\n__webpack_require__(/*! ../Ice/Protocol */ \"./node_modules/ice/src/Ice/Protocol.js\");\n__webpack_require__(/*! ../Ice/SocketOperation */ \"./node_modules/ice/src/Ice/SocketOperation.js\");\n__webpack_require__(/*! ../Ice/Timer */ \"./node_modules/ice/src/Ice/Timer.js\");\n__webpack_require__(/*! ../Ice/TraceUtil */ \"./node_modules/ice/src/Ice/TraceUtil.js\");\n__webpack_require__(/*! ../Ice/Version */ \"./node_modules/ice/src/Ice/Version.js\");\n__webpack_require__(/*! ../Ice/Exception */ \"./node_modules/ice/src/Ice/Exception.js\");\n__webpack_require__(/*! ../Ice/LocalException */ \"./node_modules/ice/src/Ice/LocalException.js\");\n__webpack_require__(/*! ../Ice/BatchRequestQueue */ \"./node_modules/ice/src/Ice/BatchRequestQueue.js\");\n\nconst AsyncStatus = Ice.AsyncStatus;\nconst AsyncResultBase = Ice.AsyncResultBase;\nconst InputStream = Ice.InputStream;\nconst OutputStream = Ice.OutputStream;\nconst BatchRequestQueue = Ice.BatchRequestQueue;\nconst ConnectionFlushBatch = Ice.ConnectionFlushBatch;\nconst HeartbeatAsync = Ice.HeartbeatAsync;\nconst Debug = Ice.Debug;\nconst ExUtil = Ice.ExUtil;\nconst HashMap = Ice.HashMap;\nconst IncomingAsync = Ice.IncomingAsync;\nconst RetryException = Ice.RetryException;\nconst Protocol = Ice.Protocol;\nconst SocketOperation = Ice.SocketOperation;\nconst Timer = Ice.Timer;\nconst TraceUtil = Ice.TraceUtil;\nconst ProtocolVersion = Ice.ProtocolVersion;\nconst EncodingVersion = Ice.EncodingVersion;\nconst ACM = Ice.ACM;\nconst ACMClose = Ice.ACMClose;\nconst ACMHeartbeat = Ice.ACMHeartbeat;\nconst ConnectionClose = Ice.ConnectionClose;\n\nconst StateNotInitialized = 0;\nconst StateNotValidated = 1;\nconst StateActive = 2;\nconst StateHolding = 3;\nconst StateClosing = 4;\nconst StateClosed = 5;\nconst StateFinished = 6;\n\nclass MessageInfo\n{\n    constructor(instance)\n    {\n        this.stream = new InputStream(instance, Protocol.currentProtocolEncoding);\n        this.invokeNum = 0;\n        this.requestId = 0;\n        this.servantManager = null;\n        this.adapter = null;\n        this.outAsync = null;\n        this.heartbeatCallback = null;\n    }\n}\n\nclass ConnectionI\n{\n    constructor(communicator, instance, monitor, transceiver, endpoint, incoming, adapter)\n    {\n        this._communicator = communicator;\n        this._instance = instance;\n        this._monitor = monitor;\n        this._transceiver = transceiver;\n        this._desc = transceiver.toString();\n        this._type = transceiver.type();\n        this._endpoint = endpoint;\n        this._incoming = incoming;\n        this._adapter = adapter;\n        const initData = instance.initializationData();\n        this._logger = initData.logger; // Cached for better performance.\n        this._traceLevels = instance.traceLevels(); // Cached for better performance.\n        this._timer = instance.timer();\n        this._writeTimeoutId = 0;\n        this._writeTimeoutScheduled = false;\n        this._readTimeoutId = 0;\n        this._readTimeoutScheduled = false;\n\n        this._hasMoreData = {value: false};\n\n        this._warn = initData.properties.getPropertyAsInt(\"Ice.Warn.Connections\") > 0;\n        this._warnUdp = instance.initializationData().properties.getPropertyAsInt(\"Ice.Warn.Datagrams\") > 0;\n        this._acmLastActivity = this._monitor !== null && this._monitor.getACM().timeout > 0 ? Date.now() : -1;\n        this._nextRequestId = 1;\n        this._messageSizeMax = adapter ? adapter.messageSizeMax() : instance.messageSizeMax();\n        this._batchRequestQueue = new BatchRequestQueue(instance, endpoint.datagram());\n\n        this._sendStreams = [];\n\n        this._readStream = new InputStream(instance, Protocol.currentProtocolEncoding);\n        this._readHeader = false;\n        this._writeStream = new OutputStream(instance, Protocol.currentProtocolEncoding);\n\n        this._readStreamPos = -1;\n        this._writeStreamPos = -1;\n\n        this._dispatchCount = 0;\n\n        this._state = StateNotInitialized;\n        this._shutdownInitiated = false;\n        this._initialized = false;\n        this._validated = false;\n\n        this._readProtocol = new ProtocolVersion();\n        this._readProtocolEncoding = new EncodingVersion();\n\n        this._asyncRequests = new HashMap(); // Map<int, OutgoingAsync>\n\n        this._exception = null;\n\n        this._startPromise = null;\n        this._closePromises = [];\n        this._finishedPromises = [];\n\n        if(this._adapter !== null)\n        {\n            this._servantManager = this._adapter.getServantManager();\n        }\n        else\n        {\n            this._servantManager = null;\n        }\n        this._closeCallback = null;\n        this._heartbeatCallback = null;\n    }\n\n    start()\n    {\n        Debug.assert(this._startPromise === null);\n\n        try\n        {\n            // The connection might already be closed if the communicator was destroyed.\n            if(this._state >= StateClosed)\n            {\n                Debug.assert(this._exception !== null);\n                return Ice.Promise.reject(this._exception);\n            }\n\n            this._startPromise = new Ice.Promise();\n            this._transceiver.setCallbacks(\n                () => this.message(SocketOperation.Write), // connected callback\n                () => this.message(SocketOperation.Read), // read callback\n                () => this.message(SocketOperation.Write) // write callback\n            );\n            this.initialize();\n        }\n        catch(ex)\n        {\n            const startPromise = this._startPromise;\n            this.exception(ex);\n            return startPromise;\n        }\n        return this._startPromise;\n    }\n\n    activate()\n    {\n        if(this._state <= StateNotValidated)\n        {\n            return;\n        }\n\n        if(this._acmLastActivity > 0)\n        {\n            this._acmLastActivity = Date.now();\n        }\n        this.setState(StateActive);\n    }\n\n    hold()\n    {\n        if(this._state <= StateNotValidated)\n        {\n            return;\n        }\n\n        this.setState(StateHolding);\n    }\n\n    destroy(reason)\n    {\n        switch(reason)\n        {\n            case ConnectionI.ObjectAdapterDeactivated:\n            {\n                this.setState(StateClosing, new Ice.ObjectAdapterDeactivatedException());\n                break;\n            }\n\n            case ConnectionI.CommunicatorDestroyed:\n            {\n                this.setState(StateClosing, new Ice.CommunicatorDestroyedException());\n                break;\n            }\n\n            default:\n            {\n                Debug.assert(false);\n                break;\n            }\n        }\n    }\n\n    close(mode)\n    {\n        const r = new AsyncResultBase(this._communicator, \"close\", this, null, null);\n\n        if(mode == ConnectionClose.Forcefully)\n        {\n            this.setState(StateClosed, new Ice.ConnectionManuallyClosedException(false));\n            r.resolve();\n        }\n        else if(mode == ConnectionClose.Gracefully)\n        {\n            this.setState(StateClosing, new Ice.ConnectionManuallyClosedException(true));\n            r.resolve();\n        }\n        else\n        {\n            Debug.assert(mode == ConnectionClose.GracefullyWithWait);\n\n            //\n            // Wait until all outstanding requests have been completed.\n            //\n            this._closePromises.push(r);\n            this.checkClose();\n        }\n\n        return r;\n    }\n\n    checkClose()\n    {\n        //\n        // If close(GracefullyWithWait) has been called, then we need to check if all\n        // requests have completed and we can transition to StateClosing. We also\n        // complete outstanding promises.\n        //\n        if(this._asyncRequests.size === 0 && this._closePromises.length > 0)\n        {\n            //\n            // The caller doesn't expect the state of the connection to change when this is called so\n            // we defer the check immediately after doing whather we're doing. This is consistent with\n            // other implementations as well.\n            //\n            Timer.setImmediate(() =>\n            {\n                this.setState(StateClosing, new Ice.ConnectionManuallyClosedException(true));\n                this._closePromises.forEach(p => p.resolve());\n                this._closePromises = [];\n            });\n        }\n    }\n\n    isActiveOrHolding()\n    {\n        return this._state > StateNotValidated && this._state < StateClosing;\n    }\n\n    isFinished()\n    {\n        if(this._state !== StateFinished || this._dispatchCount !== 0)\n        {\n            return false;\n        }\n\n        Debug.assert(this._state === StateFinished);\n        return true;\n    }\n\n    throwException()\n    {\n        if(this._exception !== null)\n        {\n            Debug.assert(this._state >= StateClosing);\n            throw this._exception;\n        }\n    }\n\n    waitUntilFinished()\n    {\n        const promise = new Ice.Promise();\n        this._finishedPromises.push(promise);\n        this.checkState();\n        return promise;\n    }\n\n    monitor(now, acm)\n    {\n        if(this._state !== StateActive)\n        {\n            return;\n        }\n\n        //\n        // We send a heartbeat if there was no activity in the last\n        // (timeout / 4) period. Sending a heartbeat sooner than\n        // really needed is safer to ensure that the receiver will\n        // receive the heartbeat in time. Sending the heartbeat if\n        // there was no activity in the last (timeout / 2) period\n        // isn't enough since monitor() is called only every (timeout\n        // / 2) period.\n        //\n        // Note that this doesn't imply that we are sending 4 heartbeats\n        // per timeout period because the monitor() method is still only\n        // called every (timeout / 2) period.\n        //\n        if(acm.heartbeat == Ice.ACMHeartbeat.HeartbeatAlways ||\n           (acm.heartbeat != Ice.ACMHeartbeat.HeartbeatOff && this._writeStream.isEmpty() &&\n            now >= (this._acmLastActivity + (acm.timeout / 4))))\n        {\n            if(acm.heartbeat != Ice.ACMHeartbeat.HeartbeatOnDispatch || this._dispatchCount > 0)\n            {\n                this.sendHeartbeatNow(); // Send heartbeat if idle in the last timeout / 2 period.\n            }\n        }\n\n        if(this._readStream.size > Protocol.headerSize || !this._writeStream.isEmpty())\n        {\n            //\n            // If writing or reading, nothing to do, the connection\n            // timeout will kick-in if writes or reads don't progress.\n            // This check is necessary because the actitivy timer is\n            // only set when a message is fully read/written.\n            //\n            return;\n        }\n\n        if(acm.close != Ice.ACMClose.CloseOff && now >= (this._acmLastActivity + acm.timeout))\n        {\n            if(acm.close == Ice.ACMClose.CloseOnIdleForceful ||\n               (acm.close != Ice.ACMClose.CloseOnIdle && this._asyncRequests.size > 0))\n            {\n                //\n                // Close the connection if we didn't receive a heartbeat in\n                // the last period.\n                //\n                this.setState(StateClosed, new Ice.ConnectionTimeoutException());\n            }\n            else if(acm.close != Ice.ACMClose.CloseOnInvocation &&\n                    this._dispatchCount === 0 && this._batchRequestQueue.isEmpty() && this._asyncRequests.size === 0)\n            {\n                //\n                // The connection is idle, close it.\n                //\n                this.setState(StateClosing, new Ice.ConnectionTimeoutException());\n            }\n        }\n    }\n\n    sendAsyncRequest(out, response, batchRequestNum)\n    {\n        let requestId = 0;\n        const ostr = out.getOs();\n\n        if(this._exception !== null)\n        {\n            //\n            // If the connection is closed before we even have a chance\n            // to send our request, we always try to send the request\n            // again.\n            //\n            throw new RetryException(this._exception);\n        }\n\n        Debug.assert(this._state > StateNotValidated);\n        Debug.assert(this._state < StateClosing);\n\n        //\n        // Ensure the message isn't bigger than what we can send with the\n        // transport.\n        //\n        this._transceiver.checkSendSize(ostr);\n\n        //\n        // Notify the request that it's cancelable with this connection.\n        // This will throw if the request is canceled.\n        //\n        out.cancelable(this); // Notify the request that it's cancelable\n\n        if(response)\n        {\n            //\n            // Create a new unique request ID.\n            //\n            requestId = this._nextRequestId++;\n            if(requestId <= 0)\n            {\n                this._nextRequestId = 1;\n                requestId = this._nextRequestId++;\n            }\n\n            //\n            // Fill in the request ID.\n            //\n            ostr.pos = Protocol.headerSize;\n            ostr.writeInt(requestId);\n        }\n        else if(batchRequestNum > 0)\n        {\n            ostr.pos = Protocol.headerSize;\n            ostr.writeInt(batchRequestNum);\n        }\n\n        let status;\n        try\n        {\n            status = this.sendMessage(OutgoingMessage.create(out, out.getOs(), requestId));\n        }\n        catch(ex)\n        {\n            if(ex instanceof Ice.LocalException)\n            {\n                this.setState(StateClosed, ex);\n                Debug.assert(this._exception !== null);\n                throw this._exception;\n            }\n            else\n            {\n                throw ex;\n            }\n        }\n\n        if(response)\n        {\n            //\n            // Add to the async requests map.\n            //\n            this._asyncRequests.set(requestId, out);\n        }\n\n        return status;\n    }\n\n    getBatchRequestQueue()\n    {\n        return this._batchRequestQueue;\n    }\n\n    flushBatchRequests()\n    {\n        const result = new ConnectionFlushBatch(this, this._communicator, \"flushBatchRequests\");\n        result.invoke();\n        return result;\n    }\n\n    setCloseCallback(callback)\n    {\n        if(this._state >= StateClosed)\n        {\n            if(callback !== null)\n            {\n                Timer.setImmediate(() =>\n                {\n                    try\n                    {\n                        callback(this);\n                    }\n                    catch(ex)\n                    {\n                        this._logger.error(\"connection callback exception:\\n\" + ex + '\\n' + this._desc);\n                    }\n                });\n            }\n        }\n        else\n        {\n            this._closeCallback = callback;\n        }\n    }\n\n    setHeartbeatCallback(callback)\n    {\n        if(this._state >= StateClosed)\n        {\n            return;\n        }\n        this._heartbeatCallback = callback;\n    }\n\n    heartbeat()\n    {\n        const result = new HeartbeatAsync(this, this._communicator);\n        result.invoke();\n        return result;\n    }\n\n    setACM(timeout, close, heartbeat)\n    {\n        if(timeout !== undefined && timeout < 0)\n        {\n            throw new RangeError(\"invalid negative ACM timeout value\");\n        }\n        if(this._monitor === null || this._state >= StateClosed)\n        {\n            return;\n        }\n\n        if(this._state == StateActive)\n        {\n            this._monitor.remove(this);\n        }\n        this._monitor = this._monitor.acm(timeout, close, heartbeat);\n        if(this._state == StateActive)\n        {\n            this._monitor.add(this);\n        }\n        if(this._monitor.getACM().timeout <= 0)\n        {\n            this._acmLastActivity = -1; // Disable the recording of last activity.\n        }\n        else if(this._state == StateActive && this._acmLastActivity == -1)\n        {\n            this._acmLastActivity = Date.now();\n        }\n    }\n\n    getACM()\n    {\n        return this._monitor !== null ? this._monitor.getACM() :\n            new ACM(0, ACMClose.CloseOff, ACMHeartbeat.HeartbeatOff);\n    }\n\n    asyncRequestCanceled(outAsync, ex)\n    {\n        for(let i = 0; i < this._sendStreams.length; i++)\n        {\n            const o = this._sendStreams[i];\n            if(o.outAsync === outAsync)\n            {\n                if(o.requestId > 0)\n                {\n                    this._asyncRequests.delete(o.requestId);\n                }\n\n                //\n                // If the request is being sent, don't remove it from the send streams,\n                // it will be removed once the sending is finished.\n                //\n                o.canceled();\n                if(i !== 0)\n                {\n                    this._sendStreams.splice(i, 1);\n                }\n                outAsync.completedEx(ex);\n                this.checkClose();\n                return; // We're done.\n            }\n        }\n\n        if(outAsync instanceof Ice.OutgoingAsync)\n        {\n            for(const [key, value] of this._asyncRequests)\n            {\n                if(value === outAsync)\n                {\n                    this._asyncRequests.delete(key);\n                    outAsync.completedEx(ex);\n                    this.checkClose();\n                    return; // We're done.\n                }\n            }\n        }\n    }\n\n    sendResponse(os)\n    {\n        Debug.assert(this._state > StateNotValidated);\n\n        try\n        {\n            if(--this._dispatchCount === 0)\n            {\n                if(this._state === StateFinished)\n                {\n                    this.reap();\n                }\n                this.checkState();\n            }\n\n            if(this._state >= StateClosed)\n            {\n                Debug.assert(this._exception !== null);\n                throw this._exception;\n            }\n\n            this.sendMessage(OutgoingMessage.createForStream(os, true));\n\n            if(this._state === StateClosing && this._dispatchCount === 0)\n            {\n                this.initiateShutdown();\n            }\n        }\n        catch(ex)\n        {\n            if(ex instanceof Ice.LocalException)\n            {\n                this.setState(StateClosed, ex);\n            }\n            else\n            {\n                throw ex;\n            }\n        }\n    }\n\n    sendNoResponse()\n    {\n        Debug.assert(this._state > StateNotValidated);\n        try\n        {\n            if(--this._dispatchCount === 0)\n            {\n                if(this._state === StateFinished)\n                {\n                    this.reap();\n                }\n                this.checkState();\n            }\n\n            if(this._state >= StateClosed)\n            {\n                Debug.assert(this._exception !== null);\n                throw this._exception;\n            }\n\n            if(this._state === StateClosing && this._dispatchCount === 0)\n            {\n                this.initiateShutdown();\n            }\n        }\n        catch(ex)\n        {\n            if(ex instanceof Ice.LocalException)\n            {\n                this.setState(StateClosed, ex);\n            }\n            else\n            {\n                throw ex;\n            }\n        }\n    }\n\n    endpoint()\n    {\n        return this._endpoint;\n    }\n\n    setAdapter(adapter)\n    {\n        if(adapter !== null)\n        {\n            adapter.checkForDeactivation();\n            if(this._state <= StateNotValidated || this._state >= StateClosing)\n            {\n                return;\n            }\n            this._adapter = adapter;\n            this._servantManager = adapter.getServantManager(); // The OA's servant manager is immutable.\n        }\n        else\n        {\n            if(this._state <= StateNotValidated || this._state >= StateClosing)\n            {\n                return;\n            }\n            this._adapter = null;\n            this._servantManager = null;\n        }\n    }\n\n    getAdapter()\n    {\n        return this._adapter;\n    }\n\n    getEndpoint()\n    {\n        return this._endpoint;\n    }\n\n    createProxy(ident)\n    {\n        //\n        // Create a reference and return a reverse proxy for this\n        // reference.\n        //\n        return this._instance.proxyFactory().referenceToProxy(\n            this._instance.referenceFactory().createFixed(ident, this));\n    }\n\n    message(operation)\n    {\n        if(this._state >= StateClosed)\n        {\n            return;\n        }\n\n        this.unscheduleTimeout(operation);\n\n        //\n        // Keep reading until no more data is available.\n        //\n        this._hasMoreData.value = (operation & SocketOperation.Read) !== 0;\n\n        let info = null;\n        try\n        {\n            if((operation & SocketOperation.Write) !== 0 && this._writeStream.buffer.remaining > 0)\n            {\n                if(!this.write(this._writeStream.buffer))\n                {\n                    Debug.assert(!this._writeStream.isEmpty());\n                    this.scheduleTimeout(SocketOperation.Write);\n                    return;\n                }\n                Debug.assert(this._writeStream.buffer.remaining === 0);\n            }\n            if((operation & SocketOperation.Read) !== 0 && !this._readStream.isEmpty())\n            {\n                if(this._readHeader) // Read header if necessary.\n                {\n                    if(!this.read(this._readStream.buffer))\n                    {\n                        //\n                        // We didn't get enough data to complete the header.\n                        //\n                        return;\n                    }\n\n                    Debug.assert(this._readStream.buffer.remaining === 0);\n                    this._readHeader = false;\n\n                    //\n                    // Connection is validated on first message. This is only used by\n                    // setState() to check wether or not we can print a connection\n                    // warning (a client might close the connection forcefully if the\n                    // connection isn't validated, we don't want to print a warning\n                    // in this case).\n                    //\n                    this._validated = true;\n\n                    const pos = this._readStream.pos;\n                    if(pos < Protocol.headerSize)\n                    {\n                        //\n                        // This situation is possible for small UDP packets.\n                        //\n                        throw new Ice.IllegalMessageSizeException();\n                    }\n\n                    this._readStream.pos = 0;\n                    const magic0 = this._readStream.readByte();\n                    const magic1 = this._readStream.readByte();\n                    const magic2 = this._readStream.readByte();\n                    const magic3 = this._readStream.readByte();\n                    if(magic0 !== Protocol.magic[0] || magic1 !== Protocol.magic[1] ||\n                       magic2 !== Protocol.magic[2] || magic3 !== Protocol.magic[3])\n                    {\n                        throw new Ice.BadMagicException(\"\", new Uint8Array([magic0, magic1, magic2, magic3]));\n                    }\n\n                    this._readProtocol._read(this._readStream);\n                    Protocol.checkSupportedProtocol(this._readProtocol);\n\n                    this._readProtocolEncoding._read(this._readStream);\n                    Protocol.checkSupportedProtocolEncoding(this._readProtocolEncoding);\n\n                    this._readStream.readByte(); // messageType\n                    this._readStream.readByte(); // compress\n                    const size = this._readStream.readInt();\n                    if(size < Protocol.headerSize)\n                    {\n                        throw new Ice.IllegalMessageSizeException();\n                    }\n\n                    if(size > this._messageSizeMax)\n                    {\n                        ExUtil.throwMemoryLimitException(size, this._messageSizeMax);\n                    }\n                    if(size > this._readStream.size)\n                    {\n                        this._readStream.resize(size);\n                    }\n                    this._readStream.pos = pos;\n                }\n\n                if(this._readStream.pos != this._readStream.size)\n                {\n                    if(this._endpoint.datagram())\n                    {\n                        throw new Ice.DatagramLimitException(); // The message was truncated.\n                    }\n                    else\n                    {\n                        if(!this.read(this._readStream.buffer))\n                        {\n                            Debug.assert(!this._readStream.isEmpty());\n                            this.scheduleTimeout(SocketOperation.Read);\n                            return;\n                        }\n                        Debug.assert(this._readStream.buffer.remaining === 0);\n                    }\n                }\n            }\n\n            if(this._state <= StateNotValidated)\n            {\n                if(this._state === StateNotInitialized && !this.initialize())\n                {\n                    return;\n                }\n\n                if(this._state <= StateNotValidated && !this.validate())\n                {\n                    return;\n                }\n\n                this._transceiver.unregister();\n\n                //\n                // We start out in holding state.\n                //\n                this.setState(StateHolding);\n                if(this._startPromise !== null)\n                {\n                    ++this._dispatchCount;\n                }\n            }\n            else\n            {\n                Debug.assert(this._state <= StateClosing);\n\n                //\n                // We parse messages first, if we receive a close\n                // connection message we won't send more messages.\n                //\n                if((operation & SocketOperation.Read) !== 0)\n                {\n                    info = this.parseMessage();\n                }\n\n                if((operation & SocketOperation.Write) !== 0)\n                {\n                    this.sendNextMessage();\n                }\n            }\n        }\n        catch(ex)\n        {\n            if(ex instanceof Ice.DatagramLimitException) // Expected.\n            {\n                if(this._warnUdp)\n                {\n                    this._logger.warning(\"maximum datagram size of \" + this._readStream.pos + \" exceeded\");\n                }\n                this._readStream.resize(Protocol.headerSize);\n                this._readStream.pos = 0;\n                this._readHeader = true;\n                return;\n            }\n            else if(ex instanceof Ice.SocketException)\n            {\n                this.setState(StateClosed, ex);\n                return;\n            }\n            else if(ex instanceof Ice.LocalException)\n            {\n                if(this._endpoint.datagram())\n                {\n                    if(this._warn)\n                    {\n                        this._logger.warning(\"datagram connection exception:\\n\" + ex + '\\n' + this._desc);\n                    }\n                    this._readStream.resize(Protocol.headerSize);\n                    this._readStream.pos = 0;\n                    this._readHeader = true;\n                }\n                else\n                {\n                    this.setState(StateClosed, ex);\n                }\n                return;\n            }\n            else\n            {\n                throw ex;\n            }\n        }\n\n        if(this._acmLastActivity > 0)\n        {\n            this._acmLastActivity = Date.now();\n        }\n\n        this.dispatch(info);\n\n        if(this._hasMoreData.value)\n        {\n            Timer.setImmediate(() => this.message(SocketOperation.Read)); // Don't tie up the thread.\n        }\n    }\n\n    dispatch(info)\n    {\n        let count = 0;\n        //\n        // Notify the factory that the connection establishment and\n        // validation has completed.\n        //\n        if(this._startPromise !== null)\n        {\n            this._startPromise.resolve();\n\n            this._startPromise = null;\n            ++count;\n        }\n\n        if(info !== null)\n        {\n            if(info.outAsync !== null)\n            {\n                info.outAsync.completed(info.stream);\n                ++count;\n            }\n\n            if(info.invokeNum > 0)\n            {\n                this.invokeAll(info.stream, info.invokeNum, info.requestId, info.servantManager, info.adapter);\n\n                //\n                // Don't increase count, the dispatch count is\n                // decreased when the incoming reply is sent.\n                //\n            }\n\n            if(info.heartbeatCallback)\n            {\n                try\n                {\n                    info.heartbeatCallback(this);\n                }\n                catch(ex)\n                {\n                    this._logger.error(\"connection callback exception:\\n\" + ex + '\\n' + this._desc);\n                }\n                info.heartbeatCallback = null;\n                ++count;\n            }\n        }\n\n        //\n        // Decrease dispatch count.\n        //\n        if(count > 0)\n        {\n            this._dispatchCount -= count;\n            if(this._dispatchCount === 0)\n            {\n                if(this._state === StateClosing)\n                {\n                    try\n                    {\n                        this.initiateShutdown();\n                    }\n                    catch(ex)\n                    {\n                        if(ex instanceof Ice.LocalException)\n                        {\n                            this.setState(StateClosed, ex);\n                        }\n                        else\n                        {\n                            throw ex;\n                        }\n                    }\n                }\n                else if(this._state === StateFinished)\n                {\n                    this.reap();\n                }\n                this.checkState();\n            }\n        }\n    }\n\n    finish()\n    {\n        Debug.assert(this._state === StateClosed);\n        this.unscheduleTimeout(SocketOperation.Read | SocketOperation.Write | SocketOperation.Connect);\n\n        const traceLevels = this._instance.traceLevels();\n        if(!this._initialized)\n        {\n            if(traceLevels.network >= 2)\n            {\n                const s = [];\n                s.push(\"failed to establish \");\n                s.push(this._endpoint.protocol());\n                s.push(\" connection\\n\");\n                s.push(this.toString());\n                s.push(\"\\n\");\n                s.push(this._exception.toString());\n                this._instance.initializationData().logger.trace(traceLevels.networkCat, s.join(\"\"));\n            }\n        }\n        else if(traceLevels.network >= 1)\n        {\n            const s = [];\n            s.push(\"closed \");\n            s.push(this._endpoint.protocol());\n            s.push(\" connection\\n\");\n            s.push(this.toString());\n\n            //\n            // Trace the cause of unexpected connection closures\n            //\n            if(!(this._exception instanceof Ice.CloseConnectionException ||\n                 this._exception instanceof Ice.ConnectionManuallyClosedException ||\n                 this._exception instanceof Ice.ConnectionTimeoutException ||\n                 this._exception instanceof Ice.CommunicatorDestroyedException ||\n                 this._exception instanceof Ice.ObjectAdapterDeactivatedException))\n            {\n                s.push(\"\\n\");\n                s.push(this._exception.toString());\n            }\n\n            this._instance.initializationData().logger.trace(traceLevels.networkCat, s.join(\"\"));\n        }\n\n        if(this._startPromise !== null)\n        {\n            this._startPromise.reject(this._exception);\n            this._startPromise = null;\n        }\n\n        if(this._sendStreams.length > 0)\n        {\n            if(!this._writeStream.isEmpty())\n            {\n                //\n                // Return the stream to the outgoing call. This is important for\n                // retriable AMI calls which are not marshalled again.\n                //\n                this._writeStream.swap(this._sendStreams[0].stream);\n            }\n\n            //\n            // NOTE: for twoway requests which are not sent, finished can be called twice: the\n            // first time because the outgoing is in the _sendStreams set and the second time\n            // because it's either in the _requests/_asyncRequests set. This is fine, only the\n            // first call should be taken into account by the implementation of finished.\n            //\n            for(let i = 0; i < this._sendStreams.length; ++i)\n            {\n                const p = this._sendStreams[i];\n                if(p.requestId > 0)\n                {\n                    this._asyncRequests.delete(p.requestId);\n                }\n                p.completed(this._exception);\n            }\n            this._sendStreams = [];\n        }\n\n        for(const value of this._asyncRequests.values())\n        {\n            value.completedEx(this._exception);\n        }\n        this._asyncRequests.clear();\n        this.checkClose();\n\n        //\n        // Don't wait to be reaped to reclaim memory allocated by read/write streams.\n        //\n        this._readStream.clear();\n        this._readStream.buffer.clear();\n        this._writeStream.clear();\n        this._writeStream.buffer.clear();\n\n        if(this._closeCallback !== null)\n        {\n            try\n            {\n                this._closeCallback(this);\n            }\n            catch(ex)\n            {\n                this._logger.error(\"connection callback exception:\\n\" + ex + '\\n' + this._desc);\n            }\n            this._closeCallback = null;\n        }\n\n        this._heartbeatCallback = null;\n\n        //\n        // This must be done last as this will cause waitUntilFinished() to return (and communicator\n        // objects such as the timer might be destroyed too).\n        //\n        if(this._dispatchCount === 0)\n        {\n            this.reap();\n        }\n        this.setState(StateFinished);\n    }\n\n    toString()\n    {\n        return this._desc;\n    }\n\n    timedOut(event)\n    {\n        if(this._state <= StateNotValidated)\n        {\n            this.setState(StateClosed, new Ice.ConnectTimeoutException());\n        }\n        else if(this._state < StateClosing)\n        {\n            this.setState(StateClosed, new Ice.TimeoutException());\n        }\n        else if(this._state === StateClosing)\n        {\n            this.setState(StateClosed, new Ice.CloseTimeoutException());\n        }\n    }\n\n    type()\n    {\n        return this._type;\n    }\n\n    timeout()\n    {\n        return this._endpoint.timeout();\n    }\n\n    getInfo()\n    {\n        if(this._state >= StateClosed)\n        {\n            throw this._exception;\n        }\n        const info = this._transceiver.getInfo();\n        for(let p = info; p !== null; p = p.underlying)\n        {\n            p.adapterName = this._adapter !== null ? this._adapter.getName() : \"\";\n            p.incoming = this._incoming;\n        }\n        return info;\n    }\n\n    setBufferSize(rcvSize, sndSize)\n    {\n        if(this._state >= StateClosed)\n        {\n            throw this._exception;\n        }\n        this._transceiver.setBufferSize(rcvSize, sndSize);\n    }\n\n    exception(ex)\n    {\n        this.setState(StateClosed, ex);\n    }\n\n    invokeException(ex, invokeNum)\n    {\n        //\n        // Fatal exception while invoking a request. Since sendResponse/sendNoResponse isn't\n        // called in case of a fatal exception we decrement this._dispatchCount here.\n        //\n\n        this.setState(StateClosed, ex);\n\n        if(invokeNum > 0)\n        {\n            Debug.assert(this._dispatchCount > 0);\n            this._dispatchCount -= invokeNum;\n            Debug.assert(this._dispatchCount >= 0);\n            if(this._dispatchCount === 0)\n            {\n                if(this._state === StateFinished)\n                {\n                    this.reap();\n                }\n                this.checkState();\n            }\n        }\n    }\n\n    setState(state, ex)\n    {\n        if(ex !== undefined)\n        {\n            Debug.assert(ex instanceof Ice.LocalException);\n\n            //\n            // If setState() is called with an exception, then only closed\n            // and closing states are permissible.\n            //\n            Debug.assert(state >= StateClosing);\n\n            if(this._state === state) // Don't switch twice.\n            {\n                return;\n            }\n\n            if(this._exception === null)\n            {\n                this._exception = ex;\n\n                //\n                // We don't warn if we are not validated.\n                //\n                if(this._warn && this._validated)\n                {\n                    //\n                    // Don't warn about certain expected exceptions.\n                    //\n                    if(!(this._exception instanceof Ice.CloseConnectionException ||\n                         this._exception instanceof Ice.ConnectionManuallyClosedException ||\n                         this._exception instanceof Ice.ConnectionTimeoutException ||\n                         this._exception instanceof Ice.CommunicatorDestroyedException ||\n                         this._exception instanceof Ice.ObjectAdapterDeactivatedException ||\n                         (this._exception instanceof Ice.ConnectionLostException && this._state === StateClosing)))\n                    {\n                        this.warning(\"connection exception\", this._exception);\n                    }\n                }\n            }\n\n            //\n            // We must set the new state before we notify requests of any\n            // exceptions. Otherwise new requests may retry on a\n            // connection that is not yet marked as closed or closing.\n            //\n        }\n\n        //\n        // We don't want to send close connection messages if the endpoint\n        // only supports oneway transmission from client to server.\n        //\n        if(this._endpoint.datagram() && state === StateClosing)\n        {\n            state = StateClosed;\n        }\n\n        //\n        // Skip graceful shutdown if we are destroyed before validation.\n        //\n        if(this._state <= StateNotValidated && state === StateClosing)\n        {\n            state = StateClosed;\n        }\n\n        if(this._state === state) // Don't switch twice.\n        {\n            return;\n        }\n\n        try\n        {\n            switch(state)\n            {\n                case StateNotInitialized:\n                {\n                    Debug.assert(false);\n                    break;\n                }\n\n                case StateNotValidated:\n                {\n                    if(this._state !== StateNotInitialized)\n                    {\n                        Debug.assert(this._state === StateClosed);\n                        return;\n                    }\n                    //\n                    // Register to receive validation message.\n                    //\n                    if(!this._endpoint.datagram() && !this._incoming)\n                    {\n                        //\n                        // Once validation is complete, a new connection starts out in the\n                        // Holding state. We only want to register the transceiver now if we\n                        // need to receive data in order to validate the connection.\n                        //\n                        this._transceiver.register();\n                    }\n                    break;\n                }\n\n                case StateActive:\n                {\n                    //\n                    // Can only switch from holding or not validated to\n                    // active.\n                    //\n                    if(this._state !== StateHolding && this._state !== StateNotValidated)\n                    {\n                        return;\n                    }\n                    this._transceiver.register();\n                    break;\n                }\n\n                case StateHolding:\n                {\n                    //\n                    // Can only switch from active or not validated to\n                    // holding.\n                    //\n                    if(this._state !== StateActive && this._state !== StateNotValidated)\n                    {\n                        return;\n                    }\n                    if(this._state === StateActive)\n                    {\n                        this._transceiver.unregister();\n                    }\n                    break;\n                }\n\n                case StateClosing:\n                {\n                    //\n                    // Can't change back from closed.\n                    //\n                    if(this._state >= StateClosed)\n                    {\n                        return;\n                    }\n                    if(this._state === StateHolding)\n                    {\n                        // We need to continue to read in closing state.\n                        this._transceiver.register();\n                    }\n                    break;\n                }\n\n                case StateClosed:\n                {\n                    if(this._state === StateFinished)\n                    {\n                        return;\n                    }\n                    this._batchRequestQueue.destroy(this._exception);\n                    this._transceiver.unregister();\n                    break;\n                }\n\n                case StateFinished:\n                {\n                    Debug.assert(this._state === StateClosed);\n                    this._transceiver.close();\n                    this._communicator = null;\n                    break;\n                }\n\n                default:\n                {\n                    Debug.assert(false);\n                    break;\n                }\n            }\n        }\n        catch(ex)\n        {\n            if(ex instanceof Ice.LocalException)\n            {\n                this._instance.initializationData().logger.error(\n                    `unexpected connection exception:\\n${this._desc}\\n${ex.toString()}`);\n            }\n            else\n            {\n                throw ex;\n            }\n        }\n\n        //\n        // We only register with the connection monitor if our new state\n        // is StateActive. Otherwise we unregister with the connection\n        // monitor, but only if we were registered before, i.e., if our\n        // old state was StateActive.\n        //\n        if(this._monitor !== null)\n        {\n            if(state === StateActive)\n            {\n                this._monitor.add(this);\n                if(this._acmLastActivity > 0)\n                {\n                    this._acmLastActivity = Date.now();\n                }\n            }\n            else if(this._state === StateActive)\n            {\n                this._monitor.remove(this);\n            }\n        }\n\n        this._state = state;\n\n        if(this._state === StateClosing && this._dispatchCount === 0)\n        {\n            try\n            {\n                this.initiateShutdown();\n            }\n            catch(ex)\n            {\n                if(ex instanceof Ice.LocalException)\n                {\n                    this.setState(StateClosed, ex);\n                }\n                else\n                {\n                    throw ex;\n                }\n            }\n        }\n        else if(this._state === StateClosed)\n        {\n            this.finish();\n        }\n\n        this.checkState();\n    }\n\n    initiateShutdown()\n    {\n        Debug.assert(this._state === StateClosing && this._dispatchCount === 0);\n\n        if(this._shutdownInitiated)\n        {\n            return;\n        }\n        this._shutdownInitiated = true;\n\n        if(!this._endpoint.datagram())\n        {\n            //\n            // Before we shut down, we send a close connection message.\n            //\n            const os = new OutputStream(this._instance, Protocol.currentProtocolEncoding);\n            os.writeBlob(Protocol.magic);\n            Protocol.currentProtocol._write(os);\n            Protocol.currentProtocolEncoding._write(os);\n            os.writeByte(Protocol.closeConnectionMsg);\n            os.writeByte(0); // compression status: always report 0 for CloseConnection.\n            os.writeInt(Protocol.headerSize); // Message size.\n\n            if((this.sendMessage(OutgoingMessage.createForStream(os, false)) & AsyncStatus.Sent) > 0)\n            {\n                //\n                // Schedule the close timeout to wait for the peer to close the connection.\n                //\n                this.scheduleTimeout(SocketOperation.Read);\n            }\n        }\n    }\n\n    sendHeartbeatNow()\n    {\n        Debug.assert(this._state === StateActive);\n\n        if(!this._endpoint.datagram())\n        {\n            const os = new OutputStream(this._instance, Protocol.currentProtocolEncoding);\n            os.writeBlob(Protocol.magic);\n            Protocol.currentProtocol._write(os);\n            Protocol.currentProtocolEncoding._write(os);\n            os.writeByte(Protocol.validateConnectionMsg);\n            os.writeByte(0);\n            os.writeInt(Protocol.headerSize); // Message size.\n            try\n            {\n                this.sendMessage(OutgoingMessage.createForStream(os, false));\n            }\n            catch(ex)\n            {\n                this.setState(StateClosed, ex);\n                Debug.assert(this._exception !== null);\n            }\n        }\n    }\n\n    initialize()\n    {\n        const s = this._transceiver.initialize(this._readStream.buffer, this._writeStream.buffer);\n        if(s != SocketOperation.None)\n        {\n            this.scheduleTimeout(s);\n            return false;\n        }\n\n        //\n        // Update the connection description once the transceiver is initialized.\n        //\n        this._desc = this._transceiver.toString();\n        this._initialized = true;\n        this.setState(StateNotValidated);\n        return true;\n    }\n\n    validate()\n    {\n        if(!this._endpoint.datagram()) // Datagram connections are always implicitly validated.\n        {\n            if(this._adapter !== null) // The server side has the active role for connection validation.\n            {\n                if(this._writeStream.size === 0)\n                {\n                    this._writeStream.writeBlob(Protocol.magic);\n                    Protocol.currentProtocol._write(this._writeStream);\n                    Protocol.currentProtocolEncoding._write(this._writeStream);\n                    this._writeStream.writeByte(Protocol.validateConnectionMsg);\n                    this._writeStream.writeByte(0); // Compression status (always zero for validate connection).\n                    this._writeStream.writeInt(Protocol.headerSize); // Message size.\n                    TraceUtil.traceSend(this._writeStream, this._logger, this._traceLevels);\n                    this._writeStream.prepareWrite();\n                }\n\n                if(this._writeStream.pos != this._writeStream.size && !this.write(this._writeStream.buffer))\n                {\n                    this.scheduleTimeout(SocketOperation.Write);\n                    return false;\n                }\n            }\n            else // The client side has the passive role for connection validation.\n            {\n                if(this._readStream.size === 0)\n                {\n                    this._readStream.resize(Protocol.headerSize);\n                    this._readStream.pos = 0;\n                }\n\n                if(this._readStream.pos !== this._readStream.size &&\n                    !this.read(this._readStream.buffer))\n                {\n                    this.scheduleTimeout(SocketOperation.Read);\n                    return false;\n                }\n\n                this._validated = true;\n\n                Debug.assert(this._readStream.pos === Protocol.headerSize);\n                this._readStream.pos = 0;\n                const m = this._readStream.readBlob(4);\n                if(m[0] !== Protocol.magic[0] || m[1] !== Protocol.magic[1] ||\n                    m[2] !== Protocol.magic[2] || m[3] !== Protocol.magic[3])\n                {\n                    throw new Ice.BadMagicException(\"\", m);\n                }\n\n                this._readProtocol._read(this._readStream);\n                Protocol.checkSupportedProtocol(this._readProtocol);\n\n                this._readProtocolEncoding._read(this._readStream);\n                Protocol.checkSupportedProtocolEncoding(this._readProtocolEncoding);\n\n                const messageType = this._readStream.readByte();\n                if(messageType !== Protocol.validateConnectionMsg)\n                {\n                    throw new Ice.ConnectionNotValidatedException();\n                }\n                this._readStream.readByte(); // Ignore compression status for validate connection.\n                if(this._readStream.readInt() !== Protocol.headerSize)\n                {\n                    throw new Ice.IllegalMessageSizeException();\n                }\n                TraceUtil.traceRecv(this._readStream, this._logger, this._traceLevels);\n            }\n        }\n\n        this._writeStream.resize(0);\n        this._writeStream.pos = 0;\n\n        this._readStream.resize(Protocol.headerSize);\n        this._readHeader = true;\n        this._readStream.pos = 0;\n\n        const traceLevels = this._instance.traceLevels();\n        if(traceLevels.network >= 1)\n        {\n            const s = [];\n            if(this._endpoint.datagram())\n            {\n                s.push(\"starting to send \");\n                s.push(this._endpoint.protocol());\n                s.push(\" messages\\n\");\n                s.push(this._transceiver.toDetailedString());\n            }\n            else\n            {\n                s.push(\"established \");\n                s.push(this._endpoint.protocol());\n                s.push(\" connection\\n\");\n                s.push(this.toString());\n            }\n            this._instance.initializationData().logger.trace(traceLevels.networkCat, s.join(\"\"));\n        }\n\n        return true;\n    }\n\n    sendNextMessage()\n    {\n        if(this._sendStreams.length === 0)\n        {\n            return;\n        }\n\n        Debug.assert(!this._writeStream.isEmpty() && this._writeStream.pos === this._writeStream.size);\n        try\n        {\n            while(true)\n            {\n                //\n                // Notify the message that it was sent.\n                //\n                let message = this._sendStreams.shift();\n                this._writeStream.swap(message.stream);\n                message.sent();\n\n                //\n                // If there's nothing left to send, we're done.\n                //\n                if(this._sendStreams.length === 0)\n                {\n                    break;\n                }\n\n                //\n                // If we are in the closed state, don't continue sending.\n                //\n                // The connection can be in the closed state if parseMessage\n                // (called before sendNextMessage by message()) closes the\n                // connection.\n                //\n                if(this._state >= StateClosed)\n                {\n                    return;\n                }\n\n                //\n                // Otherwise, prepare the next message stream for writing.\n                //\n                message = this._sendStreams[0];\n                Debug.assert(!message.prepared);\n\n                const stream = message.stream;\n                stream.pos = 10;\n                stream.writeInt(stream.size);\n                stream.prepareWrite();\n                message.prepared = true;\n\n                TraceUtil.traceSend(stream, this._logger, this._traceLevels);\n\n                this._writeStream.swap(message.stream);\n\n                //\n                // Send the message.\n                //\n                if(this._writeStream.pos != this._writeStream.size && !this.write(this._writeStream.buffer))\n                {\n                    Debug.assert(!this._writeStream.isEmpty());\n                    this.scheduleTimeout(SocketOperation.Write);\n                    return;\n                }\n            }\n        }\n        catch(ex)\n        {\n            if(ex instanceof Ice.LocalException)\n            {\n                this.setState(StateClosed, ex);\n                return;\n            }\n            else\n            {\n                throw ex;\n            }\n        }\n\n        Debug.assert(this._writeStream.isEmpty());\n\n        //\n        // If all the messages were sent and we are in the closing state, we schedule\n        // the close timeout to wait for the peer to close the connection.\n        //\n        if(this._state === StateClosing && this._shutdownInitiated)\n        {\n            this.scheduleTimeout(SocketOperation.Read);\n        }\n    }\n\n    sendMessage(message)\n    {\n        if(this._sendStreams.length > 0)\n        {\n            message.doAdopt();\n            this._sendStreams.push(message);\n            return AsyncStatus.Queued;\n        }\n        Debug.assert(this._state < StateClosed);\n\n        Debug.assert(!message.prepared);\n\n        const stream = message.stream;\n        stream.pos = 10;\n        stream.writeInt(stream.size);\n        stream.prepareWrite();\n        message.prepared = true;\n\n        TraceUtil.traceSend(stream, this._logger, this._traceLevels);\n\n        if(this.write(stream.buffer))\n        {\n            //\n            // Entire buffer was written immediately.\n            //\n            message.sent();\n\n            if(this._acmLastActivity > 0)\n            {\n                this._acmLastActivity = Date.now();\n            }\n            return AsyncStatus.Sent;\n        }\n\n        message.doAdopt();\n\n        this._writeStream.swap(message.stream);\n        this._sendStreams.push(message);\n        this.scheduleTimeout(SocketOperation.Write);\n\n        return AsyncStatus.Queued;\n    }\n\n    parseMessage()\n    {\n        Debug.assert(this._state > StateNotValidated && this._state < StateClosed);\n\n        let info = new MessageInfo(this._instance);\n\n        this._readStream.swap(info.stream);\n        this._readStream.resize(Protocol.headerSize);\n        this._readStream.pos = 0;\n        this._readHeader = true;\n\n        Debug.assert(info.stream.pos === info.stream.size);\n\n        try\n        {\n            //\n            // We don't need to check magic and version here. This has already\n            // been done by the caller.\n            //\n            info.stream.pos = 8;\n            const messageType = info.stream.readByte();\n            const compress = info.stream.readByte();\n            if(compress === 2)\n            {\n                throw new Ice.FeatureNotSupportedException(\"Cannot uncompress compressed message\");\n            }\n            info.stream.pos = Protocol.headerSize;\n\n            switch(messageType)\n            {\n                case Protocol.closeConnectionMsg:\n                {\n                    TraceUtil.traceRecv(info.stream, this._logger, this._traceLevels);\n                    if(this._endpoint.datagram())\n                    {\n                        if(this._warn)\n                        {\n                            this._logger.warning(\"ignoring close connection message for datagram connection:\\n\" +\n                                                this._desc);\n                        }\n                    }\n                    else\n                    {\n                        this.setState(StateClosed, new Ice.CloseConnectionException());\n                    }\n                    break;\n                }\n\n                case Protocol.requestMsg:\n                {\n                    if(this._state === StateClosing)\n                    {\n                        TraceUtil.traceIn(\"received request during closing\\n\" +\n                                          \"(ignored by server, client will retry)\",\n                                          info.stream, this._logger, this._traceLevels);\n                    }\n                    else\n                    {\n                        TraceUtil.traceRecv(info.stream, this._logger, this._traceLevels);\n                        info.requestId = info.stream.readInt();\n                        info.invokeNum = 1;\n                        info.servantManager = this._servantManager;\n                        info.adapter = this._adapter;\n                        ++this._dispatchCount;\n                    }\n                    break;\n                }\n\n                case Protocol.requestBatchMsg:\n                {\n                    if(this._state === StateClosing)\n                    {\n                        TraceUtil.traceIn(\"received batch request during closing\\n\" +\n                                          \"(ignored by server, client will retry)\",\n                                          info.stream, this._logger, this._traceLevels);\n                    }\n                    else\n                    {\n                        TraceUtil.traceRecv(info.stream, this._logger, this._traceLevels);\n                        info.invokeNum = info.stream.readInt();\n                        if(info.invokeNum < 0)\n                        {\n                            info.invokeNum = 0;\n                            throw new Ice.UnmarshalOutOfBoundsException();\n                        }\n                        info.servantManager = this._servantManager;\n                        info.adapter = this._adapter;\n                        this._dispatchCount += info.invokeNum;\n                    }\n                    break;\n                }\n\n                case Protocol.replyMsg:\n                {\n                    TraceUtil.traceRecv(info.stream, this._logger, this._traceLevels);\n                    info.requestId = info.stream.readInt();\n                    info.outAsync = this._asyncRequests.get(info.requestId);\n                    if(info.outAsync)\n                    {\n                        this._asyncRequests.delete(info.requestId);\n                        ++this._dispatchCount;\n                    }\n                    else\n                    {\n                        info = null;\n                    }\n                    this.checkClose();\n                    break;\n                }\n\n                case Protocol.validateConnectionMsg:\n                {\n                    TraceUtil.traceRecv(info.stream, this._logger, this._traceLevels);\n                    if(this._heartbeatCallback !== null)\n                    {\n                        info.heartbeatCallback = this._heartbeatCallback;\n                        ++this._dispatchCount;\n                    }\n                    break;\n                }\n\n                default:\n                {\n                    TraceUtil.traceIn(\"received unknown message\\n(invalid, closing connection)\",\n                                      info.stream, this._logger, this._traceLevels);\n                    throw new Ice.UnknownMessageException();\n                }\n            }\n        }\n        catch(ex)\n        {\n            if(ex instanceof Ice.LocalException)\n            {\n                if(this._endpoint.datagram())\n                {\n                    if(this._warn)\n                    {\n                        this._logger.warning(\"datagram connection exception:\\n\" + ex + '\\n' + this._desc);\n                    }\n                }\n                else\n                {\n                    this.setState(StateClosed, ex);\n                }\n            }\n            else\n            {\n                throw ex;\n            }\n        }\n\n        return info;\n    }\n\n    invokeAll(stream, invokeNum, requestId, servantManager, adapter)\n    {\n        try\n        {\n            while(invokeNum > 0)\n            {\n                //\n                // Prepare the invocation.\n                //\n                const inc = new IncomingAsync(this._instance, this,\n                                              adapter,\n                                              !this._endpoint.datagram() && requestId !== 0, // response\n                                              requestId);\n\n                //\n                // Dispatch the invocation.\n                //\n                inc.invoke(servantManager, stream);\n\n                --invokeNum;\n            }\n\n            stream.clear();\n        }\n        catch(ex)\n        {\n            if(ex instanceof Ice.LocalException)\n            {\n                this.invokeException(ex, invokeNum);\n            }\n            else\n            {\n                //\n                // An Error was raised outside of servant code (i.e., by Ice code).\n                // Attempt to log the error and clean up.\n                //\n                this._logger.error(\"unexpected exception:\\n\" + ex.toString());\n                this.invokeException(new Ice.UnknownException(ex), invokeNum);\n            }\n        }\n    }\n\n    scheduleTimeout(op)\n    {\n        let timeout;\n        if(this._state < StateActive)\n        {\n            const defaultsAndOverrides = this._instance.defaultsAndOverrides();\n            if(defaultsAndOverrides.overrideConnectTimeout)\n            {\n                timeout = defaultsAndOverrides.overrideConnectTimeoutValue;\n            }\n            else\n            {\n                timeout = this._endpoint.timeout();\n            }\n        }\n        else if(this._state < StateClosing)\n        {\n            if(this._readHeader) // No timeout for reading the header.\n            {\n                op &= ~SocketOperation.Read;\n            }\n            timeout = this._endpoint.timeout();\n        }\n        else\n        {\n            const defaultsAndOverrides = this._instance.defaultsAndOverrides();\n            if(defaultsAndOverrides.overrideCloseTimeout)\n            {\n                timeout = defaultsAndOverrides.overrideCloseTimeoutValue;\n            }\n            else\n            {\n                timeout = this._endpoint.timeout();\n            }\n        }\n\n        if(timeout < 0)\n        {\n            return;\n        }\n\n        if((op & SocketOperation.Read) !== 0)\n        {\n            if(this._readTimeoutScheduled)\n            {\n                this._timer.cancel(this._readTimeoutId);\n            }\n            this._readTimeoutId = this._timer.schedule(() => this.timedOut(), timeout);\n            this._readTimeoutScheduled = true;\n        }\n        if((op & (SocketOperation.Write | SocketOperation.Connect)) !== 0)\n        {\n            if(this._writeTimeoutScheduled)\n            {\n                this._timer.cancel(this._writeTimeoutId);\n            }\n            this._writeTimeoutId = this._timer.schedule(() => this.timedOut(), timeout);\n            this._writeTimeoutScheduled = true;\n        }\n    }\n\n    unscheduleTimeout(op)\n    {\n        if((op & SocketOperation.Read) !== 0 && this._readTimeoutScheduled)\n        {\n            this._timer.cancel(this._readTimeoutId);\n            this._readTimeoutScheduled = false;\n        }\n        if((op & (SocketOperation.Write | SocketOperation.Connect)) !== 0 && this._writeTimeoutScheduled)\n        {\n            this._timer.cancel(this._writeTimeoutId);\n            this._writeTimeoutScheduled = false;\n        }\n    }\n\n    warning(msg, ex)\n    {\n        this._logger.warning(msg + \":\\n\" + this._desc + \"\\n\" + ex.toString());\n    }\n\n    checkState()\n    {\n        if(this._state < StateHolding || this._dispatchCount > 0)\n        {\n            return;\n        }\n\n        //\n        // We aren't finished until the state is finished and all\n        // outstanding requests are completed. Otherwise we couldn't\n        // guarantee that there are no outstanding calls when deactivate()\n        // is called on the servant locators.\n        //\n        if(this._state === StateFinished && this._finishedPromises.length > 0)\n        {\n            //\n            // Clear the OA. See bug 1673 for the details of why this is necessary.\n            //\n            this._adapter = null;\n            this._finishedPromises.forEach(p => p.resolve());\n            this._finishedPromises = [];\n        }\n    }\n\n    reap()\n    {\n        if(this._monitor !== null)\n        {\n            this._monitor.reap(this);\n        }\n    }\n\n    read(buf)\n    {\n        const start = buf.position;\n        const ret = this._transceiver.read(buf, this._hasMoreData);\n        if(this._instance.traceLevels().network >= 3 && buf.position != start)\n        {\n            const s = [];\n            s.push(\"received \");\n            if(this._endpoint.datagram())\n            {\n                s.push(buf.limit);\n            }\n            else\n            {\n                s.push(buf.position - start);\n                s.push(\" of \");\n                s.push(buf.limit - start);\n            }\n            s.push(\" bytes via \");\n            s.push(this._endpoint.protocol());\n            s.push(\"\\n\");\n            s.push(this.toString());\n            this._instance.initializationData().logger.trace(this._instance.traceLevels().networkCat, s.join(\"\"));\n        }\n        return ret;\n    }\n\n    write(buf)\n    {\n        const start = buf.position;\n        const ret = this._transceiver.write(buf);\n        if(this._instance.traceLevels().network >= 3 && buf.position != start)\n        {\n            const s = [];\n            s.push(\"sent \");\n            s.push(buf.position - start);\n            if(!this._endpoint.datagram())\n            {\n                s.push(\" of \");\n                s.push(buf.limit - start);\n            }\n            s.push(\" bytes via \");\n            s.push(this._endpoint.protocol());\n            s.push(\"\\n\");\n            s.push(this.toString());\n            this._instance.initializationData().logger.trace(this._instance.traceLevels().networkCat, s.join(\"\"));\n        }\n        return ret;\n    }\n}\n\n// DestructionReason.\nConnectionI.ObjectAdapterDeactivated = 0;\nConnectionI.CommunicatorDestroyed = 1;\n\nIce.ConnectionI = ConnectionI;\n\nclass OutgoingMessage\n{\n    constructor()\n    {\n        this.stream = null;\n        this.outAsync = null;\n        this.requestId = 0;\n        this.prepared = false;\n    }\n\n    canceled()\n    {\n        Debug.assert(this.outAsync !== null);\n        this.outAsync = null;\n    }\n\n    doAdopt()\n    {\n        if(this.adopt)\n        {\n            const stream = new OutputStream(this.stream.instance, Protocol.currentProtocolEncoding);\n            stream.swap(this.stream);\n            this.stream = stream;\n            this.adopt = false;\n        }\n    }\n\n    sent()\n    {\n        if(this.outAsync !== null)\n        {\n            this.outAsync.sent();\n        }\n    }\n\n    completed(ex)\n    {\n        if(this.outAsync !== null)\n        {\n            this.outAsync.completedEx(ex);\n        }\n    }\n\n    static createForStream(stream, adopt)\n    {\n        const m = new OutgoingMessage();\n        m.stream = stream;\n        m.adopt = adopt;\n        m.isSent = false;\n        m.requestId = 0;\n        m.outAsync = null;\n        return m;\n    }\n\n    static create(out, stream, requestId)\n    {\n        const m = new OutgoingMessage();\n        m.stream = stream;\n        m.outAsync = out;\n        m.requestId = requestId;\n        m.isSent = false;\n        m.adopt = false;\n        return m;\n    }\n}\n\nmodule.exports.Ice = Ice;\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/ConnectionI.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/ConnectionInfo.js":
/*!****************************************************!*\
  !*** ./node_modules/ice/src/Ice/ConnectionInfo.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n//\n// Ice version 3.7.10\n//\n// <auto-generated>\n//\n// Generated from file `ConnectionInfo.ice'\n//\n// Warning: do not edit this file.\n//\n// </auto-generated>\n//\n\n/* eslint-disable */\n/* jshint ignore: start */\n\n/* slice2js browser-bundle-skip */\nconst _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\n__webpack_require__(/*! ../Ice/Object */ \"./node_modules/ice/src/Ice/Object.js\");\n__webpack_require__(/*! ../Ice/Value */ \"./node_modules/ice/src/Ice/Value.js\");\n__webpack_require__(/*! ../Ice/ObjectPrx */ \"./node_modules/ice/src/Ice/ObjectPrx.js\");\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\n__webpack_require__(/*! ../Ice/Connection */ \"./node_modules/ice/src/Ice/Connection.js\");\nconst Ice = _ModuleRegistry.module(\"Ice\");\n\nconst Slice = Ice.Slice;\n/* slice2js browser-bundle-skip-end */\n/* slice2js browser-bundle-skip */\n\nlet IceSSL = _ModuleRegistry.module(\"IceSSL\");\n/* slice2js browser-bundle-skip-end */\n\n/**\n * Provides access to the connection details of an SSL connection\n *\n **/\nIceSSL.ConnectionInfo = class extends Ice.ConnectionInfo\n{\n    constructor(underlying, incoming, adapterName, connectionId, cipher = \"\", certs = null, verified = false)\n    {\n        super(underlying, incoming, adapterName, connectionId);\n        this.cipher = cipher;\n        this.certs = certs;\n        this.verified = verified;\n    }\n};\n\n/* slice2js browser-bundle-skip */\nexports.IceSSL = IceSSL;\n/* slice2js browser-bundle-skip-end */\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/ConnectionInfo.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/ConnectionRequestHandler.js":
/*!**************************************************************!*\
  !*** ./node_modules/ice/src/Ice/ConnectionRequestHandler.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nconst Ice = (__webpack_require__(/*! ../Ice/ReferenceMode */ \"./node_modules/ice/src/Ice/ReferenceMode.js\").Ice);\nconst ReferenceMode = Ice.ReferenceMode;\n\nclass ConnectionRequestHandler\n{\n    constructor(ref, connection)\n    {\n        this._reference = ref;\n        this._response = ref.getMode() == ReferenceMode.ModeTwoway;\n        this._connection = connection;\n    }\n\n    update(previousHandler, newHandler)\n    {\n        try\n        {\n            if(previousHandler === this)\n            {\n                return newHandler;\n            }\n            else if(previousHandler.getConnection() === this._connection)\n            {\n                //\n                // If both request handlers point to the same connection, we also\n                // update the request handler. See bug ICE-5489 for reasons why\n                // this can be useful.\n                //\n                return newHandler;\n            }\n        }\n        catch(ex)\n        {\n            // Ignore\n        }\n        return this;\n    }\n\n    sendAsyncRequest(out)\n    {\n        return out.invokeRemote(this._connection, this._response);\n    }\n\n    asyncRequestCanceled(out)\n    {\n        return this._connection.asyncRequestCanceled(out);\n    }\n\n    getReference()\n    {\n        return this._reference;\n    }\n\n    getConnection()\n    {\n        return this._connection;\n    }\n}\n\nIce.ConnectionRequestHandler = ConnectionRequestHandler;\nmodule.exports.Ice = Ice;\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/ConnectionRequestHandler.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/Current.js":
/*!*********************************************!*\
  !*** ./node_modules/ice/src/Ice/Current.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n//\n// Ice version 3.7.10\n//\n// <auto-generated>\n//\n// Generated from file `Current.ice'\n//\n// Warning: do not edit this file.\n//\n// </auto-generated>\n//\n\n/* eslint-disable */\n/* jshint ignore: start */\n\n/* slice2js browser-bundle-skip */\nconst _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\n__webpack_require__(/*! ../Ice/Struct */ \"./node_modules/ice/src/Ice/Struct.js\");\n__webpack_require__(/*! ../Ice/EnumBase */ \"./node_modules/ice/src/Ice/EnumBase.js\");\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\n__webpack_require__(/*! ../Ice/ObjectAdapterF */ \"./node_modules/ice/src/Ice/ObjectAdapterF.js\");\n__webpack_require__(/*! ../Ice/ConnectionF */ \"./node_modules/ice/src/Ice/ConnectionF.js\");\n__webpack_require__(/*! ../Ice/Identity */ \"./node_modules/ice/src/Ice/Identity.js\");\n__webpack_require__(/*! ../Ice/Version */ \"./node_modules/ice/src/Ice/Version.js\");\nconst Ice = _ModuleRegistry.module(\"Ice\");\n\nconst Slice = Ice.Slice;\n/* slice2js browser-bundle-skip-end */\n\nSlice.defineDictionary(Ice, \"Context\", \"ContextHelper\", \"Ice.StringHelper\", \"Ice.StringHelper\", false, undefined, undefined);\n\n/**\n * Determines the retry behavior an invocation in case of a (potentially) recoverable error.\n *\n **/\nIce.OperationMode = Slice.defineEnum([\n    ['Normal', 0], ['Nonmutating', 1], ['Idempotent', 2]]);\n\n/**\n * Information about the current method invocation for servers. Each\n * operation on the server has a <code>Current</code> as its implicit final\n * parameter. <code>Current</code> is mostly used for Ice services. Most\n * applications ignore this parameter.\n *\n **/\nIce.Current = class\n{\n    constructor(adapter = null, con = null, id = new Ice.Identity(), facet = \"\", operation = \"\", mode = Ice.OperationMode.Normal, ctx = null, requestId = 0, encoding = new Ice.EncodingVersion())\n    {\n        this.adapter = adapter;\n        this.con = con;\n        this.id = id;\n        this.facet = facet;\n        this.operation = operation;\n        this.mode = mode;\n        this.ctx = ctx;\n        this.requestId = requestId;\n        this.encoding = encoding;\n    }\n};\n\nSlice.defineStruct(Ice.Current, false, true);\n/* slice2js browser-bundle-skip */\nexports.Ice = Ice;\n/* slice2js browser-bundle-skip-end */\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/Current.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/Debug.js":
/*!*******************************************!*\
  !*** ./node_modules/ice/src/Ice/Debug.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\n/* eslint no-sync: \"off\" */\n/* eslint no-process-exit: \"off\" */\n\nconst Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n__webpack_require__(/*! ../Ice/Exception */ \"./node_modules/ice/src/Ice/Exception.js\");\n\nlet Debug = {};\n\nif (typeof process !== 'undefined')\n{\n    const fs = __webpack_require__(/*! fs */ \"?3c7e\");\n    Debug = class\n    {\n        static assert(b, msg)\n        {\n            if(!b)\n            {\n                fs.writeSync(process.stderr.fd, msg === undefined ? \"assertion failed\" : msg);\n                fs.writeSync(process.stderr.fd, new Error().stack);\n                process.exit(1);\n            }\n        }\n    }\n}\nelse\n{\n    class AssertionFailedException extends Error\n    {\n        constructor(message)\n        {\n            super();\n            Ice.Exception.captureStackTrace(this);\n            this.message = message;\n        }\n    }\n    Ice.AssertionFailedException = AssertionFailedException;\n\n    Debug = class\n    {\n        static assert(b, msg)\n        {\n            if(!b)\n            {\n                console.log(msg === undefined ? \"assertion failed\" : msg);\n                console.log(new Error().stack);\n                throw new Ice.AssertionFailedException(msg === undefined ? \"assertion failed\" : msg);\n            }\n        }\n    }\n}\n\nIce.Debug = Debug;\nmodule.exports.Ice = Ice;\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/Debug.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/DefaultsAndOverrides.js":
/*!**********************************************************!*\
  !*** ./node_modules/ice/src/Ice/DefaultsAndOverrides.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nconst Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n\n__webpack_require__(/*! ../Ice/EndpointTypes */ \"./node_modules/ice/src/Ice/EndpointTypes.js\");\n__webpack_require__(/*! ../Ice/FormatType */ \"./node_modules/ice/src/Ice/FormatType.js\");\n__webpack_require__(/*! ../Ice/LocalException */ \"./node_modules/ice/src/Ice/LocalException.js\");\n__webpack_require__(/*! ../Ice/Protocol */ \"./node_modules/ice/src/Ice/Protocol.js\");\n\nconst FormatType = Ice.FormatType;\nconst EndpointSelectionType = Ice.EndpointSelectionType;\nconst Protocol = Ice.Protocol;\n\nclass DefaultsAndOverrides\n{\n    constructor(properties, logger)\n    {\n        this.defaultProtocol = properties.getPropertyWithDefault(\"Ice.Default.Protocol\",\n                                                                 Ice.TcpTransceiver !== null ? \"tcp\" : \"ws\");\n\n        let value = properties.getProperty(\"Ice.Default.Host\");\n        this.defaultHost = value.length > 0 ? value : null;\n\n        value = properties.getProperty(\"Ice.Default.SourceAddress\");\n        this.defaultSourceAddress = value.length > 0 ? value : null;\n\n        value = properties.getProperty(\"Ice.Override.Timeout\");\n        if(value.length > 0)\n        {\n            this.overrideTimeout = true;\n            this.overrideTimeoutValue = properties.getPropertyAsInt(\"Ice.Override.Timeout\");\n            if(this.overrideTimeoutValue < 1 && this.overrideTimeoutValue !== -1)\n            {\n                this.overrideTimeoutValue = -1;\n                logger.warning(\"invalid value for Ice.Override.Timeout `\" +\n                                properties.getProperty(\"Ice.Override.Timeout\") + \"': defaulting to -1\");\n            }\n        }\n        else\n        {\n            this.overrideTimeout = false;\n            this.overrideTimeoutValue = -1;\n        }\n\n        value = properties.getProperty(\"Ice.Override.ConnectTimeout\");\n        if(value.length > 0)\n        {\n            this.overrideConnectTimeout = true;\n            this.overrideConnectTimeoutValue = properties.getPropertyAsInt(\"Ice.Override.ConnectTimeout\");\n            if(this.overrideConnectTimeoutValue < 1 && this.overrideConnectTimeoutValue !== -1)\n            {\n                this.overrideConnectTimeoutValue = -1;\n                logger.warning(\"invalid value for Ice.Override.ConnectTimeout `\" +\n                                properties.getProperty(\"Ice.Override.ConnectTimeout\") + \"': defaulting to -1\");\n            }\n        }\n        else\n        {\n            this.overrideConnectTimeout = false;\n            this.overrideConnectTimeoutValue = -1;\n        }\n\n        value = properties.getProperty(\"Ice.Override.CloseTimeout\");\n        if(value.length > 0)\n        {\n            this.overrideCloseTimeout = true;\n            this.overrideCloseTimeoutValue = properties.getPropertyAsInt(\"Ice.Override.CloseTimeout\");\n            if(this.overrideCloseTimeoutValue < 1 && this.overrideCloseTimeoutValue !== -1)\n            {\n                this.overrideCloseTimeoutValue = -1;\n                logger.warning(\"invalid value for Ice.Override.CloseTimeout `\" +\n                                properties.getProperty(\"Ice.Override.CloseTimeout\") + \"': defaulting to -1\");\n            }\n        }\n        else\n        {\n            this.overrideCloseTimeout = false;\n            this.overrideCloseTimeoutValue = -1;\n        }\n\n        this.overrideSecure = false;\n\n        value = properties.getPropertyWithDefault(\"Ice.Default.EndpointSelection\", \"Random\");\n        if(value === \"Random\")\n        {\n            this.defaultEndpointSelection = EndpointSelectionType.Random;\n        }\n        else if(value === \"Ordered\")\n        {\n            this.defaultEndpointSelection = EndpointSelectionType.Ordered;\n        }\n        else\n        {\n            const ex = new Ice.EndpointSelectionTypeParseException();\n            ex.str = \"illegal value `\" + value + \"'; expected `Random' or `Ordered'\";\n            throw ex;\n        }\n\n        this.defaultTimeout = properties.getPropertyAsIntWithDefault(\"Ice.Default.Timeout\", 60000);\n        if(this.defaultTimeout < 1 && this.defaultTimeout !== -1)\n        {\n            this.defaultTimeout = 60000;\n            logger.warning(\"invalid value for Ice.Default.Timeout `\" + properties.getProperty(\"Ice.Default.Timeout\") +\n                        \"': defaulting to 60000\");\n        }\n\n        this.defaultLocatorCacheTimeout = properties.getPropertyAsIntWithDefault(\"Ice.Default.LocatorCacheTimeout\", -1);\n        if(this.defaultLocatorCacheTimeout < -1)\n        {\n            this.defaultLocatorCacheTimeout = -1;\n            logger.warning(\"invalid value for Ice.Default.LocatorCacheTimeout `\" +\n                        properties.getProperty(\"Ice.Default.LocatorCacheTimeout\") + \"': defaulting to -1\");\n        }\n\n        this.defaultInvocationTimeout = properties.getPropertyAsIntWithDefault(\"Ice.Default.InvocationTimeout\", -1);\n        if(this.defaultInvocationTimeout < 1 && this.defaultInvocationTimeout !== -1)\n        {\n            this.defaultInvocationTimeout = -1;\n            logger.warning(\"invalid value for Ice.Default.InvocationTimeout `\" +\n                        properties.getProperty(\"Ice.Default.InvocationTimeout\") + \"': defaulting to -1\");\n        }\n\n        this.defaultPreferSecure = properties.getPropertyAsIntWithDefault(\"Ice.Default.PreferSecure\", 0) > 0;\n\n        value = properties.getPropertyWithDefault(\"Ice.Default.EncodingVersion\",\n                                                Ice.encodingVersionToString(Protocol.currentEncoding));\n        this.defaultEncoding = Ice.stringToEncodingVersion(value);\n        Protocol.checkSupportedEncoding(this.defaultEncoding);\n\n        const slicedFormat = properties.getPropertyAsIntWithDefault(\"Ice.Default.SlicedFormat\", 0) > 0;\n        this.defaultFormat = slicedFormat ? FormatType.SlicedFormat : FormatType.CompactFormat;\n    }\n}\n\nIce.DefaultsAndOverrides = DefaultsAndOverrides;\nmodule.exports.Ice = Ice;\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/DefaultsAndOverrides.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/Endpoint.js":
/*!**********************************************!*\
  !*** ./node_modules/ice/src/Ice/Endpoint.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n//\n// Ice version 3.7.10\n//\n// <auto-generated>\n//\n// Generated from file `Endpoint.ice'\n//\n// Warning: do not edit this file.\n//\n// </auto-generated>\n//\n\n/* eslint-disable */\n/* jshint ignore: start */\n\n/* slice2js browser-bundle-skip */\nconst _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\n__webpack_require__(/*! ../Ice/Object */ \"./node_modules/ice/src/Ice/Object.js\");\n__webpack_require__(/*! ../Ice/Value */ \"./node_modules/ice/src/Ice/Value.js\");\n__webpack_require__(/*! ../Ice/ObjectPrx */ \"./node_modules/ice/src/Ice/ObjectPrx.js\");\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\n__webpack_require__(/*! ../Ice/Version */ \"./node_modules/ice/src/Ice/Version.js\");\n__webpack_require__(/*! ../Ice/BuiltinSequences */ \"./node_modules/ice/src/Ice/BuiltinSequences.js\");\n__webpack_require__(/*! ../Ice/EndpointF */ \"./node_modules/ice/src/Ice/EndpointF.js\");\nconst Ice = _ModuleRegistry.module(\"Ice\");\n\nconst Slice = Ice.Slice;\n/* slice2js browser-bundle-skip-end */\n\nObject.defineProperty(Ice, 'TCPEndpointType', {\n    value: 1\n});\n\nObject.defineProperty(Ice, 'SSLEndpointType', {\n    value: 2\n});\n\nObject.defineProperty(Ice, 'UDPEndpointType', {\n    value: 3\n});\n\nObject.defineProperty(Ice, 'WSEndpointType', {\n    value: 4\n});\n\nObject.defineProperty(Ice, 'WSSEndpointType', {\n    value: 5\n});\n\nObject.defineProperty(Ice, 'BTEndpointType', {\n    value: 6\n});\n\nObject.defineProperty(Ice, 'BTSEndpointType', {\n    value: 7\n});\n\nObject.defineProperty(Ice, 'iAPEndpointType', {\n    value: 8\n});\n\nObject.defineProperty(Ice, 'iAPSEndpointType', {\n    value: 9\n});\n\n/**\n * Base class providing access to the endpoint details.\n *\n **/\nIce.EndpointInfo = class\n{\n    constructor(underlying = null, timeout = 0, compress = false)\n    {\n        this.underlying = underlying;\n        this.timeout = timeout;\n        this.compress = compress;\n    }\n};\n\n\n/**\n * Provides access to the address details of a IP endpoint.\n *\n * @see Endpoint\n *\n **/\nIce.IPEndpointInfo = class extends Ice.EndpointInfo\n{\n    constructor(underlying, timeout, compress, host = \"\", port = 0, sourceAddress = \"\")\n    {\n        super(underlying, timeout, compress);\n        this.host = host;\n        this.port = port;\n        this.sourceAddress = sourceAddress;\n    }\n};\n\n\n/**\n * Provides access to a TCP endpoint information.\n *\n * @see Endpoint\n *\n **/\nIce.TCPEndpointInfo = class extends Ice.IPEndpointInfo\n{\n    constructor(underlying, timeout, compress, host, port, sourceAddress)\n    {\n        super(underlying, timeout, compress, host, port, sourceAddress);\n    }\n};\n\n\n/**\n * Provides access to an UDP endpoint information.\n *\n * @see Endpoint\n *\n **/\nIce.UDPEndpointInfo = class extends Ice.IPEndpointInfo\n{\n    constructor(underlying, timeout, compress, host, port, sourceAddress, mcastInterface = \"\", mcastTtl = 0)\n    {\n        super(underlying, timeout, compress, host, port, sourceAddress);\n        this.mcastInterface = mcastInterface;\n        this.mcastTtl = mcastTtl;\n    }\n};\n\n\n/**\n * Provides access to a WebSocket endpoint information.\n *\n **/\nIce.WSEndpointInfo = class extends Ice.EndpointInfo\n{\n    constructor(underlying, timeout, compress, resource = \"\")\n    {\n        super(underlying, timeout, compress);\n        this.resource = resource;\n    }\n};\n\n\n/**\n * Provides access to the details of an opaque endpoint.\n *\n * @see Endpoint\n *\n **/\nIce.OpaqueEndpointInfo = class extends Ice.EndpointInfo\n{\n    constructor(underlying, timeout, compress, rawEncoding = new Ice.EncodingVersion(), rawBytes = null)\n    {\n        super(underlying, timeout, compress);\n        this.rawEncoding = rawEncoding;\n        this.rawBytes = rawBytes;\n    }\n};\n\n/* slice2js browser-bundle-skip */\nexports.Ice = Ice;\n/* slice2js browser-bundle-skip-end */\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/Endpoint.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/EndpointF.js":
/*!***********************************************!*\
  !*** ./node_modules/ice/src/Ice/EndpointF.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n//\n// Ice version 3.7.10\n//\n// <auto-generated>\n//\n// Generated from file `EndpointF.ice'\n//\n// Warning: do not edit this file.\n//\n// </auto-generated>\n//\n\n/* eslint-disable */\n/* jshint ignore: start */\n\n/* slice2js browser-bundle-skip */\nconst _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\nconst Ice = _ModuleRegistry.module(\"Ice\");\n\nconst Slice = Ice.Slice;\n/* slice2js browser-bundle-skip-end */\n\nSlice.defineSequence(Ice, \"EndpointSeqHelper\", \"Ice.ObjectHelper\", false, \"Ice.Endpoint\");\n/* slice2js browser-bundle-skip */\nexports.Ice = Ice;\n/* slice2js browser-bundle-skip-end */\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/EndpointF.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/EndpointFactoryManager.js":
/*!************************************************************!*\
  !*** ./node_modules/ice/src/Ice/EndpointFactoryManager.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nconst Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n\n__webpack_require__(/*! ../Ice/Debug */ \"./node_modules/ice/src/Ice/Debug.js\");\n__webpack_require__(/*! ../Ice/LocalException */ \"./node_modules/ice/src/Ice/LocalException.js\");\n__webpack_require__(/*! ../Ice/OpaqueEndpointI */ \"./node_modules/ice/src/Ice/OpaqueEndpointI.js\");\n__webpack_require__(/*! ../Ice/Protocol */ \"./node_modules/ice/src/Ice/Protocol.js\");\n__webpack_require__(/*! ../Ice/Stream */ \"./node_modules/ice/src/Ice/Stream.js\");\n__webpack_require__(/*! ../Ice/StringUtil */ \"./node_modules/ice/src/Ice/StringUtil.js\");\n\n//\n// Local aliases.\n//\nconst Debug = Ice.Debug;\nconst InputStream = Ice.InputStream;\nconst OutputStream = Ice.OutputStream;\nconst EndpointParseException = Ice.EndpointParseException;\nconst OpaqueEndpointI = Ice.OpaqueEndpointI;\nconst Protocol = Ice.Protocol;\nconst StringUtil = Ice.StringUtil;\n\nclass EndpointFactoryManager\n{\n    constructor(instance)\n    {\n        this._instance = instance;\n        this._factories = [];\n    }\n\n    add(factory)\n    {\n        Debug.assert(this._factories.find(f => factory.type() == f.type()) === undefined);\n        this._factories.push(factory);\n    }\n\n    get(type)\n    {\n        return this._factories.find(f => type == f.type()) || null;\n    }\n\n    create(str, oaEndpoint)\n    {\n        const s = str.trim();\n        if(s.length === 0)\n        {\n            throw new EndpointParseException(\"value has no non-whitespace characters\");\n        }\n\n        const arr = StringUtil.splitString(s, \" \\t\\n\\r\");\n        if(arr.length === 0)\n        {\n            throw new EndpointParseException(\"value has no non-whitespace characters\");\n        }\n\n        let protocol = arr[0];\n        arr.splice(0, 1);\n\n        if(protocol === \"default\")\n        {\n            protocol = this._instance.defaultsAndOverrides().defaultProtocol;\n        }\n        for(let i = 0, length = this._factories.length; i < length; ++i)\n        {\n            if(this._factories[i].protocol() === protocol)\n            {\n                const e = this._factories[i].create(arr, oaEndpoint);\n                if(arr.length > 0)\n                {\n                    throw new EndpointParseException(\"unrecognized argument `\" + arr[0] + \"' in endpoint `\" +\n                                                     str + \"'\");\n                }\n                return e;\n            }\n        }\n\n        //\n        // If the stringified endpoint is opaque, create an unknown endpoint,\n        // then see whether the type matches one of the known endpoints.\n        //\n        if(protocol === \"opaque\")\n        {\n            const ue = new OpaqueEndpointI();\n            ue.initWithOptions(arr);\n            if(arr.length > 0)\n            {\n                throw new EndpointParseException(\"unrecognized argument `\" + arr[0] + \"' in endpoint `\" + str + \"'\");\n            }\n\n            for(let i = 0, length = this._factories.length; i < length; ++i)\n            {\n                if(this._factories[i].type() == ue.type())\n                {\n                    //\n                    // Make a temporary stream, write the opaque endpoint data into the stream,\n                    // and ask the factory to read the endpoint data from that stream to create\n                    // the actual endpoint.\n                    //\n                    const os = new OutputStream(this._instance, Protocol.currentProtocolEncoding);\n                    os.writeShort(ue.type());\n                    ue.streamWrite(os);\n                    const is = new InputStream(this._instance, Protocol.currentProtocolEncoding, os.buffer);\n                    is.pos = 0;\n                    is.readShort(); // type\n                    is.startEncapsulation();\n                    const e = this._factories[i].read(is);\n                    is.endEncapsulation();\n                    return e;\n                }\n            }\n            return ue; // Endpoint is opaque, but we don't have a factory for its type.\n        }\n\n        return null;\n    }\n\n    read(s)\n    {\n        const type = s.readShort();\n\n        const factory = this.get(type);\n        let e = null;\n        s.startEncapsulation();\n        if(factory)\n        {\n            e = factory.read(s);\n        }\n        //\n        // If the factory failed to read the endpoint, return an opaque endpoint. This can\n        // occur if for example the factory delegates to another factory and this factory\n        // isn't available. In this case, the factory needs to make sure the stream position\n        // is preserved for reading the opaque endpoint.\n        //\n        if(!e)\n        {\n            e = new OpaqueEndpointI(type);\n            e.initWithStream(s);\n        }\n        s.endEncapsulation();\n        return e;\n    }\n\n    destroy()\n    {\n        this._factories.forEach(factory => factory.destroy());\n        this._factories = [];\n    }\n}\n\nIce.EndpointFactoryManager = EndpointFactoryManager;\nmodule.exports.Ice = Ice;\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/EndpointFactoryManager.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/EndpointI.js":
/*!***********************************************!*\
  !*** ./node_modules/ice/src/Ice/EndpointI.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nconst Ice = (__webpack_require__(/*! ../Ice/Endpoint */ \"./node_modules/ice/src/Ice/Endpoint.js\").Ice);\n\nclass EndpointI\n{\n    toString()\n    {\n        //\n        // WARNING: Certain features, such as proxy validation in Glacier2,\n        // depend on the format of proxy strings. Changes to toString() and\n        // methods called to generate parts of the reference string could break\n        // these features. Please review for all features that depend on the\n        // format of proxyToString() before changing this and related code.\n        //\n        return this.protocol() + this.options();\n    }\n\n    initWithOptions(args)\n    {\n        const unknown = [];\n\n        let str = \"`\" + this.protocol();\n        for(let i = 0; i < args.length; ++i)\n        {\n            if(args[i].search(/[ \\t\\n\\r]+/) !== -1)\n            {\n                str += \" \\\"\" + args[i] + \"\\\"\";\n            }\n            else\n            {\n                str += \" \" + args[i];\n            }\n        }\n        str += \"'\";\n\n        for(let i = 0; i < args.length;)\n        {\n            const option = args[i++];\n            if(option.length < 2 || option.charAt(0) != '-')\n            {\n                unknown.push(option);\n                continue;\n            }\n\n            let argument = null;\n            if(i < args.length && args[i].charAt(0) != '-')\n            {\n                argument = args[i++];\n            }\n\n            if(!this.checkOption(option, argument, str))\n            {\n                unknown.push(option);\n                if(argument !== null)\n                {\n                    unknown.push(argument);\n                }\n            }\n        }\n\n        args.length = 0;\n        for(let i = 0; i < unknown.length; i++)\n        {\n            args.push(unknown[i]);\n        }\n    }\n\n    //\n    // Compare endpoints for sorting purposes\n    //\n    equals(p)\n    {\n        if(!(p instanceof EndpointI))\n        {\n            return false;\n        }\n        return this.compareTo(p) === 0;\n    }\n\n    checkOption()\n    {\n        return false;\n    }\n}\n\nIce.EndpointI = EndpointI;\nmodule.exports.Ice = Ice;\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/EndpointI.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/EndpointInfo.js":
/*!**************************************************!*\
  !*** ./node_modules/ice/src/Ice/EndpointInfo.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n//\n// Ice version 3.7.10\n//\n// <auto-generated>\n//\n// Generated from file `EndpointInfo.ice'\n//\n// Warning: do not edit this file.\n//\n// </auto-generated>\n//\n\n/* eslint-disable */\n/* jshint ignore: start */\n\n/* slice2js browser-bundle-skip */\nconst _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\n__webpack_require__(/*! ../Ice/Object */ \"./node_modules/ice/src/Ice/Object.js\");\n__webpack_require__(/*! ../Ice/Value */ \"./node_modules/ice/src/Ice/Value.js\");\n__webpack_require__(/*! ../Ice/ObjectPrx */ \"./node_modules/ice/src/Ice/ObjectPrx.js\");\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\n__webpack_require__(/*! ../Ice/Endpoint */ \"./node_modules/ice/src/Ice/Endpoint.js\");\nconst Ice = _ModuleRegistry.module(\"Ice\");\n\nconst Slice = Ice.Slice;\n/* slice2js browser-bundle-skip-end */\n/* slice2js browser-bundle-skip */\n\nlet IceSSL = _ModuleRegistry.module(\"IceSSL\");\n/* slice2js browser-bundle-skip-end */\n\n/**\n * Provides access to an SSL endpoint information.\n *\n **/\nIceSSL.EndpointInfo = class extends Ice.EndpointInfo\n{\n    constructor(underlying, timeout, compress)\n    {\n        super(underlying, timeout, compress);\n    }\n};\n\n/* slice2js browser-bundle-skip */\nexports.IceSSL = IceSSL;\n/* slice2js browser-bundle-skip-end */\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/EndpointInfo.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/EndpointTypes.js":
/*!***************************************************!*\
  !*** ./node_modules/ice/src/Ice/EndpointTypes.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n//\n// Ice version 3.7.10\n//\n// <auto-generated>\n//\n// Generated from file `EndpointTypes.ice'\n//\n// Warning: do not edit this file.\n//\n// </auto-generated>\n//\n\n/* eslint-disable */\n/* jshint ignore: start */\n\n/* slice2js browser-bundle-skip */\nconst _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\n__webpack_require__(/*! ../Ice/EnumBase */ \"./node_modules/ice/src/Ice/EnumBase.js\");\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\nconst Ice = _ModuleRegistry.module(\"Ice\");\n\nconst Slice = Ice.Slice;\n/* slice2js browser-bundle-skip-end */\n\n/**\n * Determines the order in which the Ice run time uses the endpoints\n * in a proxy when establishing a connection.\n *\n **/\nIce.EndpointSelectionType = Slice.defineEnum([\n    ['Random', 0], ['Ordered', 1]]);\n/* slice2js browser-bundle-skip */\nexports.Ice = Ice;\n/* slice2js browser-bundle-skip-end */\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/EndpointTypes.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/EnumBase.js":
/*!**********************************************!*\
  !*** ./node_modules/ice/src/Ice/EnumBase.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nconst Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n\n//\n// Ice.EnumBase\n//\nclass EnumBase\n{\n    constructor(name, value)\n    {\n        this._name = name;\n        this._value = value;\n    }\n\n    equals(rhs)\n    {\n        if(this === rhs)\n        {\n            return true;\n        }\n\n        if(!(rhs instanceof Object.getPrototypeOf(this).constructor))\n        {\n            return false;\n        }\n\n        return this._value == rhs._value;\n    }\n\n    hashCode()\n    {\n        return this._value;\n    }\n\n    toString()\n    {\n        return this._name;\n    }\n\n    get name()\n    {\n        return this._name;\n    }\n\n    get value()\n    {\n        return this._value;\n    }\n}\nIce.EnumBase = EnumBase;\n\nclass EnumHelper\n{\n    constructor(enumType)\n    {\n        this._enumType = enumType;\n    }\n\n    write(os, v)\n    {\n        this._enumType._write(os, v);\n    }\n\n    writeOptional(os, tag, v)\n    {\n        this._enumType._writeOpt(os, tag, v);\n    }\n\n    read(is)\n    {\n        return this._enumType._read(is);\n    }\n\n    readOptional(is, tag)\n    {\n        return this._enumType._readOpt(is, tag);\n    }\n}\n\nIce.EnumHelper = EnumHelper;\n\nconst Slice = Ice.Slice;\nSlice.defineEnum = function(enumerators)\n{\n    const type = class extends EnumBase\n    {\n    };\n\n    const enums = [];\n    let maxValue = 0;\n    let firstEnum = null;\n\n    for(const idx in enumerators)\n    {\n        const e = enumerators[idx][0];\n        const value = enumerators[idx][1];\n        const enumerator = new type(e, value);\n        enums[value] = enumerator;\n        if(!firstEnum)\n        {\n            firstEnum = enumerator;\n        }\n        Object.defineProperty(type, e, {\n            enumerable: true,\n            value: enumerator\n        });\n        if(value > maxValue)\n        {\n            maxValue = value;\n        }\n    }\n\n    Object.defineProperty(type, \"minWireSize\", {get: () => 1});\n\n    type._write = function(os, v)\n    {\n        if(v)\n        {\n            os.writeEnum(v);\n        }\n        else\n        {\n            os.writeEnum(firstEnum);\n        }\n    };\n\n    type._read = function(is)\n    {\n        return is.readEnum(type);\n    };\n\n    type._writeOpt = function(os, tag, v)\n    {\n        if(v !== undefined)\n        {\n            if(os.writeOptional(tag, Ice.OptionalFormat.Size))\n            {\n                type._write(os, v);\n            }\n        }\n    };\n\n    type._readOpt = function(is, tag)\n    {\n        return is.readOptionalEnum(tag, type);\n    };\n\n    type._helper = new EnumHelper(type);\n\n    Object.defineProperty(type, 'valueOf', {\n        value: function(v) {\n            if(v === undefined)\n            {\n                return type;\n            }\n            return enums[v];\n        }\n    });\n\n    Object.defineProperty(type, 'maxValue', {\n        value: maxValue\n    });\n\n    Object.defineProperty(type.prototype, 'maxValue', {\n        value: maxValue\n    });\n\n    return type;\n};\nmodule.exports.Ice = Ice;\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/EnumBase.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/ExUtil.js":
/*!********************************************!*\
  !*** ./node_modules/ice/src/Ice/ExUtil.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nconst Ice = (__webpack_require__(/*! ../Ice/LocalException */ \"./node_modules/ice/src/Ice/LocalException.js\").Ice);\n\n//\n// Local aliases.\n//\nconst UnexpectedObjectException = Ice.UnexpectedObjectException;\nconst MemoryLimitException = Ice.MemoryLimitException;\n\n//\n// Exception utilities\n//\n\nIce.ExUtil =\n{\n    throwUOE: function(expectedType, v)\n    {\n        const type = v.ice_id();\n        throw new UnexpectedObjectException(\"expected element of type `\" + expectedType + \"' but received `\" +\n                                            type + \"'\", type, expectedType);\n    },\n    throwMemoryLimitException: function(requested, maximum)\n    {\n        throw new MemoryLimitException(\"requested \" + requested + \" bytes, maximum allowed is \" + maximum +\n                                       \" bytes (see Ice.MessageSizeMax)\");\n    }\n};\nmodule.exports.Ice = Ice;\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/ExUtil.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/Exception.js":
/*!***********************************************!*\
  !*** ./node_modules/ice/src/Ice/Exception.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nconst Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n\nconst toString = function(key, object, objectTable, ident)\n{\n    ident += \"  \";\n    if(object === null)\n    {\n        return \"\\n\" + ident + key + \": (null)\";\n    }\n    if(object === undefined)\n    {\n        return \"\\n\" + ident + key + \": (undefined)\";\n    }\n    if(key == \"stack\" || typeof object == \"function\")\n    {\n        return \"\";\n    }\n    if(typeof object != \"object\")\n    {\n        return \"\\n\" + ident + key + \": \\\"\" + object + \"\\\"\";\n    }\n    if(objectTable.indexOf(object) != -1)\n    {\n        return \"\\n\" + ident + key + \": (recursive)\";\n    }\n\n    objectTable.push(object);\n    let s = \"\\n\" + ident + key + \":\";\n    for(const k in object)\n    {\n        if(key.indexOf(\"_\") === 0)\n        {\n            continue;\n        }\n\n        if(typeof object[k] == \"function\")\n        {\n            continue;\n        }\n        s += ident + toString(k, object[k], objectTable, ident);\n    }\n    return s;\n};\n\n//\n// Ice.Exception\n//\nclass Exception extends Error\n{\n    constructor(cause)\n    {\n        super();\n        if(cause)\n        {\n            this.ice_cause = cause;\n        }\n    }\n\n    ice_name()\n    {\n        return this.constructor._id.substr(2);\n    }\n\n    ice_id()\n    {\n        return this.constructor._id;\n    }\n\n    static get _id()\n    {\n        return \"::Ice::Exception\";\n    }\n\n    toString()\n    {\n        //\n        // We have a guard here to prevent being re-entered. With some browsers (IE), accessing\n        // the stack property ends up calling toString on the exception to print it out with the\n        // stack.\n        //\n        if(this._inToStringAlready)\n        {\n            return \"\";\n        }\n\n        this._inToStringAlready = true;\n        let s = this.ice_id();\n        for(const key in this)\n        {\n            if(key != \"_inToStringAlready\")\n            {\n                s += toString(key, this[key], [], \"\");\n            }\n        }\n\n        if(Ice._printStackTraces === true && this.stack)\n        {\n            s += \"\\n\" + this.stack;\n        }\n        this._inToStringAlready = false;\n        return s;\n    }\n\n    static captureStackTrace(object)\n    {\n        const stack = new Error().stack;\n        //\n        // In IE 10 and greater the stack will be filled once the Error is throw\n        // we don't need to do anything.\n        //\n        if(stack !== undefined)\n        {\n            Object.defineProperty(object, \"stack\", {\n                get: function()\n                    {\n                        return stack;\n                    }\n            });\n        }\n    }\n}\n\nIce.Exception = Exception;\n\n//\n// Ice.LocalException\n//\nclass LocalException extends Exception\n{\n    constructor(cause)\n    {\n        super(cause);\n        Exception.captureStackTrace(this);\n    }\n\n    static get _id()\n    {\n        return \"::Ice::LocalException\";\n    }\n}\n\nIce.LocalException = LocalException;\n\n//\n// Ice.UserException\n//\nclass UserException extends Exception\n{\n    constructor(cause)\n    {\n        super(cause);\n        Exception.captureStackTrace(this);\n    }\n\n    static get _id()\n    {\n        return \"::Ice::UserException\";\n    }\n\n    ice_getSlicedData()\n    {\n        return null;\n    }\n\n    _write(os)\n    {\n        os.startException(null);\n        writeImpl(this, os, this._mostDerivedType());\n        os.endException();\n    }\n\n    _read(is)\n    {\n        is.startException();\n        readImpl(this, is, this._mostDerivedType());\n        is.endException(false);\n    }\n\n    _usesClasses()\n    {\n        return false;\n    }\n\n    _mostDerivedType()\n    {\n        return Ice.UserException;\n    }\n}\nIce.UserException = UserException;\n\n//\n// Private methods\n//\n\nconst writeImpl = function(obj, os, type)\n{\n    //\n    // The writeImpl method is a recursive method that goes down the\n    // class hierarchy to marshal each slice of the class using the\n    // generated _writeMemberImpl method.\n    //\n\n    if(type === undefined || type === UserException)\n    {\n        return; // Don't marshal anything for Ice.UserException\n    }\n\n    os.startSlice(type._id, -1, type._parent === UserException);\n    if(type.prototype.hasOwnProperty('_writeMemberImpl'))\n    {\n        type.prototype._writeMemberImpl.call(obj, os);\n    }\n    os.endSlice();\n    writeImpl(obj, os, type._parent);\n};\n\nconst readImpl = function(obj, is, type)\n{\n    //\n    // The readImpl method is a recursive method that goes down the\n    // class hierarchy to marshal each slice of the class using the\n    // generated _readMemberImpl method.\n    //\n\n    if(type === undefined || type === UserException)\n    {\n        return; // Don't marshal anything for UserException\n    }\n\n    is.startSlice();\n    if(type.prototype.hasOwnProperty('_readMemberImpl'))\n    {\n        type.prototype._readMemberImpl.call(obj, is);\n    }\n    is.endSlice();\n    readImpl(obj, is, type._parent);\n};\n\nconst writePreserved = function(os)\n{\n    //\n    // For Slice exceptions which are marked \"preserved\", the implementation of this method\n    // replaces the Ice.UserException.prototype._write method.\n    //\n    os.startException(this._slicedData);\n    writeImpl(this, os, this._mostDerivedType());\n    os.endException();\n};\n\nconst readPreserved = function(is)\n{\n    //\n    // For Slice exceptions which are marked \"preserved\", the implementation of this method\n    // replaces the Ice.UserException.prototype._read method.\n    //\n    is.startException();\n    readImpl(this, is, this._mostDerivedType());\n    this._slicedData = is.endException(true);\n};\n\nconst ice_getSlicedData = function()\n{\n    return this._slicedData;\n};\n\nIce.Slice.PreservedUserException = function(ex)\n{\n    ex.prototype.ice_getSlicedData = ice_getSlicedData;\n    ex.prototype._write = writePreserved;\n    ex.prototype._read = readPreserved;\n};\n\nmodule.exports.Ice = Ice;\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/Exception.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/FacetMap.js":
/*!**********************************************!*\
  !*** ./node_modules/ice/src/Ice/FacetMap.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n//\n// Ice version 3.7.10\n//\n// <auto-generated>\n//\n// Generated from file `FacetMap.ice'\n//\n// Warning: do not edit this file.\n//\n// </auto-generated>\n//\n\n/* eslint-disable */\n/* jshint ignore: start */\n\n/* slice2js browser-bundle-skip */\nconst _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\n__webpack_require__(/*! ../Ice/Object */ \"./node_modules/ice/src/Ice/Object.js\");\n__webpack_require__(/*! ../Ice/Value */ \"./node_modules/ice/src/Ice/Value.js\");\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\nconst Ice = _ModuleRegistry.module(\"Ice\");\n\nconst Slice = Ice.Slice;\n/* slice2js browser-bundle-skip-end */\n\nSlice.defineDictionary(Ice, \"FacetMap\", \"FacetMapHelper\", \"Ice.StringHelper\", \"Ice.ObjectHelper\", false, undefined, \"Ice.Value\");\n/* slice2js browser-bundle-skip */\nexports.Ice = Ice;\n/* slice2js browser-bundle-skip-end */\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/FacetMap.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/FormatType.js":
/*!************************************************!*\
  !*** ./node_modules/ice/src/Ice/FormatType.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nconst Ice = (__webpack_require__(/*! ../Ice/EnumBase */ \"./node_modules/ice/src/Ice/EnumBase.js\").Ice);\nIce.FormatType = Ice.Slice.defineEnum(\n    [\n        ['DefaultFormat', 0],\n        ['CompactFormat', 1],\n        ['SlicedFormat', 2]\n    ]);\nmodule.exports.Ice = Ice;\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/FormatType.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/HashMap.js":
/*!*********************************************!*\
  !*** ./node_modules/ice/src/Ice/HashMap.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nconst Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n\n__webpack_require__(/*! ../Ice/StringUtil */ \"./node_modules/ice/src/Ice/StringUtil.js\");\n__webpack_require__(/*! ../Ice/UUID */ \"./node_modules/ice/src/Ice/UUID.js\");\n\nconst _ModuleRegistry = Ice._ModuleRegistry;\nconst StringUtil = Ice.StringUtil;\n\nfunction setInternal(map, key, value, hash, index)\n{\n    //\n    // Search for an entry with the same key.\n    //\n    for(let e = map._table[index]; e !== null; e = e._nextInBucket)\n    {\n        if(e._hash === hash && map.keysEqual(key, e._key))\n        {\n            //\n            // Found a match, update the value.\n            //\n            e._value = value;\n            return undefined;\n        }\n    }\n\n    //\n    // No match found, add a new entry.\n    //\n    map.add(key, value, hash, index);\n    return undefined;\n}\n\nfunction compareEquals(v1, v2)\n{\n    if(v1 === v2)\n    {\n        return true;\n    }\n    if(v1 === undefined || v1 === null || v2 === undefined || v2 === null)\n    {\n        return false;\n    }\n    return v1.equals(v2);\n}\n\nfunction compareIdentity(v1, v2)\n{\n    return v1 === v2;\n}\n\nclass HashMap\n{\n    constructor(arg1, arg2)\n    {\n        //\n        // The first argument can be a HashMap or the keyComparator, the second\n        // argument if present is always the value comparator.\n        //\n        let h, keyComparator, valueComparator;\n\n        if(typeof arg1 == \"function\")\n        {\n            keyComparator = arg1;\n            valueComparator = arg2;\n        }\n        else if(arg1 instanceof HashMap)\n        {\n            h = arg1;\n            keyComparator = h.keyComparator;\n            valueComparator = h.valueComparator;\n        }\n\n        this._size = 0;\n        this._head = null;\n        this._initialCapacity = 32;\n        this._loadFactor = 0.75;\n        this._table = [];\n\n        this._keyComparator = (typeof keyComparator == \"function\") ? keyComparator : compareIdentity;\n        this._valueComparator = (typeof valueComparator == \"function\") ? valueComparator : compareIdentity;\n\n        if(h instanceof HashMap && h._size > 0)\n        {\n            this._threshold = h._threshold;\n            this._table.length = h._table.length;\n            for(let i = 0; i < h._table.length; i++)\n            {\n                this._table[i] = null;\n            }\n            this.merge(h);\n        }\n        else\n        {\n            this._threshold = this._initialCapacity * this._loadFactor;\n            for(let i = 0; i < this._initialCapacity; i++)\n            {\n                this._table[i] = null;\n            }\n        }\n    }\n\n    set(key, value)\n    {\n        const r = this.computeHash(key); // Returns an object with key,hash members.\n\n        const index = this.hashIndex(r.hash, this._table.length);\n\n        return setInternal(this, r.key, value, r.hash, index);\n    }\n\n    get(key)\n    {\n        const r = this.computeHash(key); // Returns an object with key,hash members.\n        const e = this.findEntry(r.key, r.hash);\n        return e !== undefined ? e._value : undefined;\n    }\n\n    has(key)\n    {\n        const r = this.computeHash(key); // Returns an object with key,hash members.\n        return this.findEntry(r.key, r.hash) !== undefined;\n    }\n\n    delete(key)\n    {\n        const r = this.computeHash(key); // Returns an object with key,hash members.\n\n        const index = this.hashIndex(r.hash, this._table.length);\n\n        //\n        // Search for an entry with the same key.\n        //\n        let prev = null;\n        for(let e = this._table[index]; e !== null; e = e._nextInBucket)\n        {\n            if(e._hash === r.hash && this.keysEqual(r.key, e._key))\n            {\n                //\n                // Found a match.\n                //\n                this._size--;\n\n                //\n                // Remove from bucket.\n                //\n                if(prev !== null)\n                {\n                    prev._nextInBucket = e._nextInBucket;\n                }\n                else\n                {\n                    this._table[index] = e._nextInBucket;\n                }\n\n                //\n                // Unlink the entry.\n                //\n                if(e._prev !== null)\n                {\n                    e._prev._next = e._next;\n                }\n                if(e._next !== null)\n                {\n                    e._next._prev = e._prev;\n                }\n\n                if(this._head === e)\n                {\n                    this._head = e._next;\n                }\n\n                return e._value;\n            }\n\n            prev = e;\n        }\n\n        return undefined;\n    }\n\n    clear()\n    {\n        for(let i = 0; i < this._table.length; ++i)\n        {\n            this._table[i] = null;\n        }\n        this._head = null;\n        this._size = 0;\n    }\n\n    forEach(fn, obj)\n    {\n        obj = obj === undefined ? fn : obj;\n        for(let e = this._head; e !== null; e = e._next)\n        {\n            fn.call(obj, e._value, e._key);\n        }\n    }\n\n    *entries()\n    {\n        for(let e = this._head; e !== null; e = e._next)\n        {\n            yield [e._key, e._value];\n        }\n    }\n\n    *keys()\n    {\n        for(let e = this._head; e !== null; e = e._next)\n        {\n            yield e._key;\n        }\n    }\n\n    *values()\n    {\n        for(let e = this._head; e !== null; e = e._next)\n        {\n            yield e._value;\n        }\n    }\n\n    equals(other, valuesEqual)\n    {\n        if(other === null || !(other instanceof HashMap) || this._size !== other._size)\n        {\n            return false;\n        }\n\n        let eq;\n        if(valuesEqual)\n        {\n            eq = valuesEqual;\n        }\n        else\n        {\n            eq = (v1, v2) => this._valueComparator.call(this._valueComparator, v1, v2);\n        }\n\n        for(let e = this._head; e !== null; e = e._next)\n        {\n            const oe = other.findEntry(e._key, e._hash);\n            if(oe === undefined || !eq(e._value, oe._value))\n            {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    merge(from)\n    {\n        for(let e = from._head; e !== null; e = e._next)\n        {\n            setInternal(this, e._key, e._value, e._hash, this.hashIndex(e._hash, this._table.length));\n        }\n    }\n\n    add(key, value, hash, index)\n    {\n        //\n        // Create a new table entry.\n        //\n        const e = Object.create(null, {\n            key:\n            {\n                enumerable: true,\n                get: function() { return this._key; }\n            },\n            value:\n            {\n                enumerable: true,\n                get: function() { return this._value; }\n            },\n            next:\n            {\n                enumerable: true,\n                get: function() { return this._next; }\n            },\n            _key:\n            {\n                enumerable: false,\n                writable: true,\n                value: key\n            },\n            _value:\n            {\n                enumerable: false,\n                writable: true,\n                value: value\n            },\n            _prev:\n            {\n                enumerable: false,\n                writable: true,\n                value: null\n            },\n            _next:\n            {\n                enumerable: false,\n                writable: true,\n                value: null\n            },\n            _nextInBucket:\n            {\n                enumerable: false,\n                writable: true,\n                value: null\n            },\n            _hash:\n            {\n                enumerable: false,\n                writable: true,\n                value: hash\n            }\n        });\n        e._nextInBucket = this._table[index];\n        this._table[index] = e;\n\n        e._next = this._head;\n        if(this._head !== null)\n        {\n            this._head._prev = e;\n        }\n        this._head = e;\n\n        this._size++;\n        if(this._size >= this._threshold)\n        {\n            this.resize(this._table.length * 2);\n        }\n    }\n\n    resize(capacity)\n    {\n        const newTable = new Array(capacity).fill(null);\n\n        //\n        // Re-assign all entries to buckets.\n        //\n        for(let e = this._head; e !== null; e = e._next)\n        {\n            const index = this.hashIndex(e._hash, capacity);\n            e._nextInBucket = newTable[index];\n            newTable[index] = e;\n        }\n\n        this._table = newTable;\n        this._threshold = (capacity * this._loadFactor);\n    }\n\n    findEntry(key, hash)\n    {\n        const index = this.hashIndex(hash, this._table.length);\n        //\n        // Search for an entry with the same key.\n        //\n        for(let e = this._table[index]; e !== null; e = e._nextInBucket)\n        {\n            if(e._hash === hash && this.keysEqual(key, e._key))\n            {\n                return e;\n            }\n        }\n\n        return undefined;\n    }\n\n    hashIndex(hash, len)\n    {\n        return hash & (len - 1);\n    }\n\n    computeHash(v)\n    {\n        if(v === 0)\n        {\n            return {key: 0, hash: 0};\n        }\n\n        if(v === null)\n        {\n            if(HashMap._null === null)\n            {\n                const uuid = Ice.generateUUID();\n                HashMap._null = {key: uuid, hash: StringUtil.hashCode(uuid)};\n            }\n            return HashMap._null;\n        }\n\n        if(v === undefined)\n        {\n            throw new RangeError(\"cannot compute hash for undefined value\");\n        }\n\n        if(typeof v.hashCode === \"function\")\n        {\n            return {key: v, hash: v.hashCode()};\n        }\n\n        const type = typeof v;\n        if(type === \"string\" || v instanceof String)\n        {\n            return {key: v, hash: StringUtil.hashCode(v)};\n        }\n        else if(type === \"number\" || v instanceof Number)\n        {\n            if(isNaN(v))\n            {\n                if(HashMap._nan === null)\n                {\n                    const uuid = Ice.generateUUID();\n                    HashMap._nan = {key: uuid, hash: StringUtil.hashCode(uuid)};\n                }\n                return HashMap._nan;\n            }\n            return {key: v, hash: v.toFixed(0)};\n        }\n        else if(type === \"boolean\" || v instanceof Boolean)\n        {\n            return {key: v, hash: v ? 1 : 0};\n        }\n\n        throw new RangeError(\"cannot compute hash for value of type \" + type);\n    }\n\n    keysEqual(k1, k2)\n    {\n        return this._keyComparator.call(this._keyComparator, k1, k2);\n    }\n\n    get size()\n    {\n        return this._size;\n    }\n}\n\nHashMap.prototype[Symbol.iterator] = HashMap.prototype.entries;\n\nIce.HashMap = HashMap;\n\nHashMap.compareEquals = compareEquals;\nHashMap.compareIdentity = compareIdentity;\nHashMap._null = null;\nHashMap._nan = null;\n\nconst Slice = Ice.Slice;\n\nSlice.defineDictionary = function(module, name, helperName, keyHelper, valueHelper, fixed, keysEqual, valueType)\n{\n    if(keysEqual === undefined)\n    {\n        module[name] = Map;\n    }\n    else\n    {\n        //\n        // Define a constructor function for a dictionary whose key type requires\n        // comparison using an equals() method instead of the native comparison\n        // operators.\n        //\n        module[name] = function(h)\n        {\n            return new HashMap(h || keysEqual);\n        };\n    }\n\n    let helper = null;\n    Object.defineProperty(module, helperName,\n    {\n        get: function()\n        {\n            if(helper === null)\n            {\n                helper = Ice.StreamHelpers.generateDictHelper(_ModuleRegistry.type(keyHelper),\n                                                              _ModuleRegistry.type(valueHelper),\n                                                              fixed,\n                                                              _ModuleRegistry.type(valueType),\n                                                              module[name]);\n            }\n            return helper;\n        }\n    });\n};\nmodule.exports.Ice = Ice;\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/HashMap.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/HashUtil.js":
/*!**********************************************!*\
  !*** ./node_modules/ice/src/Ice/HashUtil.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nconst Ice = (__webpack_require__(/*! ../Ice/StringUtil */ \"./node_modules/ice/src/Ice/StringUtil.js\").Ice);\n\nconst StringUtil = Ice.StringUtil;\n\nclass HashUtil\n{\n    static addBoolean(h, b)\n    {\n        return ((h << 5) + h) ^ (b ? 0 : 1);\n    }\n\n    static addString(h, str)\n    {\n        if(str !== undefined && str !== null)\n        {\n            h = ((h << 5) + h) ^ StringUtil.hashCode(str);\n        }\n        return h;\n    }\n\n    static addNumber(h, num)\n    {\n        return ((h << 5) + h) ^ num;\n    }\n\n    static addHashable(h, obj)\n    {\n        if(obj !== undefined && obj !== null)\n        {\n            h = ((h << 5) + h) ^ obj.hashCode();\n        }\n        return h;\n    }\n\n    static addArray(h, arr, hashCode)\n    {\n        if(arr !== undefined && arr !== null)\n        {\n            for(let i = 0; i < arr.length; ++i)\n            {\n                h = hashCode(h, arr[i]);\n            }\n        }\n        return h;\n    }\n}\n\nIce.HashUtil = HashUtil;\nmodule.exports.Ice = Ice;\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/HashUtil.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/IPEndpointI.js":
/*!*************************************************!*\
  !*** ./node_modules/ice/src/Ice/IPEndpointI.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nconst Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n\n__webpack_require__(/*! ../Ice/Address */ \"./node_modules/ice/src/Ice/Address.js\");\n__webpack_require__(/*! ../Ice/EndpointI */ \"./node_modules/ice/src/Ice/EndpointI.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/LocalException */ \"./node_modules/ice/src/Ice/LocalException.js\");\n__webpack_require__(/*! ../Ice/StringUtil */ \"./node_modules/ice/src/Ice/StringUtil.js\");\n\nconst Address = Ice.Address;\nconst EndpointParseException = Ice.EndpointParseException;\nconst HashUtil = Ice.HashUtil;\nconst StringUtil = Ice.StringUtil;\n\nclass IPEndpointI extends Ice.EndpointI\n{\n    constructor(instance, ho, po, sa, conId)\n    {\n        super();\n        this._instance = instance;\n        this._host = ho === undefined ? null : ho;\n        this._port = po === undefined ? 0 : po;\n        this._sourceAddr = sa === undefined ? null : sa;\n        this._connectionId = conId === undefined ? \"\" : conId;\n    }\n\n    //\n    // Marshal the endpoint\n    //\n    streamWrite(s)\n    {\n        s.startEncapsulation();\n        this.streamWriteImpl(s);\n        s.endEncapsulation();\n    }\n\n    getInfo()\n    {\n        const info = new Ice.IPEndpointInfo();\n        this.fillEndpointInfo(info);\n        return info;\n    }\n\n    //\n    // Return the endpoint type\n    //\n    type()\n    {\n        return this._instance.type();\n    }\n\n    //\n    // Return the protocol string\n    //\n    protocol()\n    {\n        return this._instance.protocol();\n    }\n\n    //\n    // Return true if the endpoint is secure.\n    //\n    secure()\n    {\n        return this._instance.secure();\n    }\n\n    connectionId()\n    {\n        return this._connectionId;\n    }\n\n    //\n    // Return a new endpoint with a different connection id.\n    //\n    changeConnectionId(connectionId)\n    {\n        if(connectionId === this._connectionId)\n        {\n            return this;\n        }\n        else\n        {\n            return this.createEndpoint(this._host, this._port, connectionId);\n        }\n    }\n\n    //\n    // Return the endpoint information.\n    //\n    hashCode()\n    {\n        if(this._hashCode === undefined)\n        {\n            this._hashCode = this.hashInit(5381);\n        }\n        return this._hashCode;\n    }\n\n    options()\n    {\n        //\n        // WARNING: Certain features, such as proxy validation in Glacier2,\n        // depend on the format of proxy strings. Changes to toString() and\n        // methods called to generate parts of the reference string could break\n        // these features. Please review for all features that depend on the\n        // format of proxyToString() before changing this and related code.\n        //\n        let s = \"\";\n\n        if(this._host !== null && this._host.length > 0)\n        {\n            s += \" -h \";\n            const addQuote = this._host.indexOf(':') != -1;\n            if(addQuote)\n            {\n                s += \"\\\"\";\n            }\n            s += this._host;\n            if(addQuote)\n            {\n                s += \"\\\"\";\n            }\n        }\n\n        s += \" -p \" + this._port;\n\n        if(this._sourceAddr !== null && this._sourceAddr.length > 0)\n        {\n            s += \" --sourceAddress \";\n            const addQuote = this._sourceAddr.indexOf(':') != -1;\n            if(addQuote)\n            {\n                s += \"\\\"\";\n            }\n            s += this._sourceAddr;\n            if(addQuote)\n            {\n                s += \"\\\"\";\n            }\n        }\n        return s;\n    }\n\n    compareTo(p)\n    {\n        if(this === p)\n        {\n            return 0;\n        }\n\n        if(p === null)\n        {\n            return 1;\n        }\n\n        if(!(p instanceof IPEndpointI))\n        {\n            return this.type() < p.type() ? -1 : 1;\n        }\n\n        if(this._port < p._port)\n        {\n            return -1;\n        }\n        else if(p._port < this._port)\n        {\n            return 1;\n        }\n\n        if(this._host != p._host)\n        {\n            return this._host < p._host ? -1 : 1;\n        }\n\n        if(this._sourceAddr != p._sourceAddr)\n        {\n            return this._sourceAddr < p._sourceAddr ? -1 : 1;\n        }\n\n        if(this._connectionId != p._connectionId)\n        {\n            return this._connectionId < p._connectionId ? -1 : 1;\n        }\n\n        return 0;\n    }\n\n    getAddress()\n    {\n        return new Address(this._host, this._port);\n    }\n\n    //\n    // Convert the endpoint to its Connector string form\n    //\n    toConnectorString()\n    {\n        return this._host + \":\" + this._port;\n    }\n\n    streamWriteImpl(s)\n    {\n        s.writeString(this._host);\n        s.writeInt(this._port);\n    }\n\n    hashInit(h)\n    {\n        h = HashUtil.addNumber(h, this.type());\n        h = HashUtil.addString(h, this._host);\n        h = HashUtil.addNumber(h, this._port);\n        h = HashUtil.addString(h, this._sourceAddr);\n        h = HashUtil.addString(h, this._connectionId);\n        return h;\n    }\n\n    fillEndpointInfo(info)\n    {\n        info.type = () => this.type();\n        info.datagram = () => this.datagram();\n        info.secure = () => this.secure();\n        info.host = this._host;\n        info.port = this._port;\n        info.sourceAddress = this._sourceAddr;\n    }\n\n    initWithOptions(args, oaEndpoint)\n    {\n        super.initWithOptions(args);\n\n        if(this._host === null || this._host.length === 0)\n        {\n            this._host = this._instance.defaultHost();\n        }\n        else if(this._host == \"*\")\n        {\n            if(oaEndpoint)\n            {\n                this._host = \"\";\n            }\n            else\n            {\n                throw new EndpointParseException(\"`-h *' not valid for proxy endpoint `\" + this + \"'\");\n            }\n        }\n\n        if(this._host === null)\n        {\n            this._host = \"\";\n        }\n\n        if(this._sourceAddr === null)\n        {\n            if(!oaEndpoint)\n            {\n                this._sourceAddr = this._instance.defaultSourceAddress();\n            }\n        }\n        else if(oaEndpoint)\n        {\n            throw new EndpointParseException(\"`--sourceAddress not valid for object adapter endpoint `\" + this + \"'\");\n        }\n    }\n\n    initWithStream(s)\n    {\n        this._host = s.readString();\n        this._port = s.readInt();\n    }\n\n    checkOption(option, argument, str)\n    {\n        if(option === \"-h\")\n        {\n            if(argument === null)\n            {\n                throw new EndpointParseException(\"no argument provided for -h option in endpoint \" + str);\n            }\n\n            this._host = argument;\n        }\n        else if(option === \"-p\")\n        {\n            if(argument === null)\n            {\n                throw new EndpointParseException(\"no argument provided for -p option in endpoint \" + str);\n            }\n\n            try\n            {\n                this._port = StringUtil.toInt(argument);\n            }\n            catch(ex)\n            {\n                throw new EndpointParseException(\"invalid port value `\" + argument + \"' in endpoint \" + str);\n            }\n\n            if(this._port < 0 || this._port > 65535)\n            {\n                throw new EndpointParseException(\"port value `\" + argument + \"' out of range in endpoint \" + str);\n            }\n        }\n        else if(option === \"--sourceAddress\")\n        {\n            if(argument === null)\n            {\n                throw new EndpointParseException(\"no argument provided for --sourceAddress option in endpoint \" + str);\n            }\n\n            this._sourceAddr = argument;\n        }\n        else\n        {\n            return false;\n        }\n        return true;\n    }\n}\n\nIce.IPEndpointI = IPEndpointI;\nmodule.exports.Ice = Ice;\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/IPEndpointI.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/Ice.js":
/*!*****************************************!*\
  !*** ./node_modules/ice/src/Ice/Ice.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/BatchRequestQueue */ \"./node_modules/ice/src/Ice/BatchRequestQueue.js\");\n__webpack_require__(/*! ../Ice/Buffer */ \"./node_modules/ice/src/Ice/Buffer.js\");\n__webpack_require__(/*! ../Ice/BuiltinSequences */ \"./node_modules/ice/src/Ice/BuiltinSequences.js\");\n__webpack_require__(/*! ../Ice/Communicator */ \"./node_modules/ice/src/Ice/Communicator.js\");\n__webpack_require__(/*! ../Ice/CommunicatorI */ \"./node_modules/ice/src/Ice/CommunicatorI.js\");\n__webpack_require__(/*! ../Ice/EndpointTypes */ \"./node_modules/ice/src/Ice/EndpointTypes.js\");\n__webpack_require__(/*! ../Ice/Exception */ \"./node_modules/ice/src/Ice/Exception.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/Identity */ \"./node_modules/ice/src/Ice/Identity.js\");\n__webpack_require__(/*! ../Ice/IdentityUtil */ \"./node_modules/ice/src/Ice/IdentityUtil.js\");\n__webpack_require__(/*! ../Ice/Initialize */ \"./node_modules/ice/src/Ice/Initialize.js\");\n__webpack_require__(/*! ../Ice/LocalException */ \"./node_modules/ice/src/Ice/LocalException.js\");\n__webpack_require__(/*! ../Ice/Locator */ \"./node_modules/ice/src/Ice/Locator.js\");\n__webpack_require__(/*! ../Ice/Logger */ \"./node_modules/ice/src/Ice/Logger.js\");\n__webpack_require__(/*! ../Ice/LoggerI */ \"./node_modules/ice/src/Ice/LoggerI.js\");\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/MapUtil */ \"./node_modules/ice/src/Ice/MapUtil.js\");\n__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\");\n__webpack_require__(/*! ../Ice/Object */ \"./node_modules/ice/src/Ice/Object.js\");\n__webpack_require__(/*! ../Ice/ObjectPrx */ \"./node_modules/ice/src/Ice/ObjectPrx.js\");\n__webpack_require__(/*! ../Ice/Process */ \"./node_modules/ice/src/Ice/Process.js\");\n__webpack_require__(/*! ../Ice/ProcessLogger */ \"./node_modules/ice/src/Ice/ProcessLogger.js\");\n__webpack_require__(/*! ../Ice/Promise */ \"./node_modules/ice/src/Ice/Promise.js\");\n__webpack_require__(/*! ../Ice/Properties */ \"./node_modules/ice/src/Ice/Properties.js\");\n__webpack_require__(/*! ../Ice/PropertiesI */ \"./node_modules/ice/src/Ice/PropertiesI.js\");\n__webpack_require__(/*! ../Ice/Protocol */ \"./node_modules/ice/src/Ice/Protocol.js\");\n__webpack_require__(/*! ../Ice/Router */ \"./node_modules/ice/src/Ice/Router.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\n__webpack_require__(/*! ../Ice/ToStringMode */ \"./node_modules/ice/src/Ice/ToStringMode.js\");\n__webpack_require__(/*! ../Ice/UnknownSlicedValue */ \"./node_modules/ice/src/Ice/UnknownSlicedValue.js\");\n__webpack_require__(/*! ../Ice/Value */ \"./node_modules/ice/src/Ice/Value.js\");\n__webpack_require__(/*! ../Ice/Version */ \"./node_modules/ice/src/Ice/Version.js\");\n\nmodule.exports.Ice = __webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice;\nmodule.exports.IceMX = __webpack_require__(/*! ../Ice/Metrics */ \"./node_modules/ice/src/Ice/Metrics.js\").IceMX;\nmodule.exports.IceSSL = __webpack_require__(/*! ../Ice/EndpointInfo */ \"./node_modules/ice/src/Ice/EndpointInfo.js\").IceSSL;\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/Ice.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/Identity.js":
/*!**********************************************!*\
  !*** ./node_modules/ice/src/Ice/Identity.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n//\n// Ice version 3.7.10\n//\n// <auto-generated>\n//\n// Generated from file `Identity.ice'\n//\n// Warning: do not edit this file.\n//\n// </auto-generated>\n//\n\n/* eslint-disable */\n/* jshint ignore: start */\n\n/* slice2js browser-bundle-skip */\nconst _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\n__webpack_require__(/*! ../Ice/Object */ \"./node_modules/ice/src/Ice/Object.js\");\n__webpack_require__(/*! ../Ice/Value */ \"./node_modules/ice/src/Ice/Value.js\");\n__webpack_require__(/*! ../Ice/Struct */ \"./node_modules/ice/src/Ice/Struct.js\");\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\nconst Ice = _ModuleRegistry.module(\"Ice\");\n\nconst Slice = Ice.Slice;\n/* slice2js browser-bundle-skip-end */\n\n/**\n * The identity of an Ice object. In a proxy, an empty {@link Identity#name} denotes a nil\n * proxy. An identity with an empty {@link Identity#name} and a non-empty {@link Identity#category}\n * is illegal. You cannot add a servant with an empty name to the Active Servant Map.\n *\n * @see ServantLocator\n * @see ObjectAdapter#addServantLocator\n *\n **/\nIce.Identity = class\n{\n    constructor(name = \"\", category = \"\")\n    {\n        this.name = name;\n        this.category = category;\n    }\n\n    _write(ostr)\n    {\n        ostr.writeString(this.name);\n        ostr.writeString(this.category);\n    }\n\n    _read(istr)\n    {\n        this.name = istr.readString();\n        this.category = istr.readString();\n    }\n\n    static get minWireSize()\n    {\n        return  2;\n    }\n};\n\nSlice.defineStruct(Ice.Identity, true, true);\n\nSlice.defineDictionary(Ice, \"ObjectDict\", \"ObjectDictHelper\", \"Ice.Identity\", \"Ice.ObjectHelper\", false, Ice.HashMap.compareEquals, \"Ice.Value\");\n\nSlice.defineSequence(Ice, \"IdentitySeqHelper\", \"Ice.Identity\", false);\n/* slice2js browser-bundle-skip */\nexports.Ice = Ice;\n/* slice2js browser-bundle-skip-end */\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/Identity.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/IdentityUtil.js":
/*!**************************************************!*\
  !*** ./node_modules/ice/src/Ice/IdentityUtil.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nconst Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n\n__webpack_require__(/*! ../Ice/Identity */ \"./node_modules/ice/src/Ice/Identity.js\");\n__webpack_require__(/*! ../Ice/LocalException */ \"./node_modules/ice/src/Ice/LocalException.js\");\n__webpack_require__(/*! ../Ice/StringUtil */ \"./node_modules/ice/src/Ice/StringUtil.js\");\n\nconst Identity = Ice.Identity;\nconst IdentityParseException = Ice.IdentityParseException;\nconst StringUtil = Ice.StringUtil;\n\n/**\n* Converts a string to an object identity.\n*\n* @param s The string to convert.\n*\n* @return The converted object identity.\n**/\nIce.stringToIdentity = function(s)\n{\n    const ident = new Identity();\n\n    //\n    // Find unescaped separator; note that the string may contain an escaped\n    // backslash before the separator.\n    //\n    let slash = -1;\n    let pos = 0;\n    while((pos = s.indexOf('/', pos)) !== -1)\n    {\n        let escapes = 0;\n        while(pos - escapes > 0 && s.charAt(pos - escapes - 1) == '\\\\')\n        {\n            escapes++;\n        }\n\n        //\n        // We ignore escaped escapes\n        //\n        if(escapes % 2 === 0)\n        {\n            if(slash == -1)\n            {\n                slash = pos;\n            }\n            else\n            {\n                //\n                // Extra unescaped slash found.\n                //\n                throw new IdentityParseException(`unescaped backslash in identity \\`${s}'`);\n            }\n        }\n        pos++;\n    }\n\n    if(slash == -1)\n    {\n        ident.category = \"\";\n        try\n        {\n            ident.name = StringUtil.unescapeString(s, 0, s.length, \"/\");\n        }\n        catch(e)\n        {\n            throw new IdentityParseException(`invalid identity name \\`${s}': ${e.toString()}`);\n        }\n    }\n    else\n    {\n        try\n        {\n            ident.category = StringUtil.unescapeString(s, 0, slash, \"/\");\n        }\n        catch(e)\n        {\n            throw new IdentityParseException(`invalid category in identity \\`${s}': ${e.toString()}`);\n        }\n        if(slash + 1 < s.length)\n        {\n            try\n            {\n                ident.name = StringUtil.unescapeString(s, slash + 1, s.length, \"/\");\n            }\n            catch(e)\n            {\n                throw new IdentityParseException(`invalid name in identity \\`${s}': ${e.toString()}`);\n            }\n        }\n        else\n        {\n            ident.name = \"\";\n        }\n    }\n\n    return ident;\n};\n\n/**\n* Converts an object identity to a string.\n*\n* @param ident The object identity to convert.\n*\n* @param toStringMode Specifies if and how non-printable ASCII characters are escaped in the result.\n*\n* @return The string representation of the object identity.\n**/\nIce.identityToString = function(ident, toStringMode = Ice.ToStringMode.Unicode)\n{\n    if(ident.category === null || ident.category.length === 0)\n    {\n        return StringUtil.escapeString(ident.name, \"/\", toStringMode);\n    }\n    else\n    {\n        return StringUtil.escapeString(ident.category, \"/\", toStringMode) + '/' + StringUtil.escapeString(ident.name, \"/\", toStringMode);\n    }\n};\n\n/**\n* Compares the object identities of two proxies.\n*\n* @param lhs A proxy.\n* @param rhs A proxy.\n* @return -1 if the identity in <code>lhs</code> compares\n* less than the identity in <code>rhs</code>; 0 if the identities\n* compare equal; 1, otherwise.\n*\n* @see ProxyIdentityKey\n* @see ProxyIdentityAndFacetKey\n* @see ProxyIdentityAndFacetCompare\n**/\nIce.proxyIdentityCompare = function(lhs, rhs)\n{\n    if(lhs === rhs)\n    {\n        return 0;\n    }\n    else if(lhs === null && rhs !== null)\n    {\n        return -1;\n    }\n    else if(lhs !== null && rhs === null)\n    {\n        return 1;\n    }\n    else\n    {\n        const lhsIdentity = lhs.ice_getIdentity();\n        const rhsIdentity = rhs.ice_getIdentity();\n        const n = lhsIdentity.name.localeCompare(rhsIdentity.name);\n        return (n !== 0) ? n : lhsIdentity.category.localeCompare(rhsIdentity.category);\n    }\n};\n\n/**\n* Compares the object identities and facets of two proxies.\n*\n* @param lhs A proxy.\n* @param rhs A proxy.\n* @return -1 if the identity and facet in <code>lhs</code> compare\n* less than the identity and facet in <code>rhs</code>; 0 if the identities\n* and facets compare equal; 1, otherwise.\n*\n* @see ProxyIdentityAndFacetKey\n* @see ProxyIdentityKey\n* @see ProxyIdentityCompare\n**/\nIce.proxyIdentityAndFacetCompare = function(lhs, rhs)\n{\n    if(lhs === rhs)\n    {\n        return 0;\n    }\n    else if(lhs === null && rhs !== null)\n    {\n        return -1;\n    }\n    else if(lhs !== null && rhs === null)\n    {\n        return 1;\n    }\n    else\n    {\n        const lhsIdentity = lhs.ice_getIdentity();\n        const rhsIdentity = rhs.ice_getIdentity();\n        let n = lhsIdentity.name.localeCompare(rhsIdentity.name);\n        if(n !== 0)\n        {\n            return n;\n        }\n        n = lhsIdentity.category.localeCompare(rhsIdentity.category);\n        if(n !== 0)\n        {\n            return n;\n        }\n\n        const lhsFacet = lhs.ice_getFacet();\n        const rhsFacet = rhs.ice_getFacet();\n        if(lhsFacet === null && rhsFacet === null)\n        {\n            return 0;\n        }\n        else if(lhsFacet === null)\n        {\n            return -1;\n        }\n        else if(rhsFacet === null)\n        {\n            return 1;\n        }\n        return lhsFacet.localeCompare(rhsFacet);\n    }\n};\n\nmodule.exports.Ice = Ice;\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/IdentityUtil.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/ImplicitContextF.js":
/*!******************************************************!*\
  !*** ./node_modules/ice/src/Ice/ImplicitContextF.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n//\n// Ice version 3.7.10\n//\n// <auto-generated>\n//\n// Generated from file `ImplicitContextF.ice'\n//\n// Warning: do not edit this file.\n//\n// </auto-generated>\n//\n\n/* eslint-disable */\n/* jshint ignore: start */\n\n/* slice2js browser-bundle-skip */\nconst _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\nconst Ice = _ModuleRegistry.module(\"Ice\");\n\nconst Slice = Ice.Slice;\n/* slice2js browser-bundle-skip-end */\n/* slice2js browser-bundle-skip */\nexports.Ice = Ice;\n/* slice2js browser-bundle-skip-end */\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/ImplicitContextF.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/ImplicitContextI.js":
/*!******************************************************!*\
  !*** ./node_modules/ice/src/Ice/ImplicitContextI.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nconst Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n\n__webpack_require__(/*! ../Ice/Current */ \"./node_modules/ice/src/Ice/Current.js\");\n__webpack_require__(/*! ../Ice/LocalException */ \"./node_modules/ice/src/Ice/LocalException.js\");\n\nconst Context = Ice.Context;\nconst InitializationException = Ice.InitializationException;\n\n//\n// The base class for all ImplicitContext implementations\n//\nclass ImplicitContextI\n{\n    constructor()\n    {\n        this._context = new Context();\n    }\n\n    getContext()\n    {\n        return new Context(this._context);\n    }\n\n    setContext(context)\n    {\n        if(context !== null && context.size > 0)\n        {\n            this._context = new Context(context);\n        }\n        else\n        {\n            this._context.clear();\n        }\n    }\n\n    containsKey(key)\n    {\n        if(key === null)\n        {\n            key = \"\";\n        }\n\n        return this._context.has(key);\n    }\n\n    get(key)\n    {\n        if(key === null)\n        {\n            key = \"\";\n        }\n\n        let val = this._context.get(key);\n        if(val === null)\n        {\n            val = \"\";\n        }\n\n        return val;\n    }\n\n    put(key, value)\n    {\n        if(key === null)\n        {\n            key = \"\";\n        }\n        if(value === null)\n        {\n            value = \"\";\n        }\n\n        let oldVal = this._context.get(key);\n        if(oldVal === null)\n        {\n            oldVal = \"\";\n        }\n\n        this._context.set(key, value);\n\n        return oldVal;\n    }\n\n    remove(key)\n    {\n        if(key === null)\n        {\n            key = \"\";\n        }\n\n        let val = this._context.get(key);\n        this._context.delete(key);\n\n        if(val === null)\n        {\n            val = \"\";\n        }\n        return val;\n    }\n\n    write(prxContext, os)\n    {\n        if(prxContext.size === 0)\n        {\n            Ice.ContextHelper.write(os, this._context);\n        }\n        else\n        {\n            let ctx = null;\n            if(this._context.size === 0)\n            {\n                ctx = prxContext;\n            }\n            else\n            {\n                ctx = new Context(this._context);\n                for(const [key, value] of prxContext)\n                {\n                    ctx.set(key, value);\n                }\n            }\n            Ice.ContextHelper.write(os, ctx);\n        }\n    }\n\n    static create(kind)\n    {\n        if(kind.length === 0 || kind === \"None\")\n        {\n            return null;\n        }\n        else if(kind === \"Shared\")\n        {\n            return new ImplicitContextI();\n        }\n        else\n        {\n            throw new InitializationException(\"'\" + kind + \"' is not a valid value for Ice.ImplicitContext\");\n        }\n    }\n}\n\nIce.ImplicitContextI = ImplicitContextI;\nmodule.exports.Ice = Ice;\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/ImplicitContextI.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/IncomingAsync.js":
/*!***************************************************!*\
  !*** ./node_modules/ice/src/Ice/IncomingAsync.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nconst Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n\n__webpack_require__(/*! ../Ice/BuiltinSequences */ \"./node_modules/ice/src/Ice/BuiltinSequences.js\");\n__webpack_require__(/*! ../Ice/Connection */ \"./node_modules/ice/src/Ice/Connection.js\");\n__webpack_require__(/*! ../Ice/Current */ \"./node_modules/ice/src/Ice/Current.js\");\n__webpack_require__(/*! ../Ice/Debug */ \"./node_modules/ice/src/Ice/Debug.js\");\n__webpack_require__(/*! ../Ice/Exception */ \"./node_modules/ice/src/Ice/Exception.js\");\n__webpack_require__(/*! ../Ice/Identity */ \"./node_modules/ice/src/Ice/Identity.js\");\n__webpack_require__(/*! ../Ice/LocalException */ \"./node_modules/ice/src/Ice/LocalException.js\");\n__webpack_require__(/*! ../Ice/Protocol */ \"./node_modules/ice/src/Ice/Protocol.js\");\n__webpack_require__(/*! ../Ice/Stream */ \"./node_modules/ice/src/Ice/Stream.js\");\n__webpack_require__(/*! ../Ice/StringUtil */ \"./node_modules/ice/src/Ice/StringUtil.js\");\n\nconst OutputStream = Ice.OutputStream;\nconst Current = Ice.Current;\nconst Debug = Ice.Debug;\nconst Context = Ice.Context;\nconst Identity = Ice.Identity;\nconst Protocol = Ice.Protocol;\nconst StringUtil = Ice.StringUtil;\n\nclass IncomingAsync\n{\n    constructor(instance, connection, adapter, response, requestId)\n    {\n        this._instance = instance;\n        this._response = response;\n        this._connection = connection;\n        this._format = Ice.FormatType.DefaultFormat;\n\n        this._current = new Current();\n        this._current.id = new Identity();\n        this._current.adapter = adapter;\n        this._current.con = this._connection;\n        this._current.requestId = requestId;\n\n        this._servant = null;\n        this._locator = null;\n        this._cookie = {value: null};\n\n        this._os = null;\n        this._is = null;\n    }\n\n    startWriteParams()\n    {\n        if(!this._response)\n        {\n            throw new Ice.MarshalException(\"can't marshal out parameters for oneway dispatch\");\n        }\n\n        Debug.assert(this._current.encoding !== null); // Encoding for reply is known.\n        this._os = new OutputStream(this._instance, Protocol.currentProtocolEncoding);\n        this._os.writeBlob(Protocol.replyHdr);\n        this._os.writeInt(this._current.requestId);\n        this._os.writeByte(0);\n        this._os.startEncapsulation(this._current.encoding, this._format);\n        return this._os;\n    }\n\n    endWriteParams()\n    {\n        if(this._response)\n        {\n            this._os.endEncapsulation();\n        }\n    }\n\n    writeEmptyParams()\n    {\n        if(this._response)\n        {\n            Debug.assert(this._current.encoding !== null); // Encoding for reply is known.\n            this._os = new OutputStream(this._instance, Protocol.currentProtocolEncoding);\n            this._os.writeBlob(Protocol.replyHdr);\n            this._os.writeInt(this._current.requestId);\n            this._os.writeByte(Protocol.replyOK);\n            this._os.writeEmptyEncapsulation(this._current.encoding);\n        }\n    }\n\n    writeParamEncaps(v, ok)\n    {\n        if(this._response)\n        {\n            Debug.assert(this._current.encoding !== null); // Encoding for reply is known.\n            this._os = new OutputStream(this._instance, Protocol.currentProtocolEncoding);\n            this._os.writeBlob(Protocol.replyHdr);\n            this._os.writeInt(this._current.requestId);\n            this._os.writeByte(ok ? Protocol.replyOK : Protocol.replyUserException);\n            if(v === null || v.length === 0)\n            {\n                this._os.writeEmptyEncapsulation(this._current.encoding);\n            }\n            else\n            {\n                this._os.writeEncapsulation(v);\n            }\n        }\n    }\n\n    setFormat(format)\n    {\n        this._format = format;\n    }\n\n    warning(ex)\n    {\n        Debug.assert(this._instance !== null);\n\n        const s = [];\n        s.push(\"dispatch exception:\");\n        s.push(\"\\nidentity: \" + Ice.identityToString(this._current.id, this._instance.toStringMode()));\n        s.push(\"\\nfacet: \" + StringUtil.escapeString(this._current.facet, \"\", this._instance.toStringMode()));\n        s.push(\"\\noperation: \" + this._current.operation);\n        if(this._connection !== null)\n        {\n            try\n            {\n                for(let p = this._connection.getInfo(); p; p = p.underlying)\n                {\n                    if(p instanceof Ice.IPConnectionInfo)\n                    {\n                        s.push(\"\\nremote host: \" + p.remoteAddress + \" remote port: \" + p.remotePort);\n                    }\n                }\n            }\n            catch(exc)\n            {\n                // Ignore.\n            }\n        }\n        if(ex.stack)\n        {\n            s.push(\"\\n\");\n            s.push(ex.stack);\n        }\n        this._instance.initializationData().logger.warning(s.join(\"\"));\n    }\n\n    handleException(ex, amd)\n    {\n        Debug.assert(this._connection !== null);\n\n        const props = this._instance.initializationData().properties;\n        if(ex instanceof Ice.RequestFailedException)\n        {\n            if(ex.id === null)\n            {\n                ex.id = this._current.id;\n            }\n\n            if(ex.facet === null)\n            {\n                ex.facet = this._current.facet;\n            }\n\n            if(ex.operation === null || ex.operation.length === 0)\n            {\n                ex.operation = this._current.operation;\n            }\n\n            if(props.getPropertyAsIntWithDefault(\"Ice.Warn.Dispatch\", 1) > 1)\n            {\n                this.warning(ex);\n            }\n\n            if(this._response)\n            {\n                this._os = new OutputStream(this._instance, Protocol.currentProtocolEncoding);\n                this._os.writeBlob(Protocol.replyHdr);\n                this._os.writeInt(this._current.requestId);\n                if(ex instanceof Ice.ObjectNotExistException)\n                {\n                    this._os.writeByte(Protocol.replyObjectNotExist);\n                }\n                else if(ex instanceof Ice.FacetNotExistException)\n                {\n                    this._os.writeByte(Protocol.replyFacetNotExist);\n                }\n                else if(ex instanceof Ice.OperationNotExistException)\n                {\n                    this._os.writeByte(Protocol.replyOperationNotExist);\n                }\n                else\n                {\n                    Debug.assert(false);\n                }\n                ex.id._write(this._os);\n\n                //\n                // For compatibility with the old FacetPath.\n                //\n                if(ex.facet === null || ex.facet.length === 0)\n                {\n                    Ice.StringSeqHelper.write(this._os, null);\n                }\n                else\n                {\n                    Ice.StringSeqHelper.write(this._os, [ex.facet]);\n                }\n\n                this._os.writeString(ex.operation);\n\n                this._connection.sendResponse(this._os);\n            }\n            else\n            {\n                this._connection.sendNoResponse();\n            }\n        }\n        else if(ex instanceof Ice.UnknownLocalException)\n        {\n            if(props.getPropertyAsIntWithDefault(\"Ice.Warn.Dispatch\", 1) > 0)\n            {\n                this.warning(ex);\n            }\n\n            if(this._response)\n            {\n                this._os = new OutputStream(this._instance, Protocol.currentProtocolEncoding);\n                this._os.writeBlob(Protocol.replyHdr);\n                this._os.writeInt(this._current.requestId);\n                this._os.writeByte(Protocol.replyUnknownLocalException);\n                this._os.writeString(ex.unknown);\n                this._connection.sendResponse(this._os);\n            }\n            else\n            {\n                this._connection.sendNoResponse();\n            }\n        }\n        else if(ex instanceof Ice.UnknownUserException)\n        {\n            if(props.getPropertyAsIntWithDefault(\"Ice.Warn.Dispatch\", 1) > 0)\n            {\n                this.warning(ex);\n            }\n\n            if(this._response)\n            {\n                this._os = new OutputStream(this._instance, Protocol.currentProtocolEncoding);\n                this._os.writeBlob(Protocol.replyHdr);\n                this._os.writeInt(this._current.requestId);\n                this._os.writeByte(Protocol.replyUnknownUserException);\n                this._os.writeString(ex.unknown);\n                this._connection.sendResponse(this._os);\n            }\n            else\n            {\n                this._connection.sendNoResponse();\n            }\n        }\n        else if(ex instanceof Ice.UnknownException)\n        {\n            if(props.getPropertyAsIntWithDefault(\"Ice.Warn.Dispatch\", 1) > 0)\n            {\n                this.warning(ex);\n            }\n\n            if(this._response)\n            {\n                this._os = new OutputStream(this._instance, Protocol.currentProtocolEncoding);\n                this._os.writeBlob(Protocol.replyHdr);\n                this._os.writeInt(this._current.requestId);\n                this._os.writeByte(Protocol.replyUnknownException);\n                this._os.writeString(ex.unknown);\n                this._connection.sendResponse(this._os);\n            }\n            else\n            {\n                this._connection.sendNoResponse();\n            }\n        }\n        else if(ex instanceof Ice.LocalException)\n        {\n            if(props.getPropertyAsIntWithDefault(\"Ice.Warn.Dispatch\", 1) > 0)\n            {\n                this.warning(ex);\n            }\n\n            if(this._response)\n            {\n                this._os = new OutputStream(this._instance, Protocol.currentProtocolEncoding);\n                this._os.writeBlob(Protocol.replyHdr);\n                this._os.writeInt(this._current.requestId);\n                this._os.writeByte(Protocol.replyUnknownLocalException);\n                // this._os.writeString(ex.toString());\n                const s = [ex.ice_id()];\n                if(ex.stack)\n                {\n                    s.push(\"\\n\");\n                    s.push(ex.stack);\n                }\n                this._os.writeString(s.join(\"\"));\n                this._connection.sendResponse(this._os);\n            }\n            else\n            {\n                this._connection.sendNoResponse();\n            }\n        }\n        else if(ex instanceof Ice.UserException)\n        {\n            if(this._response)\n            {\n                this._os = new OutputStream(this._instance, Protocol.currentProtocolEncoding);\n                this._os.writeBlob(Protocol.replyHdr);\n                this._os.writeInt(this._current.requestId);\n                this._os.writeByte(Protocol.replyUserException);\n                this._os.startEncapsulation(this._current.encoding, this._format);\n                this._os.writeException(ex);\n                this._os.endEncapsulation();\n                this._connection.sendResponse(this._os);\n            }\n            else\n            {\n                this._connection.sendNoResponse();\n            }\n        }\n        else\n        {\n            if(props.getPropertyAsIntWithDefault(\"Ice.Warn.Dispatch\", 1) > 0)\n            {\n                this.warning(ex);\n            }\n\n            if(this._response)\n            {\n                this._os = new OutputStream(this._instance, Protocol.currentProtocolEncoding);\n                this._os.writeBlob(Protocol.replyHdr);\n                this._os.writeInt(this._current.requestId);\n                this._os.writeByte(Protocol.replyUnknownException);\n                this._os.writeString(ex.toString() + (ex.stack ? \"\\n\" + ex.stack : \"\"));\n                this._connection.sendResponse(this._os);\n            }\n            else\n            {\n                this._connection.sendNoResponse();\n            }\n        }\n\n        this._connection = null;\n    }\n\n    invoke(servantManager, stream)\n    {\n        this._is = stream;\n\n        //\n        // Read the current.\n        //\n        this._current.id._read(this._is);\n\n        //\n        // For compatibility with the old FacetPath.\n        //\n        const facetPath = Ice.StringSeqHelper.read(this._is);\n        if(facetPath.length > 0)\n        {\n            if(facetPath.length > 1)\n            {\n                throw new Ice.MarshalException();\n            }\n            this._current.facet = facetPath[0];\n        }\n        else\n        {\n            this._current.facet = \"\";\n        }\n\n        this._current.operation = this._is.readString();\n        this._current.mode = Ice.OperationMode.valueOf(this._is.readByte());\n        this._current.ctx = new Context();\n        let sz = this._is.readSize();\n        while(sz-- > 0)\n        {\n            this._current.ctx.set(this._is.readString(), this._is.readString());\n        }\n\n        //\n        // Don't put the code above into the try block below. Exceptions\n        // in the code above are considered fatal, and must propagate to\n        // the caller of this operation.\n        //\n        if(servantManager !== null)\n        {\n            this._servant = servantManager.findServant(this._current.id, this._current.facet);\n            if(this._servant === null)\n            {\n                this._locator = servantManager.findServantLocator(this._current.id.category);\n                if(this._locator === null && this._current.id.category.length > 0)\n                {\n                    this._locator = servantManager.findServantLocator(\"\");\n                }\n\n                if(this._locator !== null)\n                {\n                    try\n                    {\n                        this._servant = this._locator.locate(this._current, this._cookie);\n                    }\n                    catch(ex)\n                    {\n                        this.skipReadParams(); // Required for batch requests.\n                        this.handleException(ex, false);\n                        return;\n                    }\n                }\n            }\n        }\n\n        if(this._servant === null)\n        {\n            try\n            {\n                if(servantManager !== null && servantManager.hasServant(this._current.id))\n                {\n                    throw new Ice.FacetNotExistException(this._current.id, this._current.facet,\n                                                         this._current.operation);\n                }\n                else\n                {\n                    throw new Ice.ObjectNotExistException(this._current.id, this._current.facet,\n                                                          this._current.operation);\n                }\n\n            }\n            catch(ex)\n            {\n                this.skipReadParams(); // Required for batch requests.\n                this.handleException(ex, false);\n                return;\n            }\n        }\n\n        try\n        {\n            Debug.assert(this._servant !== null);\n            const promise = this._servant._iceDispatch(this, this._current);\n            if(promise !== null)\n            {\n                promise.then(() => this.completed(null, true),\n                             ex => this.completed(ex, true));\n                return;\n            }\n\n            Debug.assert(!this._response || this._os !== null);\n            this.completed(null, false);\n        }\n        catch(ex)\n        {\n            this.completed(ex, false);\n        }\n    }\n\n    startReadParams()\n    {\n        //\n        // Remember the encoding used by the input parameters, we'll\n        // encode the response parameters with the same encoding.\n        //\n        this._current.encoding = this._is.startEncapsulation();\n        return this._is;\n    }\n\n    endReadParams()\n    {\n        this._is.endEncapsulation();\n    }\n\n    readEmptyParams()\n    {\n        this._current.encoding = this._is.skipEmptyEncapsulation();\n    }\n\n    readParamEncaps()\n    {\n        this._current.encoding = new Ice.EncodingVersion();\n        return this._is.readEncapsulation(this._current.encoding);\n    }\n\n    skipReadParams()\n    {\n        this._current.encoding = this._is.skipEncapsulation();\n    }\n\n    completed(exc, amd)\n    {\n        try\n        {\n            if(this._locator !== null)\n            {\n                Debug.assert(this._locator !== null && this._servant !== null);\n                try\n                {\n                    this._locator.finished(this._current, this._servant, this._cookie.value);\n                }\n                catch(ex)\n                {\n                    this.handleException(ex, amd);\n                    return;\n                }\n            }\n\n            Debug.assert(this._connection !== null);\n\n            if(exc !== null)\n            {\n                this.handleException(exc, amd);\n            }\n            else if(this._response)\n            {\n                this._connection.sendResponse(this._os);\n            }\n            else\n            {\n                this._connection.sendNoResponse();\n            }\n        }\n        catch(ex)\n        {\n            if(ex instanceof Ice.LocalException)\n            {\n                this._connection.invokeException(ex, 1);\n            }\n            else\n            {\n                throw ex;\n            }\n        }\n        this._connection = null;\n    }\n\n}\n\nIce.IncomingAsync = IncomingAsync;\nmodule.exports.Ice = Ice;\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/IncomingAsync.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/Initialize.js":
/*!************************************************!*\
  !*** ./node_modules/ice/src/Ice/Initialize.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nconst Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n\n__webpack_require__(/*! ../Ice/Communicator */ \"./node_modules/ice/src/Ice/Communicator.js\");\n__webpack_require__(/*! ../Ice/LocalException */ \"./node_modules/ice/src/Ice/LocalException.js\");\n__webpack_require__(/*! ../Ice/Properties */ \"./node_modules/ice/src/Ice/Properties.js\");\n__webpack_require__(/*! ../Ice/Protocol */ \"./node_modules/ice/src/Ice/Protocol.js\");\n\nconst Protocol = Ice.Protocol;\n\n//\n// Ice.InitializationData\n//\nIce.InitializationData = class\n{\n    constructor()\n    {\n        this.properties = null;\n        this.logger = null;\n        this.valueFactoryManager = null;\n    }\n\n    clone()\n    {\n        const r = new Ice.InitializationData();\n        r.properties = this.properties;\n        r.logger = this.logger;\n        r.valueFactoryManager = this.valueFactoryManager;\n        return r;\n    }\n};\n\n//\n// Ice.initialize()\n//\nIce.initialize = function(arg1, arg2)\n{\n    let args = null;\n    let initData = null;\n\n    if(arg1 instanceof Array)\n    {\n        args = arg1;\n    }\n    else if(arg1 instanceof Ice.InitializationData)\n    {\n        initData = arg1;\n    }\n    else if(arg1 !== undefined && arg1 !== null)\n    {\n        throw new Ice.InitializationException(\"invalid argument to initialize\");\n    }\n\n    if(arg2 !== undefined && arg2 !== null)\n    {\n        if(arg2 instanceof Ice.InitializationData && initData === null)\n        {\n            initData = arg2;\n        }\n        else\n        {\n            throw new Ice.InitializationException(\"invalid argument to initialize\");\n        }\n    }\n\n    if(initData === null)\n    {\n        initData = new Ice.InitializationData();\n    }\n    else\n    {\n        initData = initData.clone();\n    }\n    initData.properties = Ice.createProperties(args, initData.properties);\n\n    const result = new Ice.Communicator(initData);\n    result.finishSetup(null);\n    return result;\n};\n\n//\n// Ice.createProperties()\n//\nIce.createProperties = function(args, defaults)\n{\n    return new Ice.Properties(args, defaults);\n};\n\nIce.currentProtocol = function()\n{\n    return Protocol.currentProtocol.clone();\n};\n\nIce.currentEncoding = function()\n{\n    return Protocol.currentEncoding.clone();\n};\n\nIce.stringVersion = function()\n{\n    return \"3.7.10\"; // \"A.B.C\", with A=major, B=minor, C=patch\n};\n\nIce.intVersion = function()\n{\n    return 30710; // AABBCC, with AA=major, BB=minor, CC=patch\n};\n\nmodule.exports.Ice = Ice;\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/Initialize.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/Instance.js":
/*!**********************************************!*\
  !*** ./node_modules/ice/src/Ice/Instance.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nconst Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n\n__webpack_require__(/*! ../Ice/ACM */ \"./node_modules/ice/src/Ice/ACM.js\");\n__webpack_require__(/*! ../Ice/AsyncResultBase */ \"./node_modules/ice/src/Ice/AsyncResultBase.js\");\n__webpack_require__(/*! ../Ice/Debug */ \"./node_modules/ice/src/Ice/Debug.js\");\n__webpack_require__(/*! ../Ice/DefaultsAndOverrides */ \"./node_modules/ice/src/Ice/DefaultsAndOverrides.js\");\n__webpack_require__(/*! ../Ice/EndpointFactoryManager */ \"./node_modules/ice/src/Ice/EndpointFactoryManager.js\");\n__webpack_require__(/*! ../Ice/EndpointInfo */ \"./node_modules/ice/src/Ice/EndpointInfo.js\");\n__webpack_require__(/*! ../Ice/Exception */ \"./node_modules/ice/src/Ice/Exception.js\");\n__webpack_require__(/*! ../Ice/IdentityUtil */ \"./node_modules/ice/src/Ice/IdentityUtil.js\");\n__webpack_require__(/*! ../Ice/ImplicitContextI */ \"./node_modules/ice/src/Ice/ImplicitContextI.js\");\n__webpack_require__(/*! ../Ice/LocalException */ \"./node_modules/ice/src/Ice/LocalException.js\");\n__webpack_require__(/*! ../Ice/LocatorManager */ \"./node_modules/ice/src/Ice/LocatorManager.js\");\n__webpack_require__(/*! ../Ice/ObjectAdapterFactory */ \"./node_modules/ice/src/Ice/ObjectAdapterFactory.js\");\n__webpack_require__(/*! ../Ice/OutgoingConnectionFactory */ \"./node_modules/ice/src/Ice/OutgoingConnectionFactory.js\");\n__webpack_require__(/*! ../Ice/ProcessLogger */ \"./node_modules/ice/src/Ice/ProcessLogger.js\");\n__webpack_require__(/*! ../Ice/Promise */ \"./node_modules/ice/src/Ice/Promise.js\");\n__webpack_require__(/*! ../Ice/Properties */ \"./node_modules/ice/src/Ice/Properties.js\");\n__webpack_require__(/*! ../Ice/ProtocolInstance */ \"./node_modules/ice/src/Ice/ProtocolInstance.js\");\n__webpack_require__(/*! ../Ice/ProxyFactory */ \"./node_modules/ice/src/Ice/ProxyFactory.js\");\n__webpack_require__(/*! ../Ice/Reference */ \"./node_modules/ice/src/Ice/Reference.js\");\n__webpack_require__(/*! ../Ice/RequestHandlerFactory */ \"./node_modules/ice/src/Ice/RequestHandlerFactory.js\");\n__webpack_require__(/*! ../Ice/RetryQueue */ \"./node_modules/ice/src/Ice/RetryQueue.js\");\n__webpack_require__(/*! ../Ice/RouterManager */ \"./node_modules/ice/src/Ice/RouterManager.js\");\n__webpack_require__(/*! ../Ice/TcpEndpointFactory */ \"./node_modules/ice/src/Ice/TcpEndpointFactory.js\");\n__webpack_require__(/*! ../Ice/Timer */ \"./node_modules/ice/src/Ice/Timer.js\");\n__webpack_require__(/*! ../Ice/ToStringMode */ \"./node_modules/ice/src/Ice/ToStringMode.js\");\n__webpack_require__(/*! ../Ice/TraceLevels */ \"./node_modules/ice/src/Ice/TraceLevels.js\");\n__webpack_require__(/*! ../Ice/ValueFactoryManagerI */ \"./node_modules/ice/src/Ice/ValueFactoryManagerI.js\");\n__webpack_require__(/*! ../Ice/WSEndpointFactory */ \"./node_modules/ice/src/Ice/WSEndpointFactory.js\");\n\nconst ACMConfig = Ice.ACMConfig;\nconst AsyncResultBase = Ice.AsyncResultBase;\nconst Debug = Ice.Debug;\nconst DefaultsAndOverrides = Ice.DefaultsAndOverrides;\nconst EndpointFactoryManager = Ice.EndpointFactoryManager;\nconst ImplicitContextI = Ice.ImplicitContextI;\nconst LocatorManager = Ice.LocatorManager;\nconst ObjectAdapterFactory = Ice.ObjectAdapterFactory;\nconst OutgoingConnectionFactory = Ice.OutgoingConnectionFactory;\nconst Properties = Ice.Properties;\nconst ProxyFactory = Ice.ProxyFactory;\nconst ReferenceFactory = Ice.ReferenceFactory;\nconst RequestHandlerFactory = Ice.RequestHandlerFactory;\nconst RetryQueue = Ice.RetryQueue;\nconst RouterManager = Ice.RouterManager;\nconst Timer = Ice.Timer;\nconst TraceLevels = Ice.TraceLevels;\nconst ValueFactoryManagerI = Ice.ValueFactoryManagerI;\n\nconst StateActive = 0;\nconst StateDestroyInProgress = 1;\nconst StateDestroyed = 2;\n\n//\n// Instance - only for use by Communicator\n//\nclass Instance\n{\n    constructor(initData)\n    {\n        this._state = StateActive;\n        this._initData = initData;\n\n        this._traceLevels = null;\n        this._defaultsAndOverrides = null;\n        this._messageSizeMax = 0;\n        this._batchAutoFlushSize = 0;\n        this._clientACM = null;\n        this._toStringMode = Ice.ToStringMode.Unicode;\n        this._implicitContext = null;\n        this._routerManager = null;\n        this._locatorManager = null;\n        this._referenceFactory = null;\n        this._requestHandlerFactory = null;\n        this._proxyFactory = null;\n        this._outgoingConnectionFactory = null;\n        this._objectAdapterFactory = null;\n        this._retryQueue = null;\n        this._endpointHostResolver = null;\n        this._endpointFactoryManager = null;\n        this._objectFactoryMap = null;\n    }\n\n    initializationData()\n    {\n        //\n        // No check for destruction. It must be possible to access the\n        // initialization data after destruction.\n        //\n        // This value is immutable.\n        //\n        return this._initData;\n    }\n\n    traceLevels()\n    {\n        // This value is immutable.\n        Debug.assert(this._traceLevels !== null);\n        return this._traceLevels;\n    }\n\n    defaultsAndOverrides()\n    {\n        // This value is immutable.\n        Debug.assert(this._defaultsAndOverrides !== null);\n        return this._defaultsAndOverrides;\n    }\n\n    routerManager()\n    {\n        if(this._state === StateDestroyed)\n        {\n            throw new Ice.CommunicatorDestroyedException();\n        }\n\n        Debug.assert(this._routerManager !== null);\n        return this._routerManager;\n    }\n\n    locatorManager()\n    {\n        if(this._state === StateDestroyed)\n        {\n            throw new Ice.CommunicatorDestroyedException();\n        }\n\n        Debug.assert(this._locatorManager !== null);\n        return this._locatorManager;\n    }\n\n    referenceFactory()\n    {\n        if(this._state === StateDestroyed)\n        {\n            throw new Ice.CommunicatorDestroyedException();\n        }\n\n        Debug.assert(this._referenceFactory !== null);\n        return this._referenceFactory;\n    }\n\n    requestHandlerFactory()\n    {\n        if(this._state === StateDestroyed)\n        {\n            throw new Ice.CommunicatorDestroyedException();\n        }\n\n        Debug.assert(this._requestHandlerFactory !== null);\n        return this._requestHandlerFactory;\n    }\n\n    proxyFactory()\n    {\n        if(this._state === StateDestroyed)\n        {\n            throw new Ice.CommunicatorDestroyedException();\n        }\n\n        Debug.assert(this._proxyFactory !== null);\n        return this._proxyFactory;\n    }\n\n    outgoingConnectionFactory()\n    {\n        if(this._state === StateDestroyed)\n        {\n            throw new Ice.CommunicatorDestroyedException();\n        }\n\n        Debug.assert(this._outgoingConnectionFactory !== null);\n        return this._outgoingConnectionFactory;\n    }\n\n    objectAdapterFactory()\n    {\n        if(this._state === StateDestroyed)\n        {\n            throw new Ice.CommunicatorDestroyedException();\n        }\n\n        Debug.assert(this._objectAdapterFactory !== null);\n        return this._objectAdapterFactory;\n    }\n\n    retryQueue()\n    {\n        if(this._state === StateDestroyed)\n        {\n            throw new Ice.CommunicatorDestroyedException();\n        }\n\n        Debug.assert(this._retryQueue !== null);\n        return this._retryQueue;\n    }\n\n    timer()\n    {\n        if(this._state === StateDestroyed)\n        {\n            throw new Ice.CommunicatorDestroyedException();\n        }\n\n        Debug.assert(this._timer !== null);\n        return this._timer;\n    }\n\n    endpointFactoryManager()\n    {\n        if(this._state === StateDestroyed)\n        {\n            throw new Ice.CommunicatorDestroyedException();\n        }\n\n        Debug.assert(this._endpointFactoryManager !== null);\n        return this._endpointFactoryManager;\n    }\n\n    messageSizeMax()\n    {\n        // This value is immutable.\n        return this._messageSizeMax;\n    }\n\n    batchAutoFlushSize()\n    {\n        // This value is immutable.\n        return this._batchAutoFlushSize;\n    }\n\n    clientACM()\n    {\n        // This value is immutable.\n        return this._clientACM;\n    }\n\n    toStringMode()\n    {\n        // this value is immutable\n        return this._toStringMode;\n    }\n\n    getImplicitContext()\n    {\n        return this._implicitContext;\n    }\n\n    setDefaultLocator(locator)\n    {\n        if(this._state == StateDestroyed)\n        {\n            throw new Ice.CommunicatorDestroyedException();\n        }\n\n        this._referenceFactory = this._referenceFactory.setDefaultLocator(locator);\n    }\n\n    setDefaultRouter(router)\n    {\n        if(this._state == StateDestroyed)\n        {\n            throw new Ice.CommunicatorDestroyedException();\n        }\n\n        this._referenceFactory = this._referenceFactory.setDefaultRouter(router);\n    }\n\n    setLogger(logger)\n    {\n        this._initData.logger = logger;\n    }\n\n    finishSetup(communicator, promise)\n    {\n        //\n        // If promise == null, it means the caller is requesting a synchronous setup.\n        // Otherwise, we resolve the promise after all initialization is complete.\n        //\n        try\n        {\n            if(this._initData.properties === null)\n            {\n                this._initData.properties = Properties.createProperties();\n            }\n\n            if(Ice._oneOfDone === undefined)\n            {\n                Ice._printStackTraces =\n                    this._initData.properties.getPropertyAsIntWithDefault(\"Ice.PrintStackTraces\", 0) > 0;\n\n                Ice._oneOfDone = true;\n            }\n\n            if(this._initData.logger === null)\n            {\n                this._initData.logger = Ice.getProcessLogger();\n            }\n\n            this._traceLevels = new TraceLevels(this._initData.properties);\n\n            this._defaultsAndOverrides = new DefaultsAndOverrides(this._initData.properties, this._initData.logger);\n\n            const defMessageSizeMax = 1024;\n            let num = this._initData.properties.getPropertyAsIntWithDefault(\"Ice.MessageSizeMax\", defMessageSizeMax);\n            if(num < 1 || num > 0x7fffffff / 1024)\n            {\n                this._messageSizeMax = 0x7fffffff;\n            }\n            else\n            {\n                this._messageSizeMax = num * 1024; // Property is in kilobytes, _messageSizeMax in bytes\n            }\n\n            if(this._initData.properties.getProperty(\"Ice.BatchAutoFlushSize\").length === 0 &&\n               this._initData.properties.getProperty(\"Ice.BatchAutoFlush\").length > 0)\n            {\n                if(this._initData.properties.getPropertyAsInt(\"Ice.BatchAutoFlush\") > 0)\n                {\n                    this._batchAutoFlushSize = this._messageSizeMax;\n                }\n            }\n            else\n            {\n                num = this._initData.properties.getPropertyAsIntWithDefault(\"Ice.BatchAutoFlushSize\", 1024); // 1MB\n                if(num < 1)\n                {\n                    this._batchAutoFlushSize = num;\n                }\n                else if(num > 0x7fffffff / 1024)\n                {\n                    this._batchAutoFlushSize = 0x7fffffff;\n                }\n                else\n                {\n                    this._batchAutoFlushSize = num * 1024; // Property is in kilobytes, _batchAutoFlushSize in bytes\n                }\n            }\n\n            this._clientACM = new ACMConfig(this._initData.properties, this._initData.logger, \"Ice.ACM.Client\",\n                                            new ACMConfig(this._initData.properties, this._initData.logger,\n                                                            \"Ice.ACM\", new ACMConfig()));\n\n            const toStringModeStr = this._initData.properties.getPropertyWithDefault(\"Ice.ToStringMode\", \"Unicode\");\n            if(toStringModeStr === \"ASCII\")\n            {\n                this._toStringMode = Ice.ToStringMode.ASCII;\n            }\n            else if(toStringModeStr === \"Compat\")\n            {\n                this._toStringMode = Ice.ToStringMode.Compat;\n            }\n            else if(toStringModeStr !== \"Unicode\")\n            {\n                throw new Ice.InitializationException(\"The value for Ice.ToStringMode must be Unicode, ASCII or Compat\");\n            }\n\n            this._implicitContext =\n                ImplicitContextI.create(this._initData.properties.getProperty(\"Ice.ImplicitContext\"));\n\n            this._routerManager = new RouterManager();\n\n            this._locatorManager = new LocatorManager(this._initData.properties);\n\n            this._referenceFactory = new ReferenceFactory(this, communicator);\n\n            this._requestHandlerFactory = new RequestHandlerFactory(this, communicator);\n\n            this._proxyFactory = new ProxyFactory(this);\n\n            this._endpointFactoryManager = new EndpointFactoryManager(this);\n\n            const tcpInstance = new Ice.ProtocolInstance(this, Ice.TCPEndpointType, \"tcp\", false);\n            const tcpEndpointFactory = new Ice.TcpEndpointFactory(tcpInstance);\n            this._endpointFactoryManager.add(tcpEndpointFactory);\n\n            const wsInstance = new Ice.ProtocolInstance(this, Ice.WSEndpointType, \"ws\", false);\n            const wsEndpointFactory = new Ice.WSEndpointFactory(wsInstance, tcpEndpointFactory.clone(wsInstance));\n            this._endpointFactoryManager.add(wsEndpointFactory);\n\n            const sslInstance = new Ice.ProtocolInstance(this, Ice.SSLEndpointType, \"ssl\", true);\n            const sslEndpointFactory = new Ice.TcpEndpointFactory(sslInstance);\n            this._endpointFactoryManager.add(sslEndpointFactory);\n\n            const wssInstance = new Ice.ProtocolInstance(this, Ice.WSSEndpointType, \"wss\", true);\n            const wssEndpointFactory = new Ice.WSEndpointFactory(wssInstance, sslEndpointFactory.clone(wssInstance));\n            this._endpointFactoryManager.add(wssEndpointFactory);\n\n            this._outgoingConnectionFactory = new OutgoingConnectionFactory(communicator, this);\n\n            if(this._initData.valueFactoryManager === null)\n            {\n                this._initData.valueFactoryManager = new ValueFactoryManagerI();\n            }\n\n            this._objectAdapterFactory = new ObjectAdapterFactory(this, communicator);\n\n            this._retryQueue = new RetryQueue(this);\n            this._timer = new Timer(this._initData.logger);\n\n            const router = Ice.RouterPrx.uncheckedCast(this._proxyFactory.propertyToProxy(\"Ice.Default.Router\"));\n            if(router !== null)\n            {\n                this._referenceFactory = this._referenceFactory.setDefaultRouter(router);\n            }\n\n            const loc = Ice.LocatorPrx.uncheckedCast(this._proxyFactory.propertyToProxy(\"Ice.Default.Locator\"));\n            if(loc !== null)\n            {\n                this._referenceFactory = this._referenceFactory.setDefaultLocator(loc);\n            }\n\n            if(promise !== null)\n            {\n                promise.resolve(communicator);\n            }\n        }\n        catch(ex)\n        {\n            if(promise !== null)\n            {\n                if(ex instanceof Ice.LocalException)\n                {\n                    this.destroy().finally(() => promise.reject(ex));\n                }\n                else\n                {\n                    promise.reject(ex);\n                }\n            }\n            else\n            {\n                if(ex instanceof Ice.LocalException)\n                {\n                    this.destroy();\n                }\n                throw ex;\n            }\n        }\n    }\n\n    //\n    // Only for use by Ice.CommunicatorI\n    //\n    destroy()\n    {\n        const promise = new AsyncResultBase(null, \"destroy\", null, this, null);\n\n        //\n        // If destroy is in progress, wait for it to be done. This is\n        // necessary in case destroy() is called concurrently by\n        // multiple threads.\n        //\n        if(this._state == StateDestroyInProgress)\n        {\n            if(!this._destroyPromises)\n            {\n                this._destroyPromises = [];\n            }\n            this._destroyPromises.push(promise);\n            return promise;\n        }\n        this._state = StateDestroyInProgress;\n\n        //\n        // Shutdown and destroy all the incoming and outgoing Ice\n        // connections and wait for the connections to be finished.\n        //\n        Ice.Promise.try(() =>\n            {\n                if(this._objectAdapterFactory)\n                {\n                    return this._objectAdapterFactory.shutdown();\n                }\n            }\n        ).then(() =>\n            {\n                if(this._outgoingConnectionFactory !== null)\n                {\n                    this._outgoingConnectionFactory.destroy();\n                }\n\n                if(this._objectAdapterFactory !== null)\n                {\n                    return this._objectAdapterFactory.destroy();\n                }\n            }\n        ).then(() =>\n            {\n                if(this._outgoingConnectionFactory !== null)\n                {\n                    return this._outgoingConnectionFactory.waitUntilFinished();\n                }\n            }\n        ).then(() =>\n            {\n                if(this._retryQueue)\n                {\n                    this._retryQueue.destroy();\n                }\n                if(this._timer)\n                {\n                    this._timer.destroy();\n                }\n\n                if(this._objectFactoryMap !== null)\n                {\n                    this._objectFactoryMap.forEach(factory => factory.destroy());\n                    this._objectFactoryMap.clear();\n                }\n\n                if(this._routerManager)\n                {\n                    this._routerManager.destroy();\n                }\n                if(this._locatorManager)\n                {\n                    this._locatorManager.destroy();\n                }\n                if(this._endpointFactoryManager)\n                {\n                    this._endpointFactoryManager.destroy();\n                }\n\n                if(this._initData.properties.getPropertyAsInt(\"Ice.Warn.UnusedProperties\") > 0)\n                {\n                    const unusedProperties = this._initData.properties.getUnusedProperties();\n                    if(unusedProperties.length > 0)\n                    {\n                        const message = [];\n                        message.push(\"The following properties were set but never read:\");\n                        unusedProperties.forEach(p => message.push(\"\\n    \", p));\n                        this._initData.logger.warning(message.join(\"\"));\n                    }\n                }\n\n                this._objectAdapterFactory = null;\n                this._outgoingConnectionFactory = null;\n                this._retryQueue = null;\n                this._timer = null;\n\n                this._referenceFactory = null;\n                this._requestHandlerFactory = null;\n                this._proxyFactory = null;\n                this._routerManager = null;\n                this._locatorManager = null;\n                this._endpointFactoryManager = null;\n\n                this._state = StateDestroyed;\n\n                if(this._destroyPromises)\n                {\n                    this._destroyPromises.forEach(p => p.resolve());\n                }\n                promise.resolve();\n            }\n        ).catch(ex =>\n            {\n                if(this._destroyPromises)\n                {\n                    this._destroyPromises.forEach(p => p.reject(ex));\n                }\n                promise.reject(ex);\n            });\n        return promise;\n    }\n\n    addObjectFactory(factory, id)\n    {\n        //\n        // Create a ValueFactory wrapper around the given ObjectFactory and register the wrapper\n        // with the value factory manager. This may raise AlreadyRegisteredException.\n        //\n        this._initData.valueFactoryManager.add(typeId => factory.create(typeId), id);\n\n        if(this._objectFactoryMap === null)\n        {\n            this._objectFactoryMap = new Map();\n        }\n\n        this._objectFactoryMap.set(id, factory);\n    }\n\n    findObjectFactory(id)\n    {\n        let factory = null;\n        if(this._objectFactoryMap !== null)\n        {\n            factory = this._objectFactoryMap.get(id);\n        }\n        return factory !== undefined ? factory : null;\n    }\n}\n\nIce.Instance = Instance;\nmodule.exports.Ice = Ice;\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/Instance.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/InstrumentationF.js":
/*!******************************************************!*\
  !*** ./node_modules/ice/src/Ice/InstrumentationF.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n//\n// Ice version 3.7.10\n//\n// <auto-generated>\n//\n// Generated from file `InstrumentationF.ice'\n//\n// Warning: do not edit this file.\n//\n// </auto-generated>\n//\n\n/* eslint-disable */\n/* jshint ignore: start */\n\n/* slice2js browser-bundle-skip */\nconst _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\nconst Ice = _ModuleRegistry.module(\"Ice\");\n\nconst Slice = Ice.Slice;\n/* slice2js browser-bundle-skip-end */\n/* slice2js browser-bundle-skip */\n\nIce.Instrumentation = _ModuleRegistry.module(\"Ice.Instrumentation\");\n/* slice2js browser-bundle-skip-end */\n/* slice2js browser-bundle-skip */\nexports.Ice = Ice;\n/* slice2js browser-bundle-skip-end */\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/InstrumentationF.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/LocalException.js":
/*!****************************************************!*\
  !*** ./node_modules/ice/src/Ice/LocalException.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n//\n// Ice version 3.7.10\n//\n// <auto-generated>\n//\n// Generated from file `LocalException.ice'\n//\n// Warning: do not edit this file.\n//\n// </auto-generated>\n//\n\n/* eslint-disable */\n/* jshint ignore: start */\n\n/* slice2js browser-bundle-skip */\nconst _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\n__webpack_require__(/*! ../Ice/Exception */ \"./node_modules/ice/src/Ice/Exception.js\");\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\n__webpack_require__(/*! ../Ice/Identity */ \"./node_modules/ice/src/Ice/Identity.js\");\n__webpack_require__(/*! ../Ice/Version */ \"./node_modules/ice/src/Ice/Version.js\");\n__webpack_require__(/*! ../Ice/BuiltinSequences */ \"./node_modules/ice/src/Ice/BuiltinSequences.js\");\nconst Ice = _ModuleRegistry.module(\"Ice\");\n\nconst Slice = Ice.Slice;\n/* slice2js browser-bundle-skip-end */\n\n/**\n * This exception is raised when a failure occurs during initialization.\n *\n **/\nIce.InitializationException = class extends Ice.LocalException\n{\n    constructor(reason = \"\", _cause = \"\")\n    {\n        super(_cause);\n        this.reason = reason;\n    }\n\n    static get _parent()\n    {\n        return Ice.LocalException;\n    }\n\n    static get _id()\n    {\n        return \"::Ice::InitializationException\";\n    }\n};\n\n/**\n * This exception indicates that a failure occurred while initializing\n * a plug-in.\n *\n **/\nIce.PluginInitializationException = class extends Ice.LocalException\n{\n    constructor(reason = \"\", _cause = \"\")\n    {\n        super(_cause);\n        this.reason = reason;\n    }\n\n    static get _parent()\n    {\n        return Ice.LocalException;\n    }\n\n    static get _id()\n    {\n        return \"::Ice::PluginInitializationException\";\n    }\n};\n\n/**\n * This exception is raised if a feature is requested that is not\n * supported with collocation optimization.\n *\n * @deprecated This exception is no longer used by the Ice run time\n **/\nIce.CollocationOptimizationException = class extends Ice.LocalException\n{\n    constructor(_cause = \"\")\n    {\n        super(_cause);\n    }\n\n    static get _parent()\n    {\n        return Ice.LocalException;\n    }\n\n    static get _id()\n    {\n        return \"::Ice::CollocationOptimizationException\";\n    }\n};\n\n/**\n * An attempt was made to register something more than once with\n * the Ice run time.\n *\n * This exception is raised if an attempt is made to register a\n * servant, servant locator, facet, value factory, plug-in, object\n * adapter, object, or user exception factory more than once for the\n * same ID.\n *\n **/\nIce.AlreadyRegisteredException = class extends Ice.LocalException\n{\n    constructor(kindOfObject = \"\", id = \"\", _cause = \"\")\n    {\n        super(_cause);\n        this.kindOfObject = kindOfObject;\n        this.id = id;\n    }\n\n    static get _parent()\n    {\n        return Ice.LocalException;\n    }\n\n    static get _id()\n    {\n        return \"::Ice::AlreadyRegisteredException\";\n    }\n};\n\n/**\n * An attempt was made to find or deregister something that is not\n * registered with the Ice run time or Ice locator.\n *\n * This exception is raised if an attempt is made to remove a servant,\n * servant locator, facet, value factory, plug-in, object adapter,\n * object, or user exception factory that is not currently registered.\n *\n * It's also raised if the Ice locator can't find an object or object\n * adapter when resolving an indirect proxy or when an object adapter\n * is activated.\n *\n **/\nIce.NotRegisteredException = class extends Ice.LocalException\n{\n    constructor(kindOfObject = \"\", id = \"\", _cause = \"\")\n    {\n        super(_cause);\n        this.kindOfObject = kindOfObject;\n        this.id = id;\n    }\n\n    static get _parent()\n    {\n        return Ice.LocalException;\n    }\n\n    static get _id()\n    {\n        return \"::Ice::NotRegisteredException\";\n    }\n};\n\n/**\n * The operation can only be invoked with a twoway request.\n *\n * This exception is raised if an attempt is made to invoke an\n * operation with <code>ice_oneway</code>, <code>ice_batchOneway</code>, <code>ice_datagram</code>,\n * or <code>ice_batchDatagram</code> and the operation has a return value,\n * out-parameters, or an exception specification.\n *\n **/\nIce.TwowayOnlyException = class extends Ice.LocalException\n{\n    constructor(operation = \"\", _cause = \"\")\n    {\n        super(_cause);\n        this.operation = operation;\n    }\n\n    static get _parent()\n    {\n        return Ice.LocalException;\n    }\n\n    static get _id()\n    {\n        return \"::Ice::TwowayOnlyException\";\n    }\n};\n\n/**\n * An attempt was made to clone a class that does not support\n * cloning.\n *\n * This exception is raised if <code>ice_clone</code> is called on\n * a class that is derived from an abstract Slice class (that is,\n * a class containing operations), and the derived class does not\n * provide an implementation of the <code>ice_clone</code> operation (C++ only).\n *\n **/\nIce.CloneNotImplementedException = class extends Ice.LocalException\n{\n    constructor(_cause = \"\")\n    {\n        super(_cause);\n    }\n\n    static get _parent()\n    {\n        return Ice.LocalException;\n    }\n\n    static get _id()\n    {\n        return \"::Ice::CloneNotImplementedException\";\n    }\n};\n\n/**\n * This exception is raised if an operation call on a server raises an\n * unknown exception. For example, for C++, this exception is raised\n * if the server throws a C++ exception that is not directly or\n * indirectly derived from <code>Ice::LocalException</code> or\n * <code>Ice::UserException</code>.\n *\n **/\nIce.UnknownException = class extends Ice.LocalException\n{\n    constructor(unknown = \"\", _cause = \"\")\n    {\n        super(_cause);\n        this.unknown = unknown;\n    }\n\n    static get _parent()\n    {\n        return Ice.LocalException;\n    }\n\n    static get _id()\n    {\n        return \"::Ice::UnknownException\";\n    }\n};\n\n/**\n * This exception is raised if an operation call on a server raises a\n * local exception. Because local exceptions are not transmitted by\n * the Ice protocol, the client receives all local exceptions raised\n * by the server as {@link UnknownLocalException}. The only exception to this\n * rule are all exceptions derived from {@link RequestFailedException},\n * which are transmitted by the Ice protocol even though they are\n * declared <code>local</code>.\n *\n **/\nIce.UnknownLocalException = class extends Ice.UnknownException\n{\n    constructor(unknown, _cause = \"\")\n    {\n        super(unknown, _cause);\n    }\n\n    static get _parent()\n    {\n        return Ice.UnknownException;\n    }\n\n    static get _id()\n    {\n        return \"::Ice::UnknownLocalException\";\n    }\n};\n\n/**\n * An operation raised an incorrect user exception.\n *\n * This exception is raised if an operation raises a\n * user exception that is not declared in the exception's\n * <code>throws</code> clause. Such undeclared exceptions are\n * not transmitted from the server to the client by the Ice\n * protocol, but instead the client just gets an\n * {@link UnknownUserException}. This is necessary in order to not violate\n * the contract established by an operation's signature: Only local\n * exceptions and user exceptions declared in the\n * <code>throws</code> clause can be raised.\n *\n **/\nIce.UnknownUserException = class extends Ice.UnknownException\n{\n    constructor(unknown, _cause = \"\")\n    {\n        super(unknown, _cause);\n    }\n\n    static get _parent()\n    {\n        return Ice.UnknownException;\n    }\n\n    static get _id()\n    {\n        return \"::Ice::UnknownUserException\";\n    }\n};\n\n/**\n * This exception is raised if the Ice library version does not match\n * the version in the Ice header files.\n *\n **/\nIce.VersionMismatchException = class extends Ice.LocalException\n{\n    constructor(_cause = \"\")\n    {\n        super(_cause);\n    }\n\n    static get _parent()\n    {\n        return Ice.LocalException;\n    }\n\n    static get _id()\n    {\n        return \"::Ice::VersionMismatchException\";\n    }\n};\n\n/**\n * This exception is raised if the {@link Communicator} has been destroyed.\n *\n * @see Communicator#destroy\n *\n **/\nIce.CommunicatorDestroyedException = class extends Ice.LocalException\n{\n    constructor(_cause = \"\")\n    {\n        super(_cause);\n    }\n\n    static get _parent()\n    {\n        return Ice.LocalException;\n    }\n\n    static get _id()\n    {\n        return \"::Ice::CommunicatorDestroyedException\";\n    }\n};\n\n/**\n * This exception is raised if an attempt is made to use a deactivated\n * {@link ObjectAdapter}.\n *\n * @see ObjectAdapter#deactivate\n * @see Communicator#shutdown\n *\n **/\nIce.ObjectAdapterDeactivatedException = class extends Ice.LocalException\n{\n    constructor(name = \"\", _cause = \"\")\n    {\n        super(_cause);\n        this.name = name;\n    }\n\n    static get _parent()\n    {\n        return Ice.LocalException;\n    }\n\n    static get _id()\n    {\n        return \"::Ice::ObjectAdapterDeactivatedException\";\n    }\n};\n\n/**\n * This exception is raised if an {@link ObjectAdapter} cannot be activated.\n *\n * This happens if the {@link Locator} detects another active {@link ObjectAdapter} with\n * the same adapter id.\n *\n **/\nIce.ObjectAdapterIdInUseException = class extends Ice.LocalException\n{\n    constructor(id = \"\", _cause = \"\")\n    {\n        super(_cause);\n        this.id = id;\n    }\n\n    static get _parent()\n    {\n        return Ice.LocalException;\n    }\n\n    static get _id()\n    {\n        return \"::Ice::ObjectAdapterIdInUseException\";\n    }\n};\n\n/**\n * This exception is raised if no suitable endpoint is available.\n *\n **/\nIce.NoEndpointException = class extends Ice.LocalException\n{\n    constructor(proxy = \"\", _cause = \"\")\n    {\n        super(_cause);\n        this.proxy = proxy;\n    }\n\n    static get _parent()\n    {\n        return Ice.LocalException;\n    }\n\n    static get _id()\n    {\n        return \"::Ice::NoEndpointException\";\n    }\n};\n\n/**\n * This exception is raised if there was an error while parsing an\n * endpoint.\n *\n **/\nIce.EndpointParseException = class extends Ice.LocalException\n{\n    constructor(str = \"\", _cause = \"\")\n    {\n        super(_cause);\n        this.str = str;\n    }\n\n    static get _parent()\n    {\n        return Ice.LocalException;\n    }\n\n    static get _id()\n    {\n        return \"::Ice::EndpointParseException\";\n    }\n};\n\n/**\n * This exception is raised if there was an error while parsing an\n * endpoint selection type.\n *\n **/\nIce.EndpointSelectionTypeParseException = class extends Ice.LocalException\n{\n    constructor(str = \"\", _cause = \"\")\n    {\n        super(_cause);\n        this.str = str;\n    }\n\n    static get _parent()\n    {\n        return Ice.LocalException;\n    }\n\n    static get _id()\n    {\n        return \"::Ice::EndpointSelectionTypeParseException\";\n    }\n};\n\n/**\n * This exception is raised if there was an error while parsing a\n * version.\n *\n **/\nIce.VersionParseException = class extends Ice.LocalException\n{\n    constructor(str = \"\", _cause = \"\")\n    {\n        super(_cause);\n        this.str = str;\n    }\n\n    static get _parent()\n    {\n        return Ice.LocalException;\n    }\n\n    static get _id()\n    {\n        return \"::Ice::VersionParseException\";\n    }\n};\n\n/**\n * This exception is raised if there was an error while parsing a\n * stringified identity.\n *\n **/\nIce.IdentityParseException = class extends Ice.LocalException\n{\n    constructor(str = \"\", _cause = \"\")\n    {\n        super(_cause);\n        this.str = str;\n    }\n\n    static get _parent()\n    {\n        return Ice.LocalException;\n    }\n\n    static get _id()\n    {\n        return \"::Ice::IdentityParseException\";\n    }\n};\n\n/**\n * This exception is raised if there was an error while parsing a\n * stringified proxy.\n *\n **/\nIce.ProxyParseException = class extends Ice.LocalException\n{\n    constructor(str = \"\", _cause = \"\")\n    {\n        super(_cause);\n        this.str = str;\n    }\n\n    static get _parent()\n    {\n        return Ice.LocalException;\n    }\n\n    static get _id()\n    {\n        return \"::Ice::ProxyParseException\";\n    }\n};\n\n/**\n * This exception is raised if an illegal identity is encountered.\n *\n **/\nIce.IllegalIdentityException = class extends Ice.LocalException\n{\n    constructor(id = new Ice.Identity(), _cause = \"\")\n    {\n        super(_cause);\n        this.id = id;\n    }\n\n    static get _parent()\n    {\n        return Ice.LocalException;\n    }\n\n    static get _id()\n    {\n        return \"::Ice::IllegalIdentityException\";\n    }\n};\n\n/**\n * This exception is raised to reject an illegal servant (typically\n * a null servant)\n *\n **/\nIce.IllegalServantException = class extends Ice.LocalException\n{\n    constructor(reason = \"\", _cause = \"\")\n    {\n        super(_cause);\n        this.reason = reason;\n    }\n\n    static get _parent()\n    {\n        return Ice.LocalException;\n    }\n\n    static get _id()\n    {\n        return \"::Ice::IllegalServantException\";\n    }\n};\n\n/**\n * This exception is raised if a request failed. This exception, and\n * all exceptions derived from {@link RequestFailedException}, are\n * transmitted by the Ice protocol, even though they are declared\n * <code>local</code>.\n *\n **/\nIce.RequestFailedException = class extends Ice.LocalException\n{\n    constructor(id = new Ice.Identity(), facet = \"\", operation = \"\", _cause = \"\")\n    {\n        super(_cause);\n        this.id = id;\n        this.facet = facet;\n        this.operation = operation;\n    }\n\n    static get _parent()\n    {\n        return Ice.LocalException;\n    }\n\n    static get _id()\n    {\n        return \"::Ice::RequestFailedException\";\n    }\n};\n\n/**\n * This exception is raised if an object does not exist on the server,\n * that is, if no facets with the given identity exist.\n *\n **/\nIce.ObjectNotExistException = class extends Ice.RequestFailedException\n{\n    constructor(id, facet, operation, _cause = \"\")\n    {\n        super(id, facet, operation, _cause);\n    }\n\n    static get _parent()\n    {\n        return Ice.RequestFailedException;\n    }\n\n    static get _id()\n    {\n        return \"::Ice::ObjectNotExistException\";\n    }\n};\n\n/**\n * This exception is raised if no facet with the given name exists,\n * but at least one facet with the given identity exists.\n *\n **/\nIce.FacetNotExistException = class extends Ice.RequestFailedException\n{\n    constructor(id, facet, operation, _cause = \"\")\n    {\n        super(id, facet, operation, _cause);\n    }\n\n    static get _parent()\n    {\n        return Ice.RequestFailedException;\n    }\n\n    static get _id()\n    {\n        return \"::Ice::FacetNotExistException\";\n    }\n};\n\n/**\n * This exception is raised if an operation for a given object does\n * not exist on the server. Typically this is caused by either the\n * client or the server using an outdated Slice specification.\n *\n **/\nIce.OperationNotExistException = class extends Ice.RequestFailedException\n{\n    constructor(id, facet, operation, _cause = \"\")\n    {\n        super(id, facet, operation, _cause);\n    }\n\n    static get _parent()\n    {\n        return Ice.RequestFailedException;\n    }\n\n    static get _id()\n    {\n        return \"::Ice::OperationNotExistException\";\n    }\n};\n\n/**\n * This exception is raised if a system error occurred in the server\n * or client process. There are many possible causes for such a system\n * exception. For details on the cause, {@link SyscallException#error}\n * should be inspected.\n *\n **/\nIce.SyscallException = class extends Ice.LocalException\n{\n    constructor(error = 0, _cause = \"\")\n    {\n        super(_cause);\n        this.error = error;\n    }\n\n    static get _parent()\n    {\n        return Ice.LocalException;\n    }\n\n    static get _id()\n    {\n        return \"::Ice::SyscallException\";\n    }\n};\n\n/**\n * This exception indicates socket errors.\n *\n **/\nIce.SocketException = class extends Ice.SyscallException\n{\n    constructor(error, _cause = \"\")\n    {\n        super(error, _cause);\n    }\n\n    static get _parent()\n    {\n        return Ice.SyscallException;\n    }\n\n    static get _id()\n    {\n        return \"::Ice::SocketException\";\n    }\n};\n\n/**\n * This exception indicates CFNetwork errors.\n *\n **/\nIce.CFNetworkException = class extends Ice.SocketException\n{\n    constructor(error, domain = \"\", _cause = \"\")\n    {\n        super(error, _cause);\n        this.domain = domain;\n    }\n\n    static get _parent()\n    {\n        return Ice.SocketException;\n    }\n\n    static get _id()\n    {\n        return \"::Ice::CFNetworkException\";\n    }\n};\n\n/**\n * This exception indicates file errors.\n *\n **/\nIce.FileException = class extends Ice.SyscallException\n{\n    constructor(error, path = \"\", _cause = \"\")\n    {\n        super(error, _cause);\n        this.path = path;\n    }\n\n    static get _parent()\n    {\n        return Ice.SyscallException;\n    }\n\n    static get _id()\n    {\n        return \"::Ice::FileException\";\n    }\n};\n\n/**\n * This exception indicates connection failures.\n *\n **/\nIce.ConnectFailedException = class extends Ice.SocketException\n{\n    constructor(error, _cause = \"\")\n    {\n        super(error, _cause);\n    }\n\n    static get _parent()\n    {\n        return Ice.SocketException;\n    }\n\n    static get _id()\n    {\n        return \"::Ice::ConnectFailedException\";\n    }\n};\n\n/**\n * This exception indicates a connection failure for which\n * the server host actively refuses a connection.\n *\n **/\nIce.ConnectionRefusedException = class extends Ice.ConnectFailedException\n{\n    constructor(error, _cause = \"\")\n    {\n        super(error, _cause);\n    }\n\n    static get _parent()\n    {\n        return Ice.ConnectFailedException;\n    }\n\n    static get _id()\n    {\n        return \"::Ice::ConnectionRefusedException\";\n    }\n};\n\n/**\n * This exception indicates a lost connection.\n *\n **/\nIce.ConnectionLostException = class extends Ice.SocketException\n{\n    constructor(error, _cause = \"\")\n    {\n        super(error, _cause);\n    }\n\n    static get _parent()\n    {\n        return Ice.SocketException;\n    }\n\n    static get _id()\n    {\n        return \"::Ice::ConnectionLostException\";\n    }\n};\n\n/**\n * This exception indicates a DNS problem. For details on the cause,\n * {@link DNSException#error} should be inspected.\n *\n **/\nIce.DNSException = class extends Ice.LocalException\n{\n    constructor(error = 0, host = \"\", _cause = \"\")\n    {\n        super(_cause);\n        this.error = error;\n        this.host = host;\n    }\n\n    static get _parent()\n    {\n        return Ice.LocalException;\n    }\n\n    static get _id()\n    {\n        return \"::Ice::DNSException\";\n    }\n};\n\n/**\n * This exception indicates a request was interrupted.\n *\n **/\nIce.OperationInterruptedException = class extends Ice.LocalException\n{\n    constructor(_cause = \"\")\n    {\n        super(_cause);\n    }\n\n    static get _parent()\n    {\n        return Ice.LocalException;\n    }\n\n    static get _id()\n    {\n        return \"::Ice::OperationInterruptedException\";\n    }\n};\n\n/**\n * This exception indicates a timeout condition.\n *\n **/\nIce.TimeoutException = class extends Ice.LocalException\n{\n    constructor(_cause = \"\")\n    {\n        super(_cause);\n    }\n\n    static get _parent()\n    {\n        return Ice.LocalException;\n    }\n\n    static get _id()\n    {\n        return \"::Ice::TimeoutException\";\n    }\n};\n\n/**\n * This exception indicates a connection establishment timeout condition.\n *\n **/\nIce.ConnectTimeoutException = class extends Ice.TimeoutException\n{\n    constructor(_cause = \"\")\n    {\n        super(_cause);\n    }\n\n    static get _parent()\n    {\n        return Ice.TimeoutException;\n    }\n\n    static get _id()\n    {\n        return \"::Ice::ConnectTimeoutException\";\n    }\n};\n\n/**\n * This exception indicates a connection closure timeout condition.\n *\n **/\nIce.CloseTimeoutException = class extends Ice.TimeoutException\n{\n    constructor(_cause = \"\")\n    {\n        super(_cause);\n    }\n\n    static get _parent()\n    {\n        return Ice.TimeoutException;\n    }\n\n    static get _id()\n    {\n        return \"::Ice::CloseTimeoutException\";\n    }\n};\n\n/**\n * This exception indicates that a connection has been shut down because it has been\n * idle for some time.\n *\n **/\nIce.ConnectionTimeoutException = class extends Ice.TimeoutException\n{\n    constructor(_cause = \"\")\n    {\n        super(_cause);\n    }\n\n    static get _parent()\n    {\n        return Ice.TimeoutException;\n    }\n\n    static get _id()\n    {\n        return \"::Ice::ConnectionTimeoutException\";\n    }\n};\n\n/**\n * This exception indicates that an invocation failed because it timed\n * out.\n *\n **/\nIce.InvocationTimeoutException = class extends Ice.TimeoutException\n{\n    constructor(_cause = \"\")\n    {\n        super(_cause);\n    }\n\n    static get _parent()\n    {\n        return Ice.TimeoutException;\n    }\n\n    static get _id()\n    {\n        return \"::Ice::InvocationTimeoutException\";\n    }\n};\n\n/**\n * This exception indicates that an asynchronous invocation failed\n * because it was canceled explicitly by the user.\n *\n **/\nIce.InvocationCanceledException = class extends Ice.LocalException\n{\n    constructor(_cause = \"\")\n    {\n        super(_cause);\n    }\n\n    static get _parent()\n    {\n        return Ice.LocalException;\n    }\n\n    static get _id()\n    {\n        return \"::Ice::InvocationCanceledException\";\n    }\n};\n\n/**\n * A generic exception base for all kinds of protocol error\n * conditions.\n *\n **/\nIce.ProtocolException = class extends Ice.LocalException\n{\n    constructor(reason = \"\", _cause = \"\")\n    {\n        super(_cause);\n        this.reason = reason;\n    }\n\n    static get _parent()\n    {\n        return Ice.LocalException;\n    }\n\n    static get _id()\n    {\n        return \"::Ice::ProtocolException\";\n    }\n};\n\n/**\n * This exception indicates that a message did not start with the expected\n * magic number ('I', 'c', 'e', 'P').\n *\n **/\nIce.BadMagicException = class extends Ice.ProtocolException\n{\n    constructor(reason, badMagic = null, _cause = \"\")\n    {\n        super(reason, _cause);\n        this.badMagic = badMagic;\n    }\n\n    static get _parent()\n    {\n        return Ice.ProtocolException;\n    }\n\n    static get _id()\n    {\n        return \"::Ice::BadMagicException\";\n    }\n};\n\n/**\n * This exception indicates an unsupported protocol version.\n *\n **/\nIce.UnsupportedProtocolException = class extends Ice.ProtocolException\n{\n    constructor(reason, bad = new Ice.ProtocolVersion(), supported = new Ice.ProtocolVersion(), _cause = \"\")\n    {\n        super(reason, _cause);\n        this.bad = bad;\n        this.supported = supported;\n    }\n\n    static get _parent()\n    {\n        return Ice.ProtocolException;\n    }\n\n    static get _id()\n    {\n        return \"::Ice::UnsupportedProtocolException\";\n    }\n};\n\n/**\n * This exception indicates an unsupported data encoding version.\n *\n **/\nIce.UnsupportedEncodingException = class extends Ice.ProtocolException\n{\n    constructor(reason, bad = new Ice.EncodingVersion(), supported = new Ice.EncodingVersion(), _cause = \"\")\n    {\n        super(reason, _cause);\n        this.bad = bad;\n        this.supported = supported;\n    }\n\n    static get _parent()\n    {\n        return Ice.ProtocolException;\n    }\n\n    static get _id()\n    {\n        return \"::Ice::UnsupportedEncodingException\";\n    }\n};\n\n/**\n * This exception indicates that an unknown protocol message has been received.\n *\n **/\nIce.UnknownMessageException = class extends Ice.ProtocolException\n{\n    constructor(reason, _cause = \"\")\n    {\n        super(reason, _cause);\n    }\n\n    static get _parent()\n    {\n        return Ice.ProtocolException;\n    }\n\n    static get _id()\n    {\n        return \"::Ice::UnknownMessageException\";\n    }\n};\n\n/**\n * This exception is raised if a message is received over a connection\n * that is not yet validated.\n *\n **/\nIce.ConnectionNotValidatedException = class extends Ice.ProtocolException\n{\n    constructor(reason, _cause = \"\")\n    {\n        super(reason, _cause);\n    }\n\n    static get _parent()\n    {\n        return Ice.ProtocolException;\n    }\n\n    static get _id()\n    {\n        return \"::Ice::ConnectionNotValidatedException\";\n    }\n};\n\n/**\n * This exception indicates that a response for an unknown request ID has been\n * received.\n *\n **/\nIce.UnknownRequestIdException = class extends Ice.ProtocolException\n{\n    constructor(reason, _cause = \"\")\n    {\n        super(reason, _cause);\n    }\n\n    static get _parent()\n    {\n        return Ice.ProtocolException;\n    }\n\n    static get _id()\n    {\n        return \"::Ice::UnknownRequestIdException\";\n    }\n};\n\n/**\n * This exception indicates that an unknown reply status has been received.\n *\n **/\nIce.UnknownReplyStatusException = class extends Ice.ProtocolException\n{\n    constructor(reason, _cause = \"\")\n    {\n        super(reason, _cause);\n    }\n\n    static get _parent()\n    {\n        return Ice.ProtocolException;\n    }\n\n    static get _id()\n    {\n        return \"::Ice::UnknownReplyStatusException\";\n    }\n};\n\n/**\n * This exception indicates that the connection has been gracefully shut down by the\n * server. The operation call that caused this exception has not been\n * executed by the server. In most cases you will not get this\n * exception, because the client will automatically retry the\n * operation call in case the server shut down the connection. However,\n * if upon retry the server shuts down the connection again, and the\n * retry limit has been reached, then this exception is propagated to\n * the application code.\n *\n **/\nIce.CloseConnectionException = class extends Ice.ProtocolException\n{\n    constructor(reason, _cause = \"\")\n    {\n        super(reason, _cause);\n    }\n\n    static get _parent()\n    {\n        return Ice.ProtocolException;\n    }\n\n    static get _id()\n    {\n        return \"::Ice::CloseConnectionException\";\n    }\n};\n\n/**\n * This exception is raised by an operation call if the application\n * closes the connection locally using {@link Connection#close}.\n *\n * @see Connection#close\n *\n **/\nIce.ConnectionManuallyClosedException = class extends Ice.LocalException\n{\n    constructor(graceful = false, _cause = \"\")\n    {\n        super(_cause);\n        this.graceful = graceful;\n    }\n\n    static get _parent()\n    {\n        return Ice.LocalException;\n    }\n\n    static get _id()\n    {\n        return \"::Ice::ConnectionManuallyClosedException\";\n    }\n};\n\n/**\n * This exception indicates that a message size is less\n * than the minimum required size.\n *\n **/\nIce.IllegalMessageSizeException = class extends Ice.ProtocolException\n{\n    constructor(reason, _cause = \"\")\n    {\n        super(reason, _cause);\n    }\n\n    static get _parent()\n    {\n        return Ice.ProtocolException;\n    }\n\n    static get _id()\n    {\n        return \"::Ice::IllegalMessageSizeException\";\n    }\n};\n\n/**\n * This exception indicates a problem with compressing or uncompressing data.\n *\n **/\nIce.CompressionException = class extends Ice.ProtocolException\n{\n    constructor(reason, _cause = \"\")\n    {\n        super(reason, _cause);\n    }\n\n    static get _parent()\n    {\n        return Ice.ProtocolException;\n    }\n\n    static get _id()\n    {\n        return \"::Ice::CompressionException\";\n    }\n};\n\n/**\n * A datagram exceeds the configured size.\n *\n * This exception is raised if a datagram exceeds the configured send or receive buffer\n * size, or exceeds the maximum payload size of a UDP packet (65507 bytes).\n *\n **/\nIce.DatagramLimitException = class extends Ice.ProtocolException\n{\n    constructor(reason, _cause = \"\")\n    {\n        super(reason, _cause);\n    }\n\n    static get _parent()\n    {\n        return Ice.ProtocolException;\n    }\n\n    static get _id()\n    {\n        return \"::Ice::DatagramLimitException\";\n    }\n};\n\n/**\n * This exception is raised for errors during marshaling or unmarshaling data.\n *\n **/\nIce.MarshalException = class extends Ice.ProtocolException\n{\n    constructor(reason, _cause = \"\")\n    {\n        super(reason, _cause);\n    }\n\n    static get _parent()\n    {\n        return Ice.ProtocolException;\n    }\n\n    static get _id()\n    {\n        return \"::Ice::MarshalException\";\n    }\n};\n\n/**\n * This exception is raised if inconsistent data is received while unmarshaling a proxy.\n *\n **/\nIce.ProxyUnmarshalException = class extends Ice.MarshalException\n{\n    constructor(reason, _cause = \"\")\n    {\n        super(reason, _cause);\n    }\n\n    static get _parent()\n    {\n        return Ice.MarshalException;\n    }\n\n    static get _id()\n    {\n        return \"::Ice::ProxyUnmarshalException\";\n    }\n};\n\n/**\n * This exception is raised if an out-of-bounds condition occurs during unmarshaling.\n *\n **/\nIce.UnmarshalOutOfBoundsException = class extends Ice.MarshalException\n{\n    constructor(reason, _cause = \"\")\n    {\n        super(reason, _cause);\n    }\n\n    static get _parent()\n    {\n        return Ice.MarshalException;\n    }\n\n    static get _id()\n    {\n        return \"::Ice::UnmarshalOutOfBoundsException\";\n    }\n};\n\n/**\n * This exception is raised if no suitable value factory was found during\n * unmarshaling of a Slice class instance.\n *\n * @see ValueFactory\n * @see Communicator#getValueFactoryManager\n * @see ValueFactoryManager#add\n * @see ValueFactoryManager#find\n *\n **/\nIce.NoValueFactoryException = class extends Ice.MarshalException\n{\n    constructor(reason, type = \"\", _cause = \"\")\n    {\n        super(reason, _cause);\n        this.type = type;\n    }\n\n    static get _parent()\n    {\n        return Ice.MarshalException;\n    }\n\n    static get _id()\n    {\n        return \"::Ice::NoValueFactoryException\";\n    }\n};\n\n/**\n * This exception is raised if the type of an unmarshaled Slice class instance does\n * not match its expected type.\n * This can happen if client and server are compiled with mismatched Slice\n * definitions or if a class of the wrong type is passed as a parameter\n * or return value using dynamic invocation. This exception can also be\n * raised if IceStorm is used to send Slice class instances and\n * an operation is subscribed to the wrong topic.\n *\n **/\nIce.UnexpectedObjectException = class extends Ice.MarshalException\n{\n    constructor(reason, type = \"\", expectedType = \"\", _cause = \"\")\n    {\n        super(reason, _cause);\n        this.type = type;\n        this.expectedType = expectedType;\n    }\n\n    static get _parent()\n    {\n        return Ice.MarshalException;\n    }\n\n    static get _id()\n    {\n        return \"::Ice::UnexpectedObjectException\";\n    }\n};\n\n/**\n * This exception is raised when Ice receives a request or reply\n * message whose size exceeds the limit specified by the\n * <code>Ice.MessageSizeMax</code> property.\n *\n **/\nIce.MemoryLimitException = class extends Ice.MarshalException\n{\n    constructor(reason, _cause = \"\")\n    {\n        super(reason, _cause);\n    }\n\n    static get _parent()\n    {\n        return Ice.MarshalException;\n    }\n\n    static get _id()\n    {\n        return \"::Ice::MemoryLimitException\";\n    }\n};\n\n/**\n * This exception is raised when a string conversion to or from UTF-8\n * fails during marshaling or unmarshaling.\n *\n **/\nIce.StringConversionException = class extends Ice.MarshalException\n{\n    constructor(reason, _cause = \"\")\n    {\n        super(reason, _cause);\n    }\n\n    static get _parent()\n    {\n        return Ice.MarshalException;\n    }\n\n    static get _id()\n    {\n        return \"::Ice::StringConversionException\";\n    }\n};\n\n/**\n * This exception indicates a malformed data encapsulation.\n *\n **/\nIce.EncapsulationException = class extends Ice.MarshalException\n{\n    constructor(reason, _cause = \"\")\n    {\n        super(reason, _cause);\n    }\n\n    static get _parent()\n    {\n        return Ice.MarshalException;\n    }\n\n    static get _id()\n    {\n        return \"::Ice::EncapsulationException\";\n    }\n};\n\n/**\n * This exception is raised if an unsupported feature is used. The\n * unsupported feature string contains the name of the unsupported\n * feature\n *\n **/\nIce.FeatureNotSupportedException = class extends Ice.LocalException\n{\n    constructor(unsupportedFeature = \"\", _cause = \"\")\n    {\n        super(_cause);\n        this.unsupportedFeature = unsupportedFeature;\n    }\n\n    static get _parent()\n    {\n        return Ice.LocalException;\n    }\n\n    static get _id()\n    {\n        return \"::Ice::FeatureNotSupportedException\";\n    }\n};\n\n/**\n * This exception indicates a failure in a security subsystem,\n * such as the IceSSL plug-in.\n *\n **/\nIce.SecurityException = class extends Ice.LocalException\n{\n    constructor(reason = \"\", _cause = \"\")\n    {\n        super(_cause);\n        this.reason = reason;\n    }\n\n    static get _parent()\n    {\n        return Ice.LocalException;\n    }\n\n    static get _id()\n    {\n        return \"::Ice::SecurityException\";\n    }\n};\n\n/**\n * This exception indicates that an attempt has been made to\n * change the connection properties of a fixed proxy.\n *\n **/\nIce.FixedProxyException = class extends Ice.LocalException\n{\n    constructor(_cause = \"\")\n    {\n        super(_cause);\n    }\n\n    static get _parent()\n    {\n        return Ice.LocalException;\n    }\n\n    static get _id()\n    {\n        return \"::Ice::FixedProxyException\";\n    }\n};\n\n/**\n * Indicates that the response to a request has already been sent;\n * re-dispatching such a request is not possible.\n *\n **/\nIce.ResponseSentException = class extends Ice.LocalException\n{\n    constructor(_cause = \"\")\n    {\n        super(_cause);\n    }\n\n    static get _parent()\n    {\n        return Ice.LocalException;\n    }\n\n    static get _id()\n    {\n        return \"::Ice::ResponseSentException\";\n    }\n};\n/* slice2js browser-bundle-skip */\nexports.Ice = Ice;\n/* slice2js browser-bundle-skip-end */\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/LocalException.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/Locator.js":
/*!*********************************************!*\
  !*** ./node_modules/ice/src/Ice/Locator.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n//\n// Ice version 3.7.10\n//\n// <auto-generated>\n//\n// Generated from file `Locator.ice'\n//\n// Warning: do not edit this file.\n//\n// </auto-generated>\n//\n\n/* eslint-disable */\n/* jshint ignore: start */\n\n/* slice2js browser-bundle-skip */\nconst _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\n__webpack_require__(/*! ../Ice/Object */ \"./node_modules/ice/src/Ice/Object.js\");\n__webpack_require__(/*! ../Ice/Value */ \"./node_modules/ice/src/Ice/Value.js\");\n__webpack_require__(/*! ../Ice/ObjectPrx */ \"./node_modules/ice/src/Ice/ObjectPrx.js\");\n__webpack_require__(/*! ../Ice/Operation */ \"./node_modules/ice/src/Ice/Operation.js\");\n__webpack_require__(/*! ../Ice/Exception */ \"./node_modules/ice/src/Ice/Exception.js\");\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\n__webpack_require__(/*! ../Ice/Identity */ \"./node_modules/ice/src/Ice/Identity.js\");\n__webpack_require__(/*! ../Ice/Process */ \"./node_modules/ice/src/Ice/Process.js\");\nconst Ice = _ModuleRegistry.module(\"Ice\");\n\nconst Slice = Ice.Slice;\n/* slice2js browser-bundle-skip-end */\n\n/**\n * This exception is raised if an adapter cannot be found.\n *\n **/\nIce.AdapterNotFoundException = class extends Ice.UserException\n{\n    constructor(_cause = \"\")\n    {\n        super(_cause);\n    }\n\n    static get _parent()\n    {\n        return Ice.UserException;\n    }\n\n    static get _id()\n    {\n        return \"::Ice::AdapterNotFoundException\";\n    }\n\n    _mostDerivedType()\n    {\n        return Ice.AdapterNotFoundException;\n    }\n};\n\n/**\n * This exception is raised if the replica group provided by the\n * server is invalid.\n *\n **/\nIce.InvalidReplicaGroupIdException = class extends Ice.UserException\n{\n    constructor(_cause = \"\")\n    {\n        super(_cause);\n    }\n\n    static get _parent()\n    {\n        return Ice.UserException;\n    }\n\n    static get _id()\n    {\n        return \"::Ice::InvalidReplicaGroupIdException\";\n    }\n\n    _mostDerivedType()\n    {\n        return Ice.InvalidReplicaGroupIdException;\n    }\n};\n\n/**\n * This exception is raised if a server tries to set endpoints for\n * an adapter that is already active.\n *\n **/\nIce.AdapterAlreadyActiveException = class extends Ice.UserException\n{\n    constructor(_cause = \"\")\n    {\n        super(_cause);\n    }\n\n    static get _parent()\n    {\n        return Ice.UserException;\n    }\n\n    static get _id()\n    {\n        return \"::Ice::AdapterAlreadyActiveException\";\n    }\n\n    _mostDerivedType()\n    {\n        return Ice.AdapterAlreadyActiveException;\n    }\n};\n\n/**\n * This exception is raised if an object cannot be found.\n *\n **/\nIce.ObjectNotFoundException = class extends Ice.UserException\n{\n    constructor(_cause = \"\")\n    {\n        super(_cause);\n    }\n\n    static get _parent()\n    {\n        return Ice.UserException;\n    }\n\n    static get _id()\n    {\n        return \"::Ice::ObjectNotFoundException\";\n    }\n\n    _mostDerivedType()\n    {\n        return Ice.ObjectNotFoundException;\n    }\n};\n\n/**\n * This exception is raised if a server cannot be found.\n *\n **/\nIce.ServerNotFoundException = class extends Ice.UserException\n{\n    constructor(_cause = \"\")\n    {\n        super(_cause);\n    }\n\n    static get _parent()\n    {\n        return Ice.UserException;\n    }\n\n    static get _id()\n    {\n        return \"::Ice::ServerNotFoundException\";\n    }\n\n    _mostDerivedType()\n    {\n        return Ice.ServerNotFoundException;\n    }\n};\n\nconst iceC_Ice_Locator_ids = [\n    \"::Ice::Locator\",\n    \"::Ice::Object\"\n];\n\n/**\n * The Ice locator interface. This interface is used by clients to\n * lookup adapters and objects. It is also used by servers to get the\n * locator registry proxy.\n *\n * <p class=\"Note\">The {@link Locator} interface is intended to be used by\n * Ice internals and by locator implementations. Regular user code\n * should not attempt to use any functionality of this interface\n * directly.\n *\n **/\nIce.Locator = class extends Ice.Object\n{\n};\n\nIce.LocatorPrx = class extends Ice.ObjectPrx\n{\n};\n\nSlice.defineOperations(Ice.Locator, Ice.LocatorPrx, iceC_Ice_Locator_ids, 0,\n{\n    \"findObjectById\": [, 2, 1, , [9], [[Ice.Identity]], ,\n    [\n        Ice.ObjectNotFoundException\n    ], , ],\n    \"findAdapterById\": [, 2, 1, , [9], [[7]], ,\n    [\n        Ice.AdapterNotFoundException\n    ], , ],\n    \"getRegistry\": [, 2, 1, , [\"Ice.LocatorRegistryPrx\"], , , , , ]\n});\n\nconst iceC_Ice_LocatorRegistry_ids = [\n    \"::Ice::LocatorRegistry\",\n    \"::Ice::Object\"\n];\n\n/**\n * The Ice locator registry interface. This interface is used by\n * servers to register adapter endpoints with the locator.\n *\n * <p class=\"Note\"> The {@link LocatorRegistry} interface is intended to be used\n * by Ice internals and by locator implementations. Regular user\n * code should not attempt to use any functionality of this interface\n * directly.\n *\n **/\nIce.LocatorRegistry = class extends Ice.Object\n{\n};\n\nIce.LocatorRegistryPrx = class extends Ice.ObjectPrx\n{\n};\n\nSlice.defineOperations(Ice.LocatorRegistry, Ice.LocatorRegistryPrx, iceC_Ice_LocatorRegistry_ids, 0,\n{\n    \"setAdapterDirectProxy\": [, 2, 2, , , [[7], [9]], ,\n    [\n        Ice.AdapterAlreadyActiveException,\n        Ice.AdapterNotFoundException\n    ], , ],\n    \"setReplicatedAdapterDirectProxy\": [, 2, 2, , , [[7], [7], [9]], ,\n    [\n        Ice.AdapterAlreadyActiveException,\n        Ice.AdapterNotFoundException,\n        Ice.InvalidReplicaGroupIdException\n    ], , ],\n    \"setServerProcessProxy\": [, 2, 2, , , [[7], [\"Ice.ProcessPrx\"]], ,\n    [\n        Ice.ServerNotFoundException\n    ], , ]\n});\n\nconst iceC_Ice_LocatorFinder_ids = [\n    \"::Ice::LocatorFinder\",\n    \"::Ice::Object\"\n];\n\n/**\n * This inferface should be implemented by services implementing the\n * Ice::Locator interface. It should be advertised through an Ice\n * object with the identity `Ice/LocatorFinder'. This allows clients\n * to retrieve the locator proxy with just the endpoint information of\n * the service.\n *\n **/\nIce.LocatorFinder = class extends Ice.Object\n{\n};\n\nIce.LocatorFinderPrx = class extends Ice.ObjectPrx\n{\n};\n\nSlice.defineOperations(Ice.LocatorFinder, Ice.LocatorFinderPrx, iceC_Ice_LocatorFinder_ids, 0,\n{\n    \"getLocator\": [, , , , [\"Ice.LocatorPrx\"], , , , , ]\n});\n/* slice2js browser-bundle-skip */\nexports.Ice = Ice;\n/* slice2js browser-bundle-skip-end */\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/Locator.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/LocatorInfo.js":
/*!*************************************************!*\
  !*** ./node_modules/ice/src/Ice/LocatorInfo.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nconst Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n\n__webpack_require__(/*! ../Ice/Debug */ \"./node_modules/ice/src/Ice/Debug.js\");\n__webpack_require__(/*! ../Ice/Exception */ \"./node_modules/ice/src/Ice/Exception.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/IdentityUtil */ \"./node_modules/ice/src/Ice/IdentityUtil.js\");\n__webpack_require__(/*! ../Ice/LocalException */ \"./node_modules/ice/src/Ice/LocalException.js\");\n__webpack_require__(/*! ../Ice/Locator */ \"./node_modules/ice/src/Ice/Locator.js\");\n__webpack_require__(/*! ../Ice/Promise */ \"./node_modules/ice/src/Ice/Promise.js\");\n__webpack_require__(/*! ../Ice/Protocol */ \"./node_modules/ice/src/Ice/Protocol.js\");\n\nconst Debug = Ice.Debug;\nconst HashMap = Ice.HashMap;\nconst LocatorRegistryPrx = Ice.LocatorRegisterPrx;\nconst Protocol = Ice.Protocol;\n\nclass LocatorInfo\n{\n    constructor(locator, table, background)\n    {\n        this._locator = locator;\n        this._locatorRegistry = null;\n        this._table = table;\n        this._background = background;\n\n        this._adapterRequests = new Map(); // Map<String, Request>\n        this._objectRequests = new HashMap(HashMap.compareEquals); // Map<Ice.Identity, Request>\n    }\n\n    destroy()\n    {\n        this._locatorRegistry = null;\n        this._table.clear();\n    }\n\n    equals(rhs)\n    {\n        if(this === rhs)\n        {\n            return true;\n        }\n\n        if(rhs instanceof LocatorInfo)\n        {\n            return this._locator.equals(rhs._locator);\n        }\n\n        return false;\n    }\n\n    hashCode()\n    {\n        return this._locator.hashCode();\n    }\n\n    getLocator()\n    {\n        return this._locator;\n    }\n\n    getLocatorRegistry()\n    {\n        if(this._locatorRegistry !== null)\n        {\n            return Ice.Promise.resolve(this._locatorRegistry);\n        }\n\n        return this._locator.getRegistry().then(reg =>\n            {\n                //\n                // The locator registry can't be located. We use ordered\n                // endpoint selection in case the locator returned a proxy\n                // with some endpoints which are prefered to be tried first.\n                //\n                this._locatorRegistry = LocatorRegistryPrx.uncheckedCast(reg.ice_locator(null).ice_endpointSelection(\n                    Ice.EndpointSelectionType.Ordered));\n                return this._locatorRegistry;\n            });\n    }\n\n    getEndpoints(ref, wellKnownRef, ttl, p)\n    {\n        const promise = p || new Ice.Promise(); // success callback receives (endpoints, cached)\n\n        Debug.assert(ref.isIndirect());\n        let endpoints = null;\n        const cached = {value: false};\n        if(!ref.isWellKnown())\n        {\n            endpoints = this._table.getAdapterEndpoints(ref.getAdapterId(), ttl, cached);\n            if(!cached.value)\n            {\n                if(this._background && endpoints !== null)\n                {\n                    this.getAdapterRequest(ref).addCallback(ref, wellKnownRef, ttl, null);\n                }\n                else\n                {\n                    this.getAdapterRequest(ref).addCallback(ref, wellKnownRef, ttl, promise);\n                    return promise;\n                }\n            }\n        }\n        else\n        {\n            const r = this._table.getObjectReference(ref.getIdentity(), ttl, cached);\n            if(!cached.value)\n            {\n                if(this._background && r !== null)\n                {\n                    this.getObjectRequest(ref).addCallback(ref, null, ttl, null);\n                }\n                else\n                {\n                    this.getObjectRequest(ref).addCallback(ref, null, ttl, promise);\n                    return promise;\n                }\n            }\n\n            if(!r.isIndirect())\n            {\n                endpoints = r.getEndpoints();\n            }\n            else if(!r.isWellKnown())\n            {\n                if(ref.getInstance().traceLevels().location >= 1)\n                {\n                    this.traceWellKnown(\"found adapter for well-known object in locator cache\", ref, r);\n                }\n                this.getEndpoints(r, ref, ttl, promise);\n                return promise;\n            }\n        }\n\n        Debug.assert(endpoints !== null);\n        if(ref.getInstance().traceLevels().location >= 1)\n        {\n            this.getEndpointsTrace(ref, endpoints, true);\n        }\n        promise.resolve([endpoints, true]);\n\n        return promise;\n    }\n\n    clearCache(ref)\n    {\n        Debug.assert(ref.isIndirect());\n\n        if(!ref.isWellKnown())\n        {\n            const endpoints = this._table.removeAdapterEndpoints(ref.getAdapterId());\n\n            if(endpoints !== null && ref.getInstance().traceLevels().location >= 2)\n            {\n                this.trace(\"removed endpoints for adapter from locator cache\", ref, endpoints);\n            }\n        }\n        else\n        {\n            const r = this._table.removeObjectReference(ref.getIdentity());\n            if(r !== null)\n            {\n                if(!r.isIndirect())\n                {\n                    if(ref.getInstance().traceLevels().location >= 2)\n                    {\n                        this.trace(\"removed endpoints for well-known object from locator cache\", ref, r.getEndpoints());\n                    }\n                }\n                else if(!r.isWellKnown())\n                {\n                    if(ref.getInstance().traceLevels().location >= 2)\n                    {\n                        this.traceWellKnown(\"removed adapter for well-known object from locator cache\", ref, r);\n                    }\n                    this.clearCache(r);\n                }\n            }\n        }\n    }\n\n    trace(msg, ref, endpoints)\n    {\n        Debug.assert(ref.isIndirect());\n\n        const s = [];\n        s.push(msg);\n        s.push(\"\\n\");\n        if(!ref.isWellKnown())\n        {\n            s.push(\"adapter = \");\n            s.push(ref.getAdapterId());\n            s.push(\"\\n\");\n        }\n        else\n        {\n            s.push(\"well-known proxy = \");\n            s.push(ref.toString());\n            s.push(\"\\n\");\n        }\n\n        s.push(\"endpoints = \");\n        s.push(endpoints.map(e => e.toString()).join(\":\"));\n        ref.getInstance().initializationData().logger.trace(ref.getInstance().traceLevels().locationCat, s.join(\"\"));\n    }\n\n    traceWellKnown(msg, ref, resolved)\n    {\n        Debug.assert(ref.isWellKnown());\n\n        const s = [];\n        s.push(msg);\n        s.push(\"\\n\");\n        s.push(\"well-known proxy = \");\n        s.push(ref.toString());\n        s.push(\"\\n\");\n\n        s.push(\"adapter = \");\n        s.push(resolved.getAdapterId());\n        ref.getInstance().initializationData().logger.trace(ref.getInstance().traceLevels().locationCat, s.join(\"\"));\n    }\n\n    getEndpointsException(ref, exc)\n    {\n        Debug.assert(ref.isIndirect());\n\n        const instance = ref.getInstance();\n        try\n        {\n            throw exc;\n        }\n        catch(ex)\n        {\n            if(ex instanceof Ice.AdapterNotFoundException)\n            {\n                if(instance.traceLevels().location >= 1)\n                {\n                    const s = [];\n                    s.push(\"adapter not found\\n\");\n                    s.push(\"adapter = \");\n                    s.push(ref.getAdapterId());\n                    instance.initializationData().logger.trace(instance.traceLevels().locationCat, s.join(\"\"));\n                }\n\n                const e = new Ice.NotRegisteredException();\n                e.kindOfObject = \"object adapter\";\n                e.id = ref.getAdapterId();\n                throw e;\n            }\n            else if(ex instanceof Ice.ObjectNotFoundException)\n            {\n                if(instance.traceLevels().location >= 1)\n                {\n                    const s = [];\n                    s.push(\"object not found\\n\");\n                    s.push(\"object = \");\n                    s.push(Ice.identityToString(ref.getIdentity(), instance.toStringMode()));\n                    instance.initializationData().logger.trace(instance.traceLevels().locationCat, s.join(\"\"));\n                }\n\n                const e = new Ice.NotRegisteredException();\n                e.kindOfObject = \"object\";\n                e.id = Ice.identityToString(ref.getIdentity(), instance.toStringMode());\n                throw e;\n            }\n            else if(ex instanceof Ice.NotRegisteredException)\n            {\n                throw ex;\n            }\n            else if(ex instanceof Ice.LocalException)\n            {\n                if(instance.traceLevels().location >= 1)\n                {\n                    const s = [];\n                    s.push(\"couldn't contact the locator to retrieve endpoints\\n\");\n                    if(ref.getAdapterId().length > 0)\n                    {\n                        s.push(\"adapter = \");\n                        s.push(ref.getAdapterId());\n                        s.push(\"\\n\");\n                    }\n                    else\n                    {\n                        s.push(\"well-known proxy = \");\n                        s.push(ref.toString());\n                        s.push(\"\\n\");\n                    }\n                    s.push(\"reason = \" + ex.toString());\n                    instance.initializationData().logger.trace(instance.traceLevels().locationCat, s.join(\"\"));\n                }\n                throw ex;\n            }\n            else\n            {\n                Debug.assert(false);\n            }\n        }\n    }\n\n    getEndpointsTrace(ref, endpoints, cached)\n    {\n        if(endpoints !== null && endpoints.length > 0)\n        {\n            if(cached)\n            {\n                if(ref.isWellKnown())\n                {\n                    this.trace(\"found endpoints for well-known proxy in locator cache\", ref, endpoints);\n                }\n                else\n                {\n                    this.trace(\"found endpoints for adapter in locator cache\", ref, endpoints);\n                }\n            }\n            else if(ref.isWellKnown())\n            {\n                this.trace(\"retrieved endpoints for well-known proxy from locator, adding to locator cache\",\n                           ref, endpoints);\n            }\n            else\n            {\n                this.trace(\"retrieved endpoints for adapter from locator, adding to locator cache\",\n                           ref, endpoints);\n            }\n        }\n        else\n        {\n            const instance = ref.getInstance();\n            const s = [];\n            s.push(\"no endpoints configured for \");\n            if(ref.getAdapterId().length > 0)\n            {\n                s.push(\"adapter\\n\");\n                s.push(\"adapter = \");\n                s.push(ref.getAdapterId());\n                s.push(\"\\n\");\n            }\n            else\n            {\n                s.push(\"well-known object\\n\");\n                s.push(\"well-known proxy = \");\n                s.push(ref.toString());\n                s.push(\"\\n\");\n            }\n            instance.initializationData().logger.trace(instance.traceLevels().locationCat, s.join(\"\"));\n        }\n    }\n\n    getAdapterRequest(ref)\n    {\n        if(ref.getInstance().traceLevels().location >= 1)\n        {\n            const instance = ref.getInstance();\n            const s = [];\n            s.push(\"searching for adapter by id\\n\");\n            s.push(\"adapter = \");\n            s.push(ref.getAdapterId());\n            instance.initializationData().logger.trace(instance.traceLevels().locationCat, s.join(\"\"));\n        }\n\n        let request = this._adapterRequests.get(ref.getAdapterId());\n        if(request !== undefined)\n        {\n            return request;\n        }\n        request = new AdapterRequest(this, ref);\n        this._adapterRequests.set(ref.getAdapterId(), request);\n        return request;\n    }\n\n    getObjectRequest(ref)\n    {\n        if(ref.getInstance().traceLevels().location >= 1)\n        {\n            const instance = ref.getInstance();\n            const s = [];\n            s.push(\"searching for well-known object\\n\");\n            s.push(\"well-known proxy = \");\n            s.push(ref.toString());\n            instance.initializationData().logger.trace(instance.traceLevels().locationCat, s.join(\"\"));\n        }\n\n        let request = this._objectRequests.get(ref.getIdentity());\n        if(request !== undefined)\n        {\n            return request;\n        }\n        request = new ObjectRequest(this, ref);\n        this._objectRequests.set(ref.getIdentity(), request);\n        return request;\n    }\n\n    finishRequest(ref, wellKnownRefs, proxy, notRegistered)\n    {\n        if(proxy === null || proxy._getReference().isIndirect())\n        {\n            //\n            // Remove the cached references of well-known objects for which we tried\n            // to resolved the endpoints if these endpoints are empty.\n            //\n            for(let i = 0; i < wellKnownRefs.length; ++i)\n            {\n                this._table.removeObjectReference(wellKnownRefs[i].getIdentity());\n            }\n        }\n\n        if(!ref.isWellKnown())\n        {\n            if(proxy !== null && !proxy._getReference().isIndirect())\n            {\n                // Cache the adapter endpoints.\n                this._table.addAdapterEndpoints(ref.getAdapterId(), proxy._getReference().getEndpoints());\n            }\n            else if(notRegistered) // If the adapter isn't registered anymore, remove it from the cache.\n            {\n                this._table.removeAdapterEndpoints(ref.getAdapterId());\n            }\n\n            Debug.assert(this._adapterRequests.has(ref.getAdapterId()));\n            this._adapterRequests.delete(ref.getAdapterId());\n        }\n        else\n        {\n            if(proxy !== null && !proxy._getReference().isWellKnown())\n            {\n                // Cache the well-known object reference.\n                this._table.addObjectReference(ref.getIdentity(), proxy._getReference());\n            }\n            else if(notRegistered) // If the well-known object isn't registered anymore, remove it from the cache.\n            {\n                this._table.removeObjectReference(ref.getIdentity());\n            }\n\n            Debug.assert(this._objectRequests.has(ref.getIdentity()));\n            this._objectRequests.delete(ref.getIdentity());\n        }\n    }\n}\n\nIce.LocatorInfo = LocatorInfo;\n\nclass RequestCallback\n{\n    constructor(ref, ttl, promise)\n    {\n        this._ref = ref;\n        this._ttl = ttl;\n        this._promise = promise;\n    }\n\n    response(locatorInfo, proxy)\n    {\n        let endpoints = null;\n        if(proxy !== null)\n        {\n            const r = proxy._getReference();\n            if(this._ref.isWellKnown() && !Protocol.isSupported(this._ref.getEncoding(), r.getEncoding()))\n            {\n                //\n                // If a well-known proxy and the returned proxy\n                // encoding isn't supported, we're done: there's\n                // no compatible endpoint we can use.\n                //\n            }\n            else if(!r.isIndirect())\n            {\n                endpoints = r.getEndpoints();\n            }\n            else if(this._ref.isWellKnown() && !r.isWellKnown())\n            {\n                //\n                // We're resolving the endpoints of a well-known object and the proxy returned\n                // by the locator is an indirect proxy. We now need to resolve the endpoints\n                // of this indirect proxy.\n                //\n                if(this._ref.getInstance().traceLevels().location >= 1)\n                {\n                    locatorInfo.traceWellKnown(\"retrieved adapter for well-known object from locator, \" +\n                                               \"adding to locator cache\", this._ref, r);\n                }\n                locatorInfo.getEndpoints(r, this._ref, this._ttl).then(\n                    values =>\n                    {\n                        if(this._promise !== null)\n                        {\n                            this._promise.resolve(values);\n                        }\n                    },\n                    ex =>\n                    {\n                        if(this._promise !== null)\n                        {\n                            this._promise.reject(ex);\n                        }\n                    });\n                return;\n            }\n        }\n\n        if(this._ref.getInstance().traceLevels().location >= 1)\n        {\n            locatorInfo.getEndpointsTrace(this._ref, endpoints, false);\n        }\n\n        if(this._promise !== null)\n        {\n            this._promise.resolve(endpoints === null ? [[], false] : [endpoints, false]);\n        }\n    }\n\n    exception(locatorInfo, exc)\n    {\n        try\n        {\n            locatorInfo.getEndpointsException(this._ref, exc); // This throws.\n        }\n        catch(ex)\n        {\n            if(this._promise !== null)\n            {\n                this._promise.reject(ex);\n            }\n        }\n    }\n}\n\nclass Request\n{\n    constructor(locatorInfo, ref)\n    {\n        this._locatorInfo = locatorInfo;\n        this._ref = ref;\n\n        this._callbacks = []; // Array<RequestCallback>\n        this._wellKnownRefs = []; // Array<Reference>\n        this._sent = false;\n        this._response = false;\n        this._proxy = null;\n        this._exception = null;\n    }\n\n    addCallback(ref, wellKnownRef, ttl, promise)\n    {\n        const callback = new RequestCallback(ref, ttl, promise);\n        if(this._response)\n        {\n            callback.response(this._locatorInfo, this._proxy);\n        }\n        else if(this._exception !== null)\n        {\n            callback.exception(this._locatorInfo, this._exception);\n        }\n        else\n        {\n            this._callbacks.push(callback);\n            if(wellKnownRef !== null) // This request is to resolve the endpoints of a cached well-known object ref\n            {\n                this._wellKnownRefs.push(wellKnownRef);\n            }\n            if(!this._sent)\n            {\n                this._sent = true;\n                this.send();\n            }\n        }\n    }\n\n    response(proxy)\n    {\n        this._locatorInfo.finishRequest(this._ref, this._wellKnownRefs, proxy, false);\n        this._response = true;\n        this._proxy = proxy;\n        for(let i = 0; i < this._callbacks.length; ++i)\n        {\n            this._callbacks[i].response(this._locatorInfo, proxy);\n        }\n    }\n\n    exception(ex)\n    {\n        this._locatorInfo.finishRequest(this._ref, this._wellKnownRefs, null, ex instanceof Ice.UserException);\n        this._exception = ex;\n        for(let i = 0; i < this._callbacks.length; ++i)\n        {\n            this._callbacks[i].exception(this._locatorInfo, ex);\n        }\n    }\n}\n\nclass ObjectRequest extends Request\n{\n    constructor(locatorInfo, reference)\n    {\n        super(locatorInfo, reference);\n        Debug.assert(reference.isWellKnown());\n    }\n\n    send()\n    {\n        try\n        {\n            this._locatorInfo.getLocator().findObjectById(this._ref.getIdentity()).then(\n                proxy => this.response(proxy),\n                ex => this.exception(ex));\n        }\n        catch(ex)\n        {\n            this.exception(ex);\n        }\n    }\n}\n\nclass AdapterRequest extends Request\n{\n    constructor(locatorInfo, reference)\n    {\n        super(locatorInfo, reference);\n        Debug.assert(reference.isIndirect());\n    }\n\n    send()\n    {\n        try\n        {\n            this._locatorInfo.getLocator().findAdapterById(this._ref.getAdapterId()).then(\n                proxy => this.response(proxy),\n                ex => this.exception(ex));\n        }\n        catch(ex)\n        {\n            this.exception(ex);\n        }\n    }\n}\n\nmodule.exports.Ice = Ice;\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/LocatorInfo.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/LocatorManager.js":
/*!****************************************************!*\
  !*** ./node_modules/ice/src/Ice/LocatorManager.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nconst Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/Locator */ \"./node_modules/ice/src/Ice/Locator.js\");\n__webpack_require__(/*! ../Ice/LocatorInfo */ \"./node_modules/ice/src/Ice/LocatorInfo.js\");\n__webpack_require__(/*! ../Ice/LocatorTable */ \"./node_modules/ice/src/Ice/LocatorTable.js\");\n\nconst HashMap = Ice.HashMap;\nconst LocatorInfo = Ice.LocatorInfo;\nconst LocatorPrx = Ice.LocatorPrx;\nconst LocatorTable = Ice.LocatorTable;\n\nclass LocatorManager\n{\n    constructor(properties)\n    {\n        this._background = properties.getPropertyAsInt(\"Ice.BackgroundLocatorCacheUpdates\") > 0;\n        this._table = new HashMap(HashMap.compareEquals); // Map<Ice.LocatorPrx, LocatorInfo>\n        this._locatorTables = new HashMap(HashMap.compareEquals); // Map<Ice.Identity, LocatorTable>\n    }\n\n    destroy()\n    {\n        for(const locator of this._table.values())\n        {\n            locator.destroy();\n        }\n        this._table.clear();\n        this._locatorTables.clear();\n    }\n\n    //\n    // Returns locator info for a given locator. Automatically creates\n    // the locator info if it doesn't exist yet.\n    //\n    find(loc)\n    {\n        if(loc === null)\n        {\n            return null;\n        }\n\n        //\n        // The locator can't be located.\n        //\n        const locator = LocatorPrx.uncheckedCast(loc.ice_locator(null));\n\n        //\n        // TODO: reap unused locator info objects?\n        //\n        let info = this._table.get(locator);\n        if(info === undefined)\n        {\n            //\n            // Rely on locator identity for the adapter table. We want to\n            // have only one table per locator (not one per locator\n            // proxy).\n            //\n            let table = this._locatorTables.get(locator.ice_getIdentity());\n            if(table === undefined)\n            {\n                table = new LocatorTable();\n                this._locatorTables.set(locator.ice_getIdentity(), table);\n            }\n\n            info = new LocatorInfo(locator, table, this._background);\n            this._table.set(locator, info);\n        }\n\n        return info;\n    }\n}\n\nIce.LocatorManager = LocatorManager;\nmodule.exports.Ice = Ice;\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/LocatorManager.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/LocatorTable.js":
/*!**************************************************!*\
  !*** ./node_modules/ice/src/Ice/LocatorTable.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nconst Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n\n__webpack_require__(/*! ../Ice/Debug */ \"./node_modules/ice/src/Ice/Debug.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/IdentityUtil */ \"./node_modules/ice/src/Ice/IdentityUtil.js\");\n\nconst Debug = Ice.Debug;\nconst HashMap = Ice.HashMap;\n\nclass EndpointTableEntry\n{\n    constructor(time, endpoints)\n    {\n        this.time = time;\n        this.endpoints = endpoints;\n    }\n}\n\nclass ReferenceTableEntry\n{\n    constructor(time, reference)\n    {\n        this.time = time;\n        this.reference = reference;\n    }\n}\n\nclass LocatorTable\n{\n    constructor()\n    {\n        this._adapterEndpointsTable = new Map(); // Map<String, EndpointTableEntry>\n        this._objectTable = new HashMap(HashMap.compareEquals); // Map<Ice.Identity, ReferenceTableEntry>\n    }\n\n    clear()\n    {\n        this._adapterEndpointsTable.clear();\n        this._objectTable.clear();\n    }\n\n    getAdapterEndpoints(adapter, ttl, cached)\n    {\n        if(ttl === 0) // Locator cache disabled.\n        {\n            cached.value = false;\n            return null;\n        }\n\n        const entry = this._adapterEndpointsTable.get(adapter);\n        if(entry !== undefined)\n        {\n            cached.value = this.checkTTL(entry.time, ttl);\n            return entry.endpoints;\n        }\n        cached.value = false;\n        return null;\n    }\n\n    addAdapterEndpoints(adapter, endpoints)\n    {\n        this._adapterEndpointsTable.set(adapter, new EndpointTableEntry(Date.now(), endpoints));\n    }\n\n    removeAdapterEndpoints(adapter)\n    {\n        const entry = this._adapterEndpointsTable.get(adapter);\n        this._adapterEndpointsTable.delete(adapter);\n        return entry !== undefined ? entry.endpoints : null;\n    }\n\n    getObjectReference(id, ttl, cached)\n    {\n        if(ttl === 0) // Locator cache disabled.\n        {\n            cached.value = false;\n            return null;\n        }\n\n        const entry = this._objectTable.get(id);\n        if(entry !== undefined)\n        {\n            cached.value = this.checkTTL(entry.time, ttl);\n            return entry.reference;\n        }\n        cached.value = false;\n        return null;\n    }\n\n    addObjectReference(id, ref)\n    {\n        this._objectTable.set(id, new ReferenceTableEntry(Date.now(), ref));\n    }\n\n    removeObjectReference(id)\n    {\n        const entry = this._objectTable.get(id);\n        this._objectTable.delete(id);\n        return entry !== undefined ? entry.reference : null;\n    }\n\n    checkTTL(time, ttl)\n    {\n        Debug.assert(ttl !== 0);\n        if(ttl < 0) // TTL = infinite\n        {\n            return true;\n        }\n        else\n        {\n            return Date.now() - time <= (ttl * 1000);\n        }\n    }\n}\n\nIce.LocatorTable = LocatorTable;\nmodule.exports.Ice = Ice;\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/LocatorTable.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/Logger.js":
/*!********************************************!*\
  !*** ./node_modules/ice/src/Ice/Logger.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n//\n// Ice version 3.7.10\n//\n// <auto-generated>\n//\n// Generated from file `Logger.ice'\n//\n// Warning: do not edit this file.\n//\n// </auto-generated>\n//\n\n/* eslint-disable */\n/* jshint ignore: start */\n\n/* slice2js browser-bundle-skip */\nconst _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\n__webpack_require__(/*! ../Ice/Object */ \"./node_modules/ice/src/Ice/Object.js\");\n__webpack_require__(/*! ../Ice/Value */ \"./node_modules/ice/src/Ice/Value.js\");\n__webpack_require__(/*! ../Ice/ObjectPrx */ \"./node_modules/ice/src/Ice/ObjectPrx.js\");\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\nconst Ice = _ModuleRegistry.module(\"Ice\");\n\nconst Slice = Ice.Slice;\n/* slice2js browser-bundle-skip-end */\n/* slice2js browser-bundle-skip */\nexports.Ice = Ice;\n/* slice2js browser-bundle-skip-end */\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/Logger.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/LoggerF.js":
/*!*********************************************!*\
  !*** ./node_modules/ice/src/Ice/LoggerF.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n//\n// Ice version 3.7.10\n//\n// <auto-generated>\n//\n// Generated from file `LoggerF.ice'\n//\n// Warning: do not edit this file.\n//\n// </auto-generated>\n//\n\n/* eslint-disable */\n/* jshint ignore: start */\n\n/* slice2js browser-bundle-skip */\nconst _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\nconst Ice = _ModuleRegistry.module(\"Ice\");\n\nconst Slice = Ice.Slice;\n/* slice2js browser-bundle-skip-end */\n/* slice2js browser-bundle-skip */\nexports.Ice = Ice;\n/* slice2js browser-bundle-skip-end */\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/LoggerF.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/LoggerI.js":
/*!*********************************************!*\
  !*** ./node_modules/ice/src/Ice/LoggerI.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nconst Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n\nclass Logger\n{\n    constructor(prefix)\n    {\n        if(prefix !== undefined && prefix.length > 0)\n        {\n            this._prefix = prefix + \": \";\n        }\n        else\n        {\n            this._prefix = \"\";\n        }\n\n        this._dateformat =\n        {\n            year: 'numeric',\n            month: 'numeric',\n            day: 'numeric',\n            hour: 'numeric',\n            minute: 'numeric',\n            second: 'numeric',\n            hour12: false\n        };\n    }\n\n    print(message)\n    {\n        this.write(message, false);\n    }\n\n    trace(category, message)\n    {\n        const s = [];\n        s.push(\"-- \");\n        s.push(this.timestamp());\n        s.push(' ');\n        s.push(this._prefix);\n        s.push(category);\n        s.push(\": \");\n        s.push(message);\n        this.write(s.join(\"\"), true);\n    }\n\n    warning(message)\n    {\n        const s = [];\n        s.push(\"-! \");\n        s.push(this.timestamp());\n        s.push(' ');\n        s.push(this._prefix);\n        s.push(\"warning: \");\n        s.push(message);\n        this.write(s.join(\"\"), true);\n    }\n\n    error(message)\n    {\n        const s = [];\n        s.push(\"!! \");\n        s.push(this.timestamp());\n        s.push(' ');\n        s.push(this._prefix);\n        s.push(\"error: \");\n        s.push(message);\n        this.write(s.join(\"\"), true);\n    }\n\n    cloneWithPrefix(prefix)\n    {\n        return new Logger(prefix);\n    }\n\n    write(message, indent)\n    {\n        if(indent)\n        {\n            message = message.replace(/\\n/g, \"\\n   \");\n        }\n\n        console.log(message);\n    }\n\n    timestamp()\n    {\n        const d = new Date();\n        return d.toLocaleString(\"en-US\", this._dateformat) + \".\" + d.getMilliseconds();\n    }\n}\n\nIce.Logger = Logger;\nmodule.exports.Ice = Ice;\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/LoggerI.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/Long.js":
/*!******************************************!*\
  !*** ./node_modules/ice/src/Ice/Long.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nconst Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n\n//\n// The Long type represents a signed 64-bit integer as two 32-bit values\n// corresponding to the high and low words.\n//\nclass Long\n{\n    //\n    // If only one argument is provide we assume it is a JavaScript Number,\n    // and we convert it to two 32 bit words to fit in the Ice.Long internal\n    // representation.\n    //\n    // If two arguments are provided we asume these are the high and low words\n    // respectively.\n    //\n    constructor(high = 0, low = undefined)\n    {\n        if(!Number.isSafeInteger(high))\n        {\n            throw new RangeError(low === undefined ?\n                    \"Number must be a safe integer\" :\n                    \"High word must be a safe integer\");\n        }\n\n        if(low === undefined)\n        {\n            this.low = high >>> 0;\n            this.high = ((high - this.low) / Long.HIGH_MASK) >>> 0;\n        }\n        else\n        {\n            if(!Number.isSafeInteger(low))\n            {\n                throw new RangeError(\"Low word must be a safe integer\");\n            }\n            if(low < 0 || low > Long.MAX_UINT32)\n            {\n                throw new RangeError(\"Low word must be between 0 and 0xFFFFFFFF\");\n            }\n            if(high < 0 || high > Long.MAX_UINT32)\n            {\n                throw new RangeError(\"High word must be between 0 and 0xFFFFFFFF\");\n            }\n\n            this.high = high;\n            this.low = low;\n        }\n    }\n\n    hashCode()\n    {\n        return this.low;\n    }\n\n    equals(rhs)\n    {\n        if(this === rhs)\n        {\n            return true;\n        }\n        if(!(rhs instanceof Long))\n        {\n            return false;\n        }\n        return this.high === rhs.high && this.low === rhs.low;\n    }\n\n    toString()\n    {\n        return this.high + \":\" + this.low;\n    }\n\n    toNumber()\n    {\n        if((this.high & Long.SIGN_MASK) !== 0)\n        {\n            const l = (~this.low) >>> 0;\n            const h = (~this.high) >>> 0;\n            if(h > Long.HIGH_MAX || h == Long.HIGH_MAX && l == Long.MAX_UINT32)\n            {\n                return Number.NEGATIVE_INFINITY;\n            }\n            return -((h * Long.HIGH_MASK) + l + 1);\n        }\n        else\n        {\n            if(this.high > Long.HIGH_MAX)\n            {\n                return Number.POSITIVE_INFINITY;\n            }\n            return (this.high * Long.HIGH_MASK) + this.low;\n        }\n    }\n}\n\n//\n// 2^32\n//\nLong.MAX_UINT32 = 0xFFFFFFFF;\n\n//\n// (high & SIGN_MASK) != 0 denotes a negative number;\n// that is, the most significant bit is set.\n//\nLong.SIGN_MASK = 0x80000000;\n\n//\n// When converting to a JavaScript Number we left shift the\n// high word by 32 bits. As that isn't possible using JavaScript's\n// left shift operator, we multiply the value by 2^32 which will\n// produce the same result.\n//\nLong.HIGH_MASK = 0x100000000;\n\n//\n// The maximum value for the high word when coverting to\n// a JavaScript Number is 2^21 - 1, in which case all\n// 53 bits are used.\n//\nLong.HIGH_MAX = 0x1FFFFF;\n\nIce.Long = Long;\nmodule.exports.Ice = Ice;\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/Long.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/MapUtil.js":
/*!*********************************************!*\
  !*** ./node_modules/ice/src/Ice/MapUtil.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nconst Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n\nclass MapUtil\n{\n    static equals(m1, m2)\n    {\n        if(m1 === m2)\n        {\n            return true;\n        }\n        else if(m1.size != m2.size)\n        {\n            return false;\n        }\n        else\n        {\n            for(const [key, value] of m1)\n            {\n                if(value === undefined)\n                {\n                    if(!m2.has(key))\n                    {\n                        return false;\n                    }\n                    else if(m2.get(key) !== value)\n                    {\n                        return false;\n                    }\n                }\n                else if(m2.get(key) !== value)\n                {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n}\n\nIce.MapUtil = MapUtil;\n\nmodule.exports.Ice = Ice;\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/MapUtil.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/Metrics.js":
/*!*********************************************!*\
  !*** ./node_modules/ice/src/Ice/Metrics.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n//\n// Ice version 3.7.10\n//\n// <auto-generated>\n//\n// Generated from file `Metrics.ice'\n//\n// Warning: do not edit this file.\n//\n// </auto-generated>\n//\n\n/* eslint-disable */\n/* jshint ignore: start */\n\n/* slice2js browser-bundle-skip */\nconst _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\n__webpack_require__(/*! ../Ice/Object */ \"./node_modules/ice/src/Ice/Object.js\");\n__webpack_require__(/*! ../Ice/Value */ \"./node_modules/ice/src/Ice/Value.js\");\n__webpack_require__(/*! ../Ice/ObjectPrx */ \"./node_modules/ice/src/Ice/ObjectPrx.js\");\n__webpack_require__(/*! ../Ice/Operation */ \"./node_modules/ice/src/Ice/Operation.js\");\n__webpack_require__(/*! ../Ice/Struct */ \"./node_modules/ice/src/Ice/Struct.js\");\n__webpack_require__(/*! ../Ice/Exception */ \"./node_modules/ice/src/Ice/Exception.js\");\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\n__webpack_require__(/*! ../Ice/BuiltinSequences */ \"./node_modules/ice/src/Ice/BuiltinSequences.js\");\nconst Ice = _ModuleRegistry.module(\"Ice\");\n\nconst Slice = Ice.Slice;\n/* slice2js browser-bundle-skip-end */\n/* slice2js browser-bundle-skip */\n\nlet IceMX = _ModuleRegistry.module(\"IceMX\");\n/* slice2js browser-bundle-skip-end */\n\nSlice.defineDictionary(IceMX, \"StringIntDict\", \"StringIntDictHelper\", \"Ice.StringHelper\", \"Ice.IntHelper\", false, undefined, undefined);\n\nconst iceC_IceMX_Metrics_ids = [\n    \"::Ice::Object\",\n    \"::IceMX::Metrics\"\n];\n\n/**\n * The base class for metrics. A metrics object represents a\n * collection of measurements associated to a given a system.\n *\n **/\nIceMX.Metrics = class extends Ice.Value\n{\n    constructor(id = \"\", total = new Ice.Long(0, 0), current = 0, totalLifetime = new Ice.Long(0, 0), failures = 0)\n    {\n        super();\n        this.id = id;\n        this.total = total;\n        this.current = current;\n        this.totalLifetime = totalLifetime;\n        this.failures = failures;\n    }\n\n    _iceWriteMemberImpl(ostr)\n    {\n        ostr.writeString(this.id);\n        ostr.writeLong(this.total);\n        ostr.writeInt(this.current);\n        ostr.writeLong(this.totalLifetime);\n        ostr.writeInt(this.failures);\n    }\n\n    _iceReadMemberImpl(istr)\n    {\n        this.id = istr.readString();\n        this.total = istr.readLong();\n        this.current = istr.readInt();\n        this.totalLifetime = istr.readLong();\n        this.failures = istr.readInt();\n    }\n};\n\nSlice.defineValue(IceMX.Metrics, iceC_IceMX_Metrics_ids[1], false);\n\n/**\n * A structure to keep track of failures associated with a given\n * metrics.\n *\n **/\nIceMX.MetricsFailures = class\n{\n    constructor(id = \"\", failures = null)\n    {\n        this.id = id;\n        this.failures = failures;\n    }\n\n    _write(ostr)\n    {\n        ostr.writeString(this.id);\n        IceMX.StringIntDictHelper.write(ostr, this.failures);\n    }\n\n    _read(istr)\n    {\n        this.id = istr.readString();\n        this.failures = IceMX.StringIntDictHelper.read(istr);\n    }\n\n    static get minWireSize()\n    {\n        return  2;\n    }\n};\n\nSlice.defineStruct(IceMX.MetricsFailures, false, true);\n\nSlice.defineSequence(IceMX, \"MetricsFailuresSeqHelper\", \"IceMX.MetricsFailures\", false);\n\nSlice.defineSequence(IceMX, \"MetricsMapHelper\", \"Ice.ObjectHelper\", false, \"IceMX.Metrics\");\n\nSlice.defineDictionary(IceMX, \"MetricsView\", \"MetricsViewHelper\", \"Ice.StringHelper\", \"IceMX.MetricsMapHelper\", false, undefined, undefined, Ice.ArrayUtil.equals);\n\n/**\n * Raised if a metrics view cannot be found.\n *\n **/\nIceMX.UnknownMetricsView = class extends Ice.UserException\n{\n    constructor(_cause = \"\")\n    {\n        super(_cause);\n    }\n\n    static get _parent()\n    {\n        return Ice.UserException;\n    }\n\n    static get _id()\n    {\n        return \"::IceMX::UnknownMetricsView\";\n    }\n\n    _mostDerivedType()\n    {\n        return IceMX.UnknownMetricsView;\n    }\n};\n\nconst iceC_IceMX_MetricsAdmin_ids = [\n    \"::Ice::Object\",\n    \"::IceMX::MetricsAdmin\"\n];\n\n/**\n * The metrics administrative facet interface. This interface allows\n * remote administrative clients to access metrics of an application\n * that enabled the Ice administrative facility and configured some\n * metrics views.\n *\n **/\nIceMX.MetricsAdmin = class extends Ice.Object\n{\n};\n\nIceMX.MetricsAdminPrx = class extends Ice.ObjectPrx\n{\n};\n\nSlice.defineOperations(IceMX.MetricsAdmin, IceMX.MetricsAdminPrx, iceC_IceMX_MetricsAdmin_ids, 1,\n{\n    \"getMetricsViewNames\": [, , , 2, [\"Ice.StringSeqHelper\"], , [[\"Ice.StringSeqHelper\"]], , , ],\n    \"enableMetricsView\": [, , , 2, , [[7]], ,\n    [\n        IceMX.UnknownMetricsView\n    ], , ],\n    \"disableMetricsView\": [, , , 2, , [[7]], ,\n    [\n        IceMX.UnknownMetricsView\n    ], , ],\n    \"getMetricsView\": [, , , 2, [\"IceMX.MetricsViewHelper\"], [[7]], [[4]],\n    [\n        IceMX.UnknownMetricsView\n    ], , true],\n    \"getMapMetricsFailures\": [, , , 2, [\"IceMX.MetricsFailuresSeqHelper\"], [[7], [7]], ,\n    [\n        IceMX.UnknownMetricsView\n    ], , ],\n    \"getMetricsFailures\": [, , , 2, [IceMX.MetricsFailures], [[7], [7], [7]], ,\n    [\n        IceMX.UnknownMetricsView\n    ], , ]\n});\n\nconst iceC_IceMX_ThreadMetrics_ids = [\n    \"::Ice::Object\",\n    \"::IceMX::Metrics\",\n    \"::IceMX::ThreadMetrics\"\n];\n\n/**\n * Provides information on the number of threads currently in use and\n * their activity.\n *\n **/\nIceMX.ThreadMetrics = class extends IceMX.Metrics\n{\n    constructor(id, total, current, totalLifetime, failures, inUseForIO = 0, inUseForUser = 0, inUseForOther = 0)\n    {\n        super(id, total, current, totalLifetime, failures);\n        this.inUseForIO = inUseForIO;\n        this.inUseForUser = inUseForUser;\n        this.inUseForOther = inUseForOther;\n    }\n\n    _iceWriteMemberImpl(ostr)\n    {\n        ostr.writeInt(this.inUseForIO);\n        ostr.writeInt(this.inUseForUser);\n        ostr.writeInt(this.inUseForOther);\n    }\n\n    _iceReadMemberImpl(istr)\n    {\n        this.inUseForIO = istr.readInt();\n        this.inUseForUser = istr.readInt();\n        this.inUseForOther = istr.readInt();\n    }\n};\n\nSlice.defineValue(IceMX.ThreadMetrics, iceC_IceMX_ThreadMetrics_ids[2], false);\n\nconst iceC_IceMX_DispatchMetrics_ids = [\n    \"::Ice::Object\",\n    \"::IceMX::DispatchMetrics\",\n    \"::IceMX::Metrics\"\n];\n\n/**\n * Provides information on servant dispatch.\n *\n **/\nIceMX.DispatchMetrics = class extends IceMX.Metrics\n{\n    constructor(id, total, current, totalLifetime, failures, userException = 0, size = new Ice.Long(0, 0), replySize = new Ice.Long(0, 0))\n    {\n        super(id, total, current, totalLifetime, failures);\n        this.userException = userException;\n        this.size = size;\n        this.replySize = replySize;\n    }\n\n    _iceWriteMemberImpl(ostr)\n    {\n        ostr.writeInt(this.userException);\n        ostr.writeLong(this.size);\n        ostr.writeLong(this.replySize);\n    }\n\n    _iceReadMemberImpl(istr)\n    {\n        this.userException = istr.readInt();\n        this.size = istr.readLong();\n        this.replySize = istr.readLong();\n    }\n};\n\nSlice.defineValue(IceMX.DispatchMetrics, iceC_IceMX_DispatchMetrics_ids[1], false);\n\nconst iceC_IceMX_ChildInvocationMetrics_ids = [\n    \"::Ice::Object\",\n    \"::IceMX::ChildInvocationMetrics\",\n    \"::IceMX::Metrics\"\n];\n\n/**\n * Provides information on child invocations. A child invocation is\n * either remote (sent over an Ice connection) or collocated. An\n * invocation can have multiple child invocation if it is\n * retried. Child invocation metrics are embedded within\n * {@link InvocationMetrics}.\n *\n **/\nIceMX.ChildInvocationMetrics = class extends IceMX.Metrics\n{\n    constructor(id, total, current, totalLifetime, failures, size = new Ice.Long(0, 0), replySize = new Ice.Long(0, 0))\n    {\n        super(id, total, current, totalLifetime, failures);\n        this.size = size;\n        this.replySize = replySize;\n    }\n\n    _iceWriteMemberImpl(ostr)\n    {\n        ostr.writeLong(this.size);\n        ostr.writeLong(this.replySize);\n    }\n\n    _iceReadMemberImpl(istr)\n    {\n        this.size = istr.readLong();\n        this.replySize = istr.readLong();\n    }\n};\n\nSlice.defineValue(IceMX.ChildInvocationMetrics, iceC_IceMX_ChildInvocationMetrics_ids[1], false);\n\nconst iceC_IceMX_CollocatedMetrics_ids = [\n    \"::Ice::Object\",\n    \"::IceMX::ChildInvocationMetrics\",\n    \"::IceMX::CollocatedMetrics\",\n    \"::IceMX::Metrics\"\n];\n\n/**\n * Provides information on invocations that are collocated. Collocated\n * metrics are embedded within {@link InvocationMetrics}.\n *\n **/\nIceMX.CollocatedMetrics = class extends IceMX.ChildInvocationMetrics\n{\n    constructor(id, total, current, totalLifetime, failures, size, replySize)\n    {\n        super(id, total, current, totalLifetime, failures, size, replySize);\n    }\n};\n\nSlice.defineValue(IceMX.CollocatedMetrics, iceC_IceMX_CollocatedMetrics_ids[2], false);\n\nconst iceC_IceMX_RemoteMetrics_ids = [\n    \"::Ice::Object\",\n    \"::IceMX::ChildInvocationMetrics\",\n    \"::IceMX::Metrics\",\n    \"::IceMX::RemoteMetrics\"\n];\n\n/**\n * Provides information on invocations that are specifically sent over\n * Ice connections. Remote metrics are embedded within {@link InvocationMetrics}.\n *\n **/\nIceMX.RemoteMetrics = class extends IceMX.ChildInvocationMetrics\n{\n    constructor(id, total, current, totalLifetime, failures, size, replySize)\n    {\n        super(id, total, current, totalLifetime, failures, size, replySize);\n    }\n};\n\nSlice.defineValue(IceMX.RemoteMetrics, iceC_IceMX_RemoteMetrics_ids[3], false);\n\nconst iceC_IceMX_InvocationMetrics_ids = [\n    \"::Ice::Object\",\n    \"::IceMX::InvocationMetrics\",\n    \"::IceMX::Metrics\"\n];\n\n/**\n * Provide measurements for proxy invocations. Proxy invocations can\n * either be sent over the wire or be collocated.\n *\n **/\nIceMX.InvocationMetrics = class extends IceMX.Metrics\n{\n    constructor(id, total, current, totalLifetime, failures, retry = 0, userException = 0, remotes = null, collocated = null)\n    {\n        super(id, total, current, totalLifetime, failures);\n        this.retry = retry;\n        this.userException = userException;\n        this.remotes = remotes;\n        this.collocated = collocated;\n    }\n\n    _iceWriteMemberImpl(ostr)\n    {\n        ostr.writeInt(this.retry);\n        ostr.writeInt(this.userException);\n        IceMX.MetricsMapHelper.write(ostr, this.remotes);\n        IceMX.MetricsMapHelper.write(ostr, this.collocated);\n    }\n\n    _iceReadMemberImpl(istr)\n    {\n        this.retry = istr.readInt();\n        this.userException = istr.readInt();\n        this.remotes = IceMX.MetricsMapHelper.read(istr);\n        this.collocated = IceMX.MetricsMapHelper.read(istr);\n    }\n};\n\nSlice.defineValue(IceMX.InvocationMetrics, iceC_IceMX_InvocationMetrics_ids[1], false);\n\nconst iceC_IceMX_ConnectionMetrics_ids = [\n    \"::Ice::Object\",\n    \"::IceMX::ConnectionMetrics\",\n    \"::IceMX::Metrics\"\n];\n\n/**\n * Provides information on the data sent and received over Ice\n * connections.\n *\n **/\nIceMX.ConnectionMetrics = class extends IceMX.Metrics\n{\n    constructor(id, total, current, totalLifetime, failures, receivedBytes = new Ice.Long(0, 0), sentBytes = new Ice.Long(0, 0))\n    {\n        super(id, total, current, totalLifetime, failures);\n        this.receivedBytes = receivedBytes;\n        this.sentBytes = sentBytes;\n    }\n\n    _iceWriteMemberImpl(ostr)\n    {\n        ostr.writeLong(this.receivedBytes);\n        ostr.writeLong(this.sentBytes);\n    }\n\n    _iceReadMemberImpl(istr)\n    {\n        this.receivedBytes = istr.readLong();\n        this.sentBytes = istr.readLong();\n    }\n};\n\nSlice.defineValue(IceMX.ConnectionMetrics, iceC_IceMX_ConnectionMetrics_ids[1], false);\n/* slice2js browser-bundle-skip */\nexports.IceMX = IceMX;\n/* slice2js browser-bundle-skip-end */\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/Metrics.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/ModuleRegistry.js":
/*!****************************************************!*\
  !*** ./node_modules/ice/src/Ice/ModuleRegistry.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nlet Ice = {};\n\nif (typeof process !== 'undefined')\n{\n    const modules = {};\n\n    class _ModuleRegistry\n    {\n        static module(name)\n        {\n            let m = modules[name];\n            if(m === undefined)\n            {\n                m = {};\n                modules[name] = m;\n            }\n            return m;\n        }\n\n        static require(m, paths)\n        {\n            let o;\n            paths.forEach(path =>\n                {\n                    o = m.require(path);\n                });\n            return o;\n        }\n\n        static type(scoped)\n        {\n            if(scoped === undefined)\n            {\n                return undefined;\n            }\n\n            const components = scoped.split(\".\");\n            let type = modules;\n            for(let i = 0; i < components.length; ++i)\n            {\n                type = type[components[i]];\n                if(type === undefined)\n                {\n                    return undefined;\n                }\n            }\n            return type;\n        }\n    }\n\n    Ice = _ModuleRegistry.module(\"Ice\");\n    Ice.Slice = Ice.Slice || {};\n    Ice._ModuleRegistry = _ModuleRegistry;\n}\nelse\n{\n    /* global\n        self : false\n    */\n    const root = typeof window !== \"undefined\" ? window :\n        typeof __webpack_require__.g !== \"undefined\" ? __webpack_require__.g :\n        typeof self !== \"undefined\" ? self : {};\n    /* global\n        self : true\n    */\n    class _ModuleRegistry\n    {\n        static module(name)\n        {\n            let m = root[name];\n            if(m === undefined)\n            {\n                m = {};\n                root[name] = m;\n            }\n            return m;\n        }\n\n        static require(name)\n        {\n            return root;\n        }\n\n        static type(scoped)\n        {\n            if(scoped === undefined)\n            {\n                return undefined;\n            }\n            const components = scoped.split(\".\");\n            let type = root;\n            for(let i = 0, length = components.length; i < length; ++i)\n            {\n                type = type[components[i]];\n                if(type === undefined)\n                {\n                    return undefined;\n                }\n            }\n            return type;\n        }\n    }\n\n    Ice = _ModuleRegistry.module(\"Ice\");\n\n    Ice._require = function()\n    {\n        return root;\n    };\n\n    Ice.Slice = Ice.Slice || {};\n    Ice._ModuleRegistry = _ModuleRegistry;\n}\n\nexports.Ice = Ice;\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/ModuleRegistry.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/Object.js":
/*!********************************************!*\
  !*** ./node_modules/ice/src/Ice/Object.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\n//\n// Ice.Object\n//\n// Using IceObject in this file to avoid collisions with the native Object.\n//\nconst Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n\n__webpack_require__(/*! ../Ice/Exception */ \"./node_modules/ice/src/Ice/Exception.js\");\n__webpack_require__(/*! ../Ice/FormatType */ \"./node_modules/ice/src/Ice/FormatType.js\");\n__webpack_require__(/*! ../Ice/OptionalFormat */ \"./node_modules/ice/src/Ice/OptionalFormat.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\n\nIce.Object = class\n{\n    ice_isA(s, current)\n    {\n        return this._iceMostDerivedType()._iceIds.indexOf(s) >= 0;\n    }\n\n    ice_ping(current)\n    {\n    }\n\n    ice_ids(current)\n    {\n        return this._iceMostDerivedType()._iceIds;\n    }\n\n    ice_id(current)\n    {\n        return this._iceMostDerivedType()._iceId;\n    }\n\n    toString()\n    {\n        return \"[object \" + this.ice_id() + \"]\";\n    }\n\n    //\n    // _iceMostDerivedType returns the the most derived Ice generated class. This is\n    // necessary because the user might extend Slice generated classes. The user\n    // class extensions don't have _iceId, _iceIds, etc static members so the implementation\n    // of ice_id and ice_ids would fail trying to access those members of the user\n    // defined class. Instead, ice_id, ice_ids and ice_instanceof call _iceMostDerivedType\n    // to get the most derived Ice class.\n    //\n    _iceMostDerivedType()\n    {\n        return Ice.Object;\n    }\n\n    //\n    // The default implementation of equals compare references.\n    //\n    equals(other)\n    {\n        return this === other;\n    }\n\n    static get _iceImplements()\n    {\n        return [];\n    }\n};\n\nmodule.exports.Ice = Ice;\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/Object.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/ObjectAdapterF.js":
/*!****************************************************!*\
  !*** ./node_modules/ice/src/Ice/ObjectAdapterF.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n//\n// Ice version 3.7.10\n//\n// <auto-generated>\n//\n// Generated from file `ObjectAdapterF.ice'\n//\n// Warning: do not edit this file.\n//\n// </auto-generated>\n//\n\n/* eslint-disable */\n/* jshint ignore: start */\n\n/* slice2js browser-bundle-skip */\nconst _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\nconst Ice = _ModuleRegistry.module(\"Ice\");\n\nconst Slice = Ice.Slice;\n/* slice2js browser-bundle-skip-end */\n/* slice2js browser-bundle-skip */\nexports.Ice = Ice;\n/* slice2js browser-bundle-skip-end */\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/ObjectAdapterF.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/ObjectAdapterFactory.js":
/*!**********************************************************!*\
  !*** ./node_modules/ice/src/Ice/ObjectAdapterFactory.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nconst Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n\n__webpack_require__(/*! ../Ice/LocalException */ \"./node_modules/ice/src/Ice/LocalException.js\");\n__webpack_require__(/*! ../Ice/ObjectAdapterI */ \"./node_modules/ice/src/Ice/ObjectAdapterI.js\");\n__webpack_require__(/*! ../Ice/Promise */ \"./node_modules/ice/src/Ice/Promise.js\");\n__webpack_require__(/*! ../Ice/UUID */ \"./node_modules/ice/src/Ice/UUID.js\");\n\nconst ObjectAdapterI = Ice.ObjectAdapterI;\nconst _Promise = Ice.Promise;\n\n//\n// Only for use by Instance.\n//\nclass ObjectAdapterFactory\n{\n    constructor(instance, communicator)\n    {\n        this._instance = instance;\n        this._communicator = communicator;\n        this._adapters = [];\n        this._adapterNamesInUse = [];\n        this._shutdownPromise = new _Promise();\n    }\n\n    shutdown()\n    {\n        //\n        // Ignore shutdown requests if the object adapter factory has\n        // already been shut down.\n        //\n        if(this._instance === null)\n        {\n            return this._shutdownPromise;\n        }\n\n        this._instance = null;\n        this._communicator = null;\n        _Promise.all(this._adapters.map(adapter => adapter.deactivate())).then(() => this._shutdownPromise.resolve());\n        return this._shutdownPromise;\n    }\n\n    waitForShutdown()\n    {\n        return this._shutdownPromise.then(() => _Promise.all(this._adapters.map(adapter => adapter.waitForDeactivate())));\n    }\n\n    isShutdown()\n    {\n        return this._instance === null;\n    }\n\n    destroy()\n    {\n        return this.waitForShutdown().then(() => _Promise.all(this._adapters.map(adapter => adapter.destroy())));\n    }\n\n    createObjectAdapter(name, router, promise)\n    {\n        if(this._instance === null)\n        {\n            throw new Ice.ObjectAdapterDeactivatedException();\n        }\n\n        let adapter = null;\n        try\n        {\n            if(name.length === 0)\n            {\n                adapter = new ObjectAdapterI(this._instance, this._communicator, this, Ice.generateUUID(), null, true,\n                                             promise);\n            }\n            else\n            {\n                if(this._adapterNamesInUse.indexOf(name) !== -1)\n                {\n                    throw new Ice.AlreadyRegisteredException(\"object adapter\", name);\n                }\n                adapter = new ObjectAdapterI(this._instance, this._communicator, this, name, router, false, promise);\n                this._adapterNamesInUse.push(name);\n            }\n            this._adapters.push(adapter);\n        }\n        catch(ex)\n        {\n            promise.reject(ex);\n        }\n    }\n\n    removeObjectAdapter(adapter)\n    {\n        if(this._instance === null)\n        {\n            return;\n        }\n\n        let n = this._adapters.indexOf(adapter);\n        if(n !== -1)\n        {\n            this._adapters.splice(n, 1);\n        }\n\n        n = this._adapterNamesInUse.indexOf(adapter.getName());\n        if(n !== -1)\n        {\n            this._adapterNamesInUse.splice(n, 1);\n        }\n    }\n}\n\nIce.ObjectAdapterFactory = ObjectAdapterFactory;\nmodule.exports.Ice = Ice;\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/ObjectAdapterFactory.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/ObjectAdapterI.js":
/*!****************************************************!*\
  !*** ./node_modules/ice/src/Ice/ObjectAdapterI.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nconst Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/AsyncResultBase */ \"./node_modules/ice/src/Ice/AsyncResultBase.js\");\n__webpack_require__(/*! ../Ice/Debug */ \"./node_modules/ice/src/Ice/Debug.js\");\n__webpack_require__(/*! ../Ice/Identity */ \"./node_modules/ice/src/Ice/Identity.js\");\n__webpack_require__(/*! ../Ice/LocalException */ \"./node_modules/ice/src/Ice/LocalException.js\");\n__webpack_require__(/*! ../Ice/Promise */ \"./node_modules/ice/src/Ice/Promise.js\");\n__webpack_require__(/*! ../Ice/PropertyNames */ \"./node_modules/ice/src/Ice/PropertyNames.js\");\n__webpack_require__(/*! ../Ice/Router */ \"./node_modules/ice/src/Ice/Router.js\");\n__webpack_require__(/*! ../Ice/ServantManager */ \"./node_modules/ice/src/Ice/ServantManager.js\");\n__webpack_require__(/*! ../Ice/StringUtil */ \"./node_modules/ice/src/Ice/StringUtil.js\");\n__webpack_require__(/*! ../Ice/Timer */ \"./node_modules/ice/src/Ice/Timer.js\");\n__webpack_require__(/*! ../Ice/UUID */ \"./node_modules/ice/src/Ice/UUID.js\");\n\nconst ArrayUtil = Ice.ArrayUtil;\nconst AsyncResultBase = Ice.AsyncResultBase;\nconst Debug = Ice.Debug;\nconst Identity = Ice.Identity;\nconst PropertyNames = Ice.PropertyNames;\nconst ServantManager = Ice.ServantManager;\nconst StringUtil = Ice.StringUtil;\nconst Timer = Ice.Timer;\n\nconst _suffixes =\n[\n    \"ACM\",\n    \"AdapterId\",\n    \"Endpoints\",\n    \"Locator\",\n    \"Locator.EncodingVersion\",\n    \"Locator.EndpointSelection\",\n    \"Locator.ConnectionCached\",\n    \"Locator.PreferSecure\",\n    \"Locator.CollocationOptimized\",\n    \"Locator.Router\",\n    \"MessageSizeMax\",\n    \"PublishedEndpoints\",\n    \"ReplicaGroupId\",\n    \"Router\",\n    \"Router.EncodingVersion\",\n    \"Router.EndpointSelection\",\n    \"Router.ConnectionCached\",\n    \"Router.PreferSecure\",\n    \"Router.CollocationOptimized\",\n    \"Router.Locator\",\n    \"Router.Locator.EndpointSelection\",\n    \"Router.Locator.ConnectionCached\",\n    \"Router.Locator.PreferSecure\",\n    \"Router.Locator.CollocationOptimized\",\n    \"Router.Locator.LocatorCacheTimeout\",\n    \"Router.Locator.InvocationTimeout\",\n    \"Router.LocatorCacheTimeout\",\n    \"Router.InvocationTimeout\",\n    \"ProxyOptions\",\n    \"ThreadPool.Size\",\n    \"ThreadPool.SizeMax\",\n    \"ThreadPool.SizeWarn\",\n    \"ThreadPool.StackSize\",\n    \"ThreadPool.Serialize\"\n];\n\nconst StateUninitialized = 0; // Just constructed.\nconst StateHeld = 1;\n// const StateWaitActivate = 2;\nconst StateActive = 3;\n// const StateDeactivating = 4;\nconst StateDeactivated = 5;\nconst StateDestroyed = 6;\n\n//\n// Only for use by IceInternal.ObjectAdapterFactory\n//\nclass ObjectAdapterI\n{\n    constructor(instance, communicator, objectAdapterFactory, name, router, noConfig, promise)\n    {\n        this._instance = instance;\n        this._communicator = communicator;\n        this._objectAdapterFactory = objectAdapterFactory;\n        this._servantManager = new ServantManager(instance, name);\n        this._name = name;\n        this._publishedEndpoints = [];\n        this._routerInfo = null;\n        this._state = StateUninitialized;\n        this._noConfig = noConfig;\n        this._statePromises = [];\n\n        if(this._noConfig)\n        {\n            this._reference = this._instance.referenceFactory().createFromString(\"dummy -t\", \"\");\n            this._messageSizeMax = this._instance.messageSizeMax();\n            promise.resolve(this);\n            return;\n        }\n\n        const properties = this._instance.initializationData().properties;\n        const unknownProps = [];\n        const noProps = this.filterProperties(unknownProps);\n\n        //\n        // Warn about unknown object adapter properties.\n        //\n        if(unknownProps.length !== 0 && properties.getPropertyAsIntWithDefault(\"Ice.Warn.UnknownProperties\", 1) > 0)\n        {\n            const message = [\"found unknown properties for object adapter `\" + name + \"':\"];\n            unknownProps.forEach(unknownProp => message.push(\"\\n    \" + unknownProp));\n            this._instance.initializationData().logger.warning(message.join(\"\"));\n        }\n\n        //\n        // Make sure named adapter has some configuration.\n        //\n        if(router === null && noProps)\n        {\n            throw new Ice.InitializationException(`object adapter \\`${this._name}' requires configuration`);\n        }\n\n        //\n        // Setup a reference to be used to get the default proxy options\n        // when creating new proxies. By default, create twoway proxies.\n        //\n        const proxyOptions = properties.getPropertyWithDefault(this._name + \".ProxyOptions\", \"-t\");\n        try\n        {\n            this._reference = this._instance.referenceFactory().createFromString(\"dummy \" + proxyOptions, \"\");\n        }\n        catch(e)\n        {\n            if(e instanceof Ice.ProxyParseException)\n            {\n                throw new Ice.InitializationException(\n                    `invalid proxy options \\`${proxyOptions}' for object adapter \\`${name}'`);\n            }\n            else\n            {\n                throw e;\n            }\n        }\n\n        {\n            const defaultMessageSizeMax = this._instance.messageSizeMax() / 1024;\n            const num = properties.getPropertyAsIntWithDefault(this._name + \".MessageSizeMax\", defaultMessageSizeMax);\n            if(num < 1 || num > 0x7fffffff / 1024)\n            {\n                this._messageSizeMax = 0x7fffffff;\n            }\n            else\n            {\n                this._messageSizeMax = num * 1024; // Property is in kilobytes, _messageSizeMax in bytes\n            }\n        }\n\n        try\n        {\n            if(router === null)\n            {\n                router = Ice.RouterPrx.uncheckedCast(\n                    this._instance.proxyFactory().propertyToProxy(this._name + \".Router\"));\n            }\n            let p;\n            if(router !== null)\n            {\n                this._routerInfo = this._instance.routerManager().find(router);\n                Debug.assert(this._routerInfo !== null);\n\n                //\n                // Make sure this router is not already registered with another adapter.\n                //\n                if(this._routerInfo.getAdapter() !== null)\n                {\n                    throw new Ice.AlreadyRegisteredException(\n                        \"object adapter with router\",\n                        Ice.identityToString(router.ice_getIdentity(), this._instance.toStringMode()));\n                }\n\n                //\n                // Associate this object adapter with the router. This way,\n                // new outgoing connections to the router's client proxy will\n                // use this object adapter for callbacks.\n                //\n                this._routerInfo.setAdapter(this);\n\n                //\n                // Also modify all existing outgoing connections to the\n                // router's client proxy to use this object adapter for\n                // callbacks.\n                //\n                p = this._instance.outgoingConnectionFactory().setRouterInfo(this._routerInfo);\n            }\n            else\n            {\n                const endpoints = properties.getProperty(this._name + \".Endpoints\");\n                if(endpoints.length > 0)\n                {\n                    throw new Ice.FeatureNotSupportedException(\"object adapter endpoints not supported\");\n                }\n                p = Ice.Promise.resolve();\n            }\n\n            p.then(() => this.computePublishedEndpoints()).then(endpoints =>\n            {\n                this._publishedEndpoints = endpoints;\n                promise.resolve(this);\n            },\n            ex =>\n            {\n                this.destroy();\n                promise.reject(ex);\n            });\n        }\n        catch(ex)\n        {\n            this.destroy();\n            throw ex;\n        }\n    }\n\n    getName()\n    {\n        //\n        // No mutex lock necessary, _name is immutable.\n        //\n        return this._noConfig ? \"\" : this._name;\n    }\n\n    getCommunicator()\n    {\n        return this._communicator;\n    }\n\n    activate()\n    {\n        const promise = new AsyncResultBase(this._communicator, \"activate\", null, null, this);\n        this.setState(StateActive);\n        promise.resolve();\n        return promise;\n    }\n\n    hold()\n    {\n        this.checkForDeactivation();\n        this.setState(StateHeld);\n    }\n\n    waitForHold()\n    {\n        const promise = new AsyncResultBase(this._communicator, \"waitForHold\", null, null, this);\n        try\n        {\n            this.checkForDeactivation();\n            this.waitState(StateHeld, promise);\n        }\n        catch(ex)\n        {\n            promise.reject(ex);\n        }\n        return promise;\n    }\n\n    deactivate()\n    {\n        const promise = new AsyncResultBase(this._communicator, \"deactivate\", null, null, this);\n        if(this._state < StateDeactivated)\n        {\n            this.setState(StateDeactivated);\n            this._instance.outgoingConnectionFactory().removeAdapter(this);\n        }\n        promise.resolve();\n        return promise;\n    }\n\n    waitForDeactivate()\n    {\n        const promise = new AsyncResultBase(this._communicator, \"waitForDeactivate\", null, null, this);\n        this.waitState(StateDeactivated, promise);\n        return promise;\n    }\n\n    isDeactivated()\n    {\n        return this._state >= StateDeactivated;\n    }\n\n    destroy()\n    {\n        // NOTE: we don't call waitForDeactivate since it's currently a no-op.\n        return this.deactivate().then(() =>\n        {\n            if(this._state < StateDestroyed)\n            {\n                this.setState(StateDestroyed);\n                this._servantManager.destroy();\n                this._objectAdapterFactory.removeObjectAdapter(this);\n                this._publishedEndpoints = [];\n            }\n            const promise = new AsyncResultBase(this._communicator, \"destroy\", null, null, this);\n            promise.resolve();\n            return promise;\n        });\n    }\n\n    add(object, ident)\n    {\n        return this.addFacet(object, ident, \"\");\n    }\n\n    addFacet(object, ident, facet)\n    {\n        this.checkForDeactivation();\n        this.checkIdentity(ident);\n        this.checkServant(object);\n\n        //\n        // Create a copy of the Identity argument, in case the caller\n        // reuses it.\n        //\n        const id = ident.clone();\n\n        this._servantManager.addServant(object, id, facet);\n\n        return this.newProxy(id, facet);\n    }\n\n    addWithUUID(object)\n    {\n        return this.addFacetWithUUID(object, \"\");\n    }\n\n    addFacetWithUUID(object, facet)\n    {\n        return this.addFacet(object, new Identity(Ice.generateUUID(), \"\"), facet);\n    }\n\n    addDefaultServant(servant, category)\n    {\n        this.checkServant(servant);\n        this.checkForDeactivation();\n\n        this._servantManager.addDefaultServant(servant, category);\n    }\n\n    remove(ident)\n    {\n        return this.removeFacet(ident, \"\");\n    }\n\n    removeFacet(ident, facet)\n    {\n        this.checkForDeactivation();\n        this.checkIdentity(ident);\n\n        return this._servantManager.removeServant(ident, facet);\n    }\n\n    removeAllFacets(ident)\n    {\n        this.checkForDeactivation();\n        this.checkIdentity(ident);\n\n        return this._servantManager.removeAllFacets(ident);\n    }\n\n    removeDefaultServant(category)\n    {\n        this.checkForDeactivation();\n\n        return this._servantManager.removeDefaultServant(category);\n    }\n\n    find(ident)\n    {\n        return this.findFacet(ident, \"\");\n    }\n\n    findFacet(ident, facet)\n    {\n        this.checkForDeactivation();\n        this.checkIdentity(ident);\n        return this._servantManager.findServant(ident, facet);\n    }\n\n    findAllFacets(ident)\n    {\n        this.checkForDeactivation();\n        this.checkIdentity(ident);\n        return this._servantManager.findAllFacets(ident);\n    }\n\n    findByProxy(proxy)\n    {\n        this.checkForDeactivation();\n        const ref = proxy._getReference();\n        return this.findFacet(ref.getIdentity(), ref.getFacet());\n    }\n\n    findDefaultServant(category)\n    {\n        this.checkForDeactivation();\n        return this._servantManager.findDefaultServant(category);\n    }\n\n    addServantLocator(locator, prefix)\n    {\n        this.checkForDeactivation();\n        this._servantManager.addServantLocator(locator, prefix);\n    }\n\n    removeServantLocator(prefix)\n    {\n        this.checkForDeactivation();\n        return this._servantManager.removeServantLocator(prefix);\n    }\n\n    findServantLocator(prefix)\n    {\n        this.checkForDeactivation();\n        return this._servantManager.findServantLocator(prefix);\n    }\n\n    createProxy(ident)\n    {\n        this.checkForDeactivation();\n        this.checkIdentity(ident);\n        return this.newProxy(ident, \"\");\n    }\n\n    createDirectProxy(ident)\n    {\n        return this.createProxy(ident);\n    }\n\n    createIndirectProxy(ident)\n    {\n        throw new Ice.FeatureNotSupportedException(\"createIndirectProxy not supported\");\n    }\n\n    setLocator(locator)\n    {\n        throw new Ice.FeatureNotSupportedException(\"setLocator not supported\");\n    }\n\n    getEndpoints()\n    {\n        return [];\n    }\n\n    refreshPublishedEndpoints()\n    {\n        this.checkForDeactivation();\n        return this.computePublishedEndpoints().then(\n            endpoints =>\n                {\n                    this._publishedEndpoints = endpoints;\n                });\n    }\n\n    getPublishedEndpoints()\n    {\n        return ArrayUtil.clone(this._publishedEndpoints);\n    }\n\n    setPublishedEndpoints(newEndpoints)\n    {\n        this.checkForDeactivation();\n        if(this._routerInfo !== null)\n        {\n            throw new Error(\"can't set published endpoints on object adapter associated with a router\");\n        }\n        this._publishedEndpoints = ArrayUtil.clone(newEndpoints);\n    }\n\n    getServantManager()\n    {\n        //\n        // _servantManager is immutable.\n        //\n        return this._servantManager;\n    }\n\n    setAdapterOnConnection(connection)\n    {\n        this.checkForDeactivation();\n        connection.setAdapterAndServantManager(this, this._servantManager);\n    }\n\n    messageSizeMax()\n    {\n        return this._messageSizeMax;\n    }\n\n    newProxy(ident, facet)\n    {\n        //\n        // Now we also add the endpoints of the router's server proxy, if\n        // any. This way, object references created by this object adapter\n        // will also point to the router's server proxy endpoints.\n        //\n        //\n        // Create a reference and return a proxy for this reference.\n        //\n        return this._instance.proxyFactory().referenceToProxy(\n            this._instance.referenceFactory().create(ident, facet, this._reference, this._publishedEndpoints));\n    }\n\n    checkForDeactivation()\n    {\n        if(this._state >= StateDeactivated)\n        {\n            const ex = new Ice.ObjectAdapterDeactivatedException();\n            ex.name = this.getName();\n            throw ex;\n        }\n    }\n\n    checkIdentity(ident)\n    {\n        if(ident.name === undefined || ident.name === null || ident.name.length === 0)\n        {\n            throw new Ice.IllegalIdentityException(ident);\n        }\n\n        if(ident.category === undefined || ident.category === null)\n        {\n            ident.category = \"\";\n        }\n    }\n\n    checkServant(servant)\n    {\n        if(servant === undefined || servant === null)\n        {\n            throw new Ice.IllegalServantException(\"cannot add null servant to Object Adapter\");\n        }\n    }\n\n    computePublishedEndpoints()\n    {\n        let p;\n        if(this._routerInfo !== null)\n        {\n            p = this._routerInfo.getServerEndpoints().then(\n                endpts =>\n                    {\n                        //\n                        // Remove duplicate endpoints, so we have a list of unique endpoints.\n                        //\n                        const endpoints = [];\n                        endpts.forEach(endpoint =>\n                                       {\n                                           if(endpoints.findIndex(value => endpoint.equals(value)) === -1)\n                                           {\n                                               endpoints.push(endpoint);\n                                           }\n                                       });\n                        return endpoints;\n                    });\n        }\n        else\n        {\n\n            //\n            // Parse published endpoints. If set, these are used in proxies\n            // instead of the connection factory Endpoints.\n            //\n            const endpoints = [];\n            const s = this._instance.initializationData().properties.getProperty(this._name + \".PublishedEndpoints\");\n            const delim = \" \\t\\n\\r\";\n\n            let end = 0;\n            let beg;\n            while(end < s.length)\n            {\n                beg = StringUtil.findFirstNotOf(s, delim, end);\n                if(beg === -1)\n                {\n                    if(s != \"\")\n                    {\n                        throw new Ice.EndpointParseException(\"invalid empty object adapter endpoint\");\n                    }\n                    break;\n                }\n\n                end = beg;\n                while(true)\n                {\n                    end = s.indexOf(':', end);\n                    if(end == -1)\n                    {\n                        end = s.length;\n                        break;\n                    }\n                    else\n                    {\n                        let quoted = false;\n                        let quote = beg;\n                        while(true)\n                        {\n                            quote = s.indexOf(\"\\\"\", quote);\n                            if(quote == -1 || end < quote)\n                            {\n                                break;\n                            }\n                            else\n                            {\n                                quote = s.indexOf(\"\\\"\", ++quote);\n                                if(quote == -1)\n                                {\n                                    break;\n                                }\n                                else if(end < quote)\n                                {\n                                    quoted = true;\n                                    break;\n                                }\n                                ++quote;\n                            }\n                        }\n                        if(!quoted)\n                        {\n                            break;\n                        }\n                        ++end;\n                    }\n                }\n\n                const es = s.substring(beg, end);\n                const endp = this._instance.endpointFactoryManager().create(es, false);\n                if(endp === null)\n                {\n                    throw new Ice.EndpointParseException(\"invalid object adapter endpoint `\" + s + \"'\");\n                }\n                endpoints.push(endp);\n            }\n\n            p = Ice.Promise.resolve(endpoints);\n        }\n\n        return p.then(\n            endpoints =>\n                {\n                    if(this._instance.traceLevels().network >= 1 && endpoints.length > 0)\n                    {\n                        const s = [];\n                        s.push(\"published endpoints for object adapter `\");\n                        s.push(this._name);\n                        s.push(\"':\\n\");\n                        let first = true;\n                        endpoints.forEach(endpoint =>\n                                          {\n                                              if(!first)\n                                              {\n                                                  s.push(\":\");\n                                              }\n                                              s.push(endpoint.toString());\n                                              first = false;\n                                          });\n                        this._instance.initializationData().logger.trace(this._instance.traceLevels().networkCat,\n                                                                         s.toString());\n                    }\n                    return endpoints;\n                });\n    }\n\n    filterProperties(unknownProps)\n    {\n        //\n        // Do not create unknown properties list if Ice prefix, i.e., Ice, Glacier2, etc.\n        //\n        let addUnknown = true;\n        const prefix = this._name + \".\";\n        for(let i = 0; i < PropertyNames.clPropNames.length; ++i)\n        {\n            if(prefix.indexOf(PropertyNames.clPropNames[i] + \".\") === 0)\n            {\n                addUnknown = false;\n                break;\n            }\n        }\n\n        let noProps = true;\n        const props = this._instance.initializationData().properties.getPropertiesForPrefix(prefix);\n        for(const key of props.keys())\n        {\n            let valid = false;\n            for(let i = 0; i < _suffixes.length; ++i)\n            {\n                if(key === prefix + _suffixes[i])\n                {\n                    noProps = false;\n                    valid = true;\n                    break;\n                }\n            }\n\n            if(!valid && addUnknown)\n            {\n                unknownProps.push(key);\n            }\n        }\n\n        return noProps;\n    }\n\n    setState(state)\n    {\n        if(this._state === state)\n        {\n            return;\n        }\n        this._state = state;\n\n        let promises = [];\n        (state < StateDeactivated ? [state] : [StateHeld, StateDeactivated]).forEach(s =>\n        {\n            if(this._statePromises[s])\n            {\n                promises = promises.concat(this._statePromises[s]);\n                delete this._statePromises[s];\n            }\n        });\n        if(promises.length > 0)\n        {\n            Timer.setImmediate(() => promises.forEach(p => p.resolve()));\n        }\n    }\n\n    waitState(state, promise)\n    {\n        if(this._state < StateDeactivated &&\n           (state === StateHeld && this._state !== StateHeld || state === StateDeactivated))\n        {\n            if(this._statePromises[state])\n            {\n                this._statePromises[state].push(promise);\n            }\n            else\n            {\n                this._statePromises[state] = [promise];\n            }\n        }\n        else\n        {\n            promise.resolve();\n        }\n    }\n}\n\nIce.ObjectAdapterI = ObjectAdapterI;\nmodule.exports.Ice = Ice;\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/ObjectAdapterI.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/ObjectFactory.js":
/*!***************************************************!*\
  !*** ./node_modules/ice/src/Ice/ObjectFactory.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n//\n// Ice version 3.7.10\n//\n// <auto-generated>\n//\n// Generated from file `ObjectFactory.ice'\n//\n// Warning: do not edit this file.\n//\n// </auto-generated>\n//\n\n/* eslint-disable */\n/* jshint ignore: start */\n\n/* slice2js browser-bundle-skip */\nconst _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\n__webpack_require__(/*! ../Ice/Object */ \"./node_modules/ice/src/Ice/Object.js\");\n__webpack_require__(/*! ../Ice/Value */ \"./node_modules/ice/src/Ice/Value.js\");\n__webpack_require__(/*! ../Ice/ObjectPrx */ \"./node_modules/ice/src/Ice/ObjectPrx.js\");\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\nconst Ice = _ModuleRegistry.module(\"Ice\");\n\nconst Slice = Ice.Slice;\n/* slice2js browser-bundle-skip-end */\n/* slice2js browser-bundle-skip */\nexports.Ice = Ice;\n/* slice2js browser-bundle-skip-end */\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/ObjectFactory.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/ObjectPrx.js":
/*!***********************************************!*\
  !*** ./node_modules/ice/src/Ice/ObjectPrx.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nconst Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/AsyncResult */ \"./node_modules/ice/src/Ice/AsyncResult.js\");\n__webpack_require__(/*! ../Ice/BuiltinSequences */ \"./node_modules/ice/src/Ice/BuiltinSequences.js\");\n__webpack_require__(/*! ../Ice/Current */ \"./node_modules/ice/src/Ice/Current.js\");\n__webpack_require__(/*! ../Ice/Debug */ \"./node_modules/ice/src/Ice/Debug.js\");\n__webpack_require__(/*! ../Ice/Exception */ \"./node_modules/ice/src/Ice/Exception.js\");\n__webpack_require__(/*! ../Ice/FormatType */ \"./node_modules/ice/src/Ice/FormatType.js\");\n__webpack_require__(/*! ../Ice/LocalException */ \"./node_modules/ice/src/Ice/LocalException.js\");\n__webpack_require__(/*! ../Ice/Object */ \"./node_modules/ice/src/Ice/Object.js\");\n__webpack_require__(/*! ../Ice/OutgoingAsync */ \"./node_modules/ice/src/Ice/OutgoingAsync.js\");\n__webpack_require__(/*! ../Ice/ReferenceMode */ \"./node_modules/ice/src/Ice/ReferenceMode.js\");\n\nconst ArrayUtil = Ice.ArrayUtil;\nconst AsyncResultBase = Ice.AsyncResultBase;\nconst Debug = Ice.Debug;\nconst OutgoingAsync = Ice.OutgoingAsync;\nconst ProxyFlushBatch = Ice.ProxyFlushBatch;\nconst ProxyGetConnection = Ice.ProxyGetConnection;\nconst RefMode = Ice.ReferenceMode;\nconst OperationMode = Ice.OperationMode;\n\n//\n// Ice.ObjectPrx\n//\nclass ObjectPrx\n{\n    constructor()\n    {\n        this._reference = null;\n        this._requestHandler = null;\n    }\n\n    hashCode(r)\n    {\n        return this._reference.hashCode();\n    }\n\n    ice_getCommunicator()\n    {\n        return this._reference.getCommunicator();\n    }\n\n    toString()\n    {\n        return this._reference.toString();\n    }\n\n    ice_getIdentity()\n    {\n        return this._reference.getIdentity().clone();\n    }\n\n    ice_identity(newIdentity)\n    {\n        if(newIdentity === undefined || newIdentity === null || newIdentity.name.length === 0)\n        {\n            throw new Ice.IllegalIdentityException();\n        }\n        if(newIdentity.equals(this._reference.getIdentity()))\n        {\n            return this;\n        }\n        else\n        {\n            const proxy = new ObjectPrx();\n            proxy._setup(this._reference.changeIdentity(newIdentity));\n            return proxy;\n        }\n    }\n\n    ice_getContext()\n    {\n        return new Map(this._reference.getContext());\n    }\n\n    ice_context(newContext)\n    {\n        return this._newInstance(this._reference.changeContext(newContext));\n    }\n\n    ice_getFacet()\n    {\n        return this._reference.getFacet();\n    }\n\n    ice_facet(newFacet)\n    {\n        if(newFacet === undefined || newFacet === null)\n        {\n            newFacet = \"\";\n        }\n\n        if(newFacet === this._reference.getFacet())\n        {\n            return this;\n        }\n        else\n        {\n            const proxy = new ObjectPrx();\n            proxy._setup(this._reference.changeFacet(newFacet));\n            return proxy;\n        }\n    }\n\n    ice_getAdapterId()\n    {\n        return this._reference.getAdapterId();\n    }\n\n    ice_adapterId(newAdapterId)\n    {\n        if(newAdapterId === undefined || newAdapterId === null)\n        {\n            newAdapterId = \"\";\n        }\n\n        if(newAdapterId === this._reference.getAdapterId())\n        {\n            return this;\n        }\n        else\n        {\n            return this._newInstance(this._reference.changeAdapterId(newAdapterId));\n        }\n    }\n\n    ice_getEndpoints()\n    {\n        return ArrayUtil.clone(this._reference.getEndpoints());\n    }\n\n    ice_endpoints(newEndpoints)\n    {\n        if(newEndpoints === undefined || newEndpoints === null)\n        {\n            newEndpoints = [];\n        }\n\n        if(ArrayUtil.equals(newEndpoints, this._reference.getEndpoints()))\n        {\n            return this;\n        }\n        else\n        {\n            return this._newInstance(this._reference.changeEndpoints(newEndpoints));\n        }\n    }\n\n    ice_getLocatorCacheTimeout()\n    {\n        return this._reference.getLocatorCacheTimeout();\n    }\n\n    ice_locatorCacheTimeout(newTimeout)\n    {\n        if(newTimeout < -1)\n        {\n            throw new RangeError(\"invalid value passed to ice_locatorCacheTimeout: \" + newTimeout);\n        }\n        if(newTimeout === this._reference.getLocatorCacheTimeout())\n        {\n            return this;\n        }\n        else\n        {\n            return this._newInstance(this._reference.changeLocatorCacheTimeout(newTimeout));\n        }\n    }\n\n    ice_getInvocationTimeout()\n    {\n        return this._reference.getInvocationTimeout();\n    }\n\n    ice_invocationTimeout(newTimeout)\n    {\n        if(newTimeout < 1 && newTimeout !== -1)\n        {\n            throw new RangeError(\"invalid value passed to ice_invocationTimeout: \" + newTimeout);\n        }\n        if(newTimeout === this._reference.getInvocationTimeout())\n        {\n            return this;\n        }\n        else\n        {\n            return this._newInstance(this._reference.changeInvocationTimeout(newTimeout));\n        }\n    }\n\n    ice_isConnectionCached()\n    {\n        return this._reference.getCacheConnection();\n    }\n\n    ice_connectionCached(newCache)\n    {\n        if(newCache === this._reference.getCacheConnection())\n        {\n            return this;\n        }\n        else\n        {\n            return this._newInstance(this._reference.changeCacheConnection(newCache));\n        }\n    }\n\n    ice_getEndpointSelection()\n    {\n        return this._reference.getEndpointSelection();\n    }\n\n    ice_endpointSelection(newType)\n    {\n        if(newType === this._reference.getEndpointSelection())\n        {\n            return this;\n        }\n        else\n        {\n            return this._newInstance(this._reference.changeEndpointSelection(newType));\n        }\n    }\n\n    ice_isSecure()\n    {\n        return this._reference.getSecure();\n    }\n\n    ice_secure(b)\n    {\n        if(b === this._reference.getSecure())\n        {\n            return this;\n        }\n        else\n        {\n            return this._newInstance(this._reference.changeSecure(b));\n        }\n    }\n\n    ice_getEncodingVersion()\n    {\n        return this._reference.getEncoding().clone();\n    }\n\n    ice_encodingVersion(e)\n    {\n        if(e.equals(this._reference.getEncoding()))\n        {\n            return this;\n        }\n        else\n        {\n            return this._newInstance(this._reference.changeEncoding(e));\n        }\n    }\n\n    ice_isPreferSecure()\n    {\n        return this._reference.getPreferSecure();\n    }\n\n    ice_preferSecure(b)\n    {\n        if(b === this._reference.getPreferSecure())\n        {\n            return this;\n        }\n        else\n        {\n            return this._newInstance(this._reference.changePreferSecure(b));\n        }\n    }\n\n    ice_getRouter()\n    {\n        const ri = this._reference.getRouterInfo();\n        return ri !== null ? ri.getRouter() : null;\n    }\n\n    ice_router(router)\n    {\n        const ref = this._reference.changeRouter(router);\n        if(ref.equals(this._reference))\n        {\n            return this;\n        }\n        else\n        {\n            return this._newInstance(ref);\n        }\n    }\n\n    ice_getLocator()\n    {\n        const ri = this._reference.getLocatorInfo();\n        return ri !== null ? ri.getLocator() : null;\n    }\n\n    ice_locator(locator)\n    {\n        const ref = this._reference.changeLocator(locator);\n        if(ref.equals(this._reference))\n        {\n            return this;\n        }\n        else\n        {\n            return this._newInstance(ref);\n        }\n    }\n\n    ice_isTwoway()\n    {\n        return this._reference.getMode() === RefMode.ModeTwoway;\n    }\n\n    ice_twoway()\n    {\n        if(this._reference.getMode() === RefMode.ModeTwoway)\n        {\n            return this;\n        }\n        else\n        {\n            return this._newInstance(this._reference.changeMode(RefMode.ModeTwoway));\n        }\n    }\n\n    ice_isOneway()\n    {\n        return this._reference.getMode() === RefMode.ModeOneway;\n    }\n\n    ice_oneway()\n    {\n        if(this._reference.getMode() === RefMode.ModeOneway)\n        {\n            return this;\n        }\n        else\n        {\n            return this._newInstance(this._reference.changeMode(RefMode.ModeOneway));\n        }\n    }\n\n    ice_isBatchOneway()\n    {\n        return this._reference.getMode() === RefMode.ModeBatchOneway;\n    }\n\n    ice_batchOneway()\n    {\n        if(this._reference.getMode() === RefMode.ModeBatchOneway)\n        {\n            return this;\n        }\n        else\n        {\n            return this._newInstance(this._reference.changeMode(RefMode.ModeBatchOneway));\n        }\n    }\n\n    ice_isDatagram()\n    {\n        return this._reference.getMode() === RefMode.ModeDatagram;\n    }\n\n    ice_datagram()\n    {\n        if(this._reference.getMode() === RefMode.ModeDatagram)\n        {\n            return this;\n        }\n        else\n        {\n            return this._newInstance(this._reference.changeMode(RefMode.ModeDatagram));\n        }\n    }\n\n    ice_isBatchDatagram()\n    {\n        return this._reference.getMode() === RefMode.ModeBatchDatagram;\n    }\n\n    ice_batchDatagram()\n    {\n        if(this._reference.getMode() === RefMode.ModeBatchDatagram)\n        {\n            return this;\n        }\n        else\n        {\n            return this._newInstance(this._reference.changeMode(RefMode.ModeBatchDatagram));\n        }\n    }\n\n    ice_timeout(t)\n    {\n        if(t < 1 && t !== -1)\n        {\n            throw new RangeError(\"invalid value passed to ice_timeout: \" + t);\n        }\n        const ref = this._reference.changeTimeout(t);\n        if(ref.equals(this._reference))\n        {\n            return this;\n        }\n        else\n        {\n            return this._newInstance(ref);\n        }\n    }\n\n    ice_getTimeout()\n    {\n        return this._reference.getTimeout();\n    }\n\n    ice_fixed(connection)\n    {\n        if(connection === null)\n        {\n            throw new RangeError(\"invalid null connection passed to ice_fixed\");\n        }\n        if(!(connection instanceof Ice.ConnectionI))\n        {\n            throw new RangeError(\"invalid connection passed to ice_fixed\");\n        }\n        const ref = this._reference.changeConnection(connection);\n        if(ref.equals(this._reference))\n        {\n            return this;\n        }\n        else\n        {\n            return this._newInstance(ref);\n        }\n    }\n\n    ice_isFixed()\n    {\n        return this._reference instanceof Ice.FixedReference;\n    }\n\n    ice_getConnectionId()\n    {\n        return this._reference.getConnectionId();\n    }\n\n    ice_connectionId(id)\n    {\n        const ref = this._reference.changeConnectionId(id);\n        if(ref.equals(this._reference))\n        {\n            return this;\n        }\n        else\n        {\n            return this._newInstance(ref);\n        }\n    }\n\n    ice_getConnection()\n    {\n        const r = new ProxyGetConnection(this, \"ice_getConnection\");\n        try\n        {\n            r.invoke();\n        }\n        catch(ex)\n        {\n            r.abort(ex);\n        }\n        return r;\n    }\n\n    ice_getCachedConnection()\n    {\n        return this._requestHandler ? this._requestHandler.getConnection() : null;\n    }\n\n    ice_flushBatchRequests()\n    {\n        const r = new ProxyFlushBatch(this, \"ice_flushBatchRequests\");\n        try\n        {\n            r.invoke();\n        }\n        catch(ex)\n        {\n            r.abort(ex);\n        }\n        return r;\n    }\n\n    equals(r)\n    {\n        if(this === r)\n        {\n            return true;\n        }\n\n        if(r instanceof ObjectPrx)\n        {\n            return this._reference.equals(r._reference);\n        }\n\n        return false;\n    }\n\n    _write(os)\n    {\n        this._reference.getIdentity()._write(os);\n        this._reference.streamWrite(os);\n    }\n\n    _getReference()\n    {\n        return this._reference;\n    }\n\n    _copyFrom(from)\n    {\n        Debug.assert(this._reference === null);\n        Debug.assert(this._requestHandler === null);\n\n        this._reference = from._reference;\n        this._requestHandler = from._requestHandler;\n    }\n\n    _handleException(ex, handler, mode, sent, sleep, cnt)\n    {\n        this._updateRequestHandler(handler, null); // Clear the request handler\n\n        //\n        // We only retry local exception, system exceptions aren't retried.\n        //\n        // A CloseConnectionException indicates graceful server shutdown, and is therefore\n        // always repeatable without violating \"at-most-once\". That's because by sending a\n        // close connection message, the server guarantees that all outstanding requests\n        // can safely be repeated.\n        //\n        // An ObjectNotExistException can always be retried as well without violating\n        // \"at-most-once\" (see the implementation of the checkRetryAfterException method\n        //  of the ProxyFactory class for the reasons why it can be useful).\n        //\n        // If the request didn't get sent or if it's non-mutating or idempotent it can\n        // also always be retried if the retry count isn't reached.\n        //\n        if(ex instanceof Ice.LocalException &&\n           (!sent ||\n            mode == OperationMode.Nonmutating || mode == OperationMode.Idempotent ||\n            ex instanceof Ice.CloseConnectionException || ex instanceof Ice.ObjectNotExistException))\n        {\n            try\n            {\n                return this._reference.getInstance().proxyFactory().checkRetryAfterException(ex,\n                                                                                             this._reference,\n                                                                                             sleep,\n                                                                                             cnt);\n            }\n            catch(exc)\n            {\n                if(exc instanceof Ice.CommunicatorDestroyedException)\n                {\n                    //\n                    // The communicator is already destroyed, so we cannot retry.\n                    //\n                    throw ex;\n                }\n                else\n                {\n                    throw exc;\n                }\n            }\n        }\n        else\n        {\n            throw ex;\n        }\n    }\n\n    _checkAsyncTwowayOnly(name)\n    {\n        if(!this.ice_isTwoway())\n        {\n            throw new Ice.TwowayOnlyException(name);\n        }\n    }\n\n    _getRequestHandler()\n    {\n        if(this._reference.getCacheConnection())\n        {\n            if(this._requestHandler)\n            {\n                return this._requestHandler;\n            }\n        }\n        return this._reference.getRequestHandler(this);\n    }\n\n    _getBatchRequestQueue()\n    {\n        if(!this._batchRequestQueue)\n        {\n            this._batchRequestQueue = this._reference.getBatchRequestQueue();\n        }\n        return this._batchRequestQueue;\n    }\n\n    _setRequestHandler(handler)\n    {\n        if(this._reference.getCacheConnection())\n        {\n            if(!this._requestHandler)\n            {\n                this._requestHandler = handler;\n            }\n            return this._requestHandler;\n        }\n        return handler;\n    }\n\n    _updateRequestHandler(previous, handler)\n    {\n        if(this._reference.getCacheConnection() && previous !== null)\n        {\n            if(this._requestHandler && this._requestHandler !== handler)\n            {\n                this._requestHandler = this._requestHandler.update(previous, handler);\n            }\n        }\n    }\n\n    //\n    // Only for use by IceInternal.ProxyFactory\n    //\n    _setup(ref)\n    {\n        Debug.assert(this._reference === null);\n\n        this._reference = ref;\n    }\n\n    _newInstance(ref)\n    {\n        const proxy = new this.constructor();\n        proxy._setup(ref);\n        return proxy;\n    }\n\n    ice_instanceof(T)\n    {\n        if(T)\n        {\n            if(this instanceof T)\n            {\n                return true;\n            }\n            return this.constructor._instanceof(T);\n        }\n        return false;\n    }\n\n    //\n    // Generic invocation for operations that have input parameters.\n    //\n    static _invoke(p, name, mode, fmt, ctx, marshalFn, unmarshalFn, userEx, args)\n    {\n        if(unmarshalFn !== null || userEx.length > 0)\n        {\n            p._checkAsyncTwowayOnly(name);\n        }\n\n        const r = new OutgoingAsync(p, name,\n            res =>\n            {\n                this._completed(res, unmarshalFn, userEx);\n            });\n\n        try\n        {\n            r.prepare(name, mode, ctx);\n            if(marshalFn === null)\n            {\n                r.writeEmptyParams();\n            }\n            else\n            {\n                const ostr = r.startWriteParams(fmt);\n                marshalFn(ostr, args);\n                r.endWriteParams();\n            }\n            r.invoke();\n        }\n        catch(ex)\n        {\n            r.abort(ex);\n        }\n        return r;\n    }\n\n    //\n    // Handles the completion of an invocation.\n    //\n    static _completed(r, unmarshalFn, userEx)\n    {\n        if(!this._check(r, userEx))\n        {\n            return;\n        }\n\n        try\n        {\n            if(unmarshalFn === null)\n            {\n                r.readEmptyParams();\n                r.resolve();\n            }\n            else\n            {\n                r.resolve(unmarshalFn(r));\n            }\n        }\n        catch(ex)\n        {\n            this.dispatchLocalException(r, ex);\n        }\n    }\n\n    //\n    // Handles user exceptions.\n    //\n    static _check(r, uex)\n    {\n        //\n        // If uex is non-null, it must be an array of exception types.\n        //\n        try\n        {\n            r.throwUserException();\n        }\n        catch(ex)\n        {\n            if(ex instanceof Ice.UserException)\n            {\n                if(uex !== null)\n                {\n                    for(let i = 0; i < uex.length; ++i)\n                    {\n                        if(ex instanceof uex[i])\n                        {\n                            r.reject(ex);\n                            return false;\n                        }\n                    }\n                }\n                r.reject(new Ice.UnknownUserException(ex.ice_id()));\n                return false;\n            }\n            else\n            {\n                r.reject(ex);\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    static dispatchLocalException(r, ex)\n    {\n        r.reject(ex);\n    }\n\n    static checkedCast(prx, facet, ctx)\n    {\n        let r = null;\n\n        if(prx === undefined || prx === null)\n        {\n            r = new AsyncResultBase(null, \"checkedCast\", null, null, null);\n            r.resolve(null);\n        }\n        else\n        {\n            if(facet !== undefined)\n            {\n                prx = prx.ice_facet(facet);\n            }\n\n            r = new AsyncResultBase(prx.ice_getCommunicator(), \"checkedCast\", null, prx, null);\n            prx.ice_isA(this.ice_staticId(), ctx).then(\n                ret =>\n                {\n                    if(ret)\n                    {\n                        const h = new this();\n                        h._copyFrom(prx);\n                        r.resolve(h);\n                    }\n                    else\n                    {\n                        r.resolve(null);\n                    }\n                }).catch(\n                    ex =>\n                    {\n                        if(ex instanceof Ice.FacetNotExistException)\n                        {\n                            r.resolve(null);\n                        }\n                        else\n                        {\n                            r.reject(ex);\n                        }\n                    });\n        }\n\n        return r;\n    }\n\n    static uncheckedCast(prx, facet)\n    {\n        let r = null;\n        if(prx !== undefined && prx !== null)\n        {\n            r = new this();\n            if(facet !== undefined)\n            {\n                prx = prx.ice_facet(facet);\n            }\n            r._copyFrom(prx);\n        }\n        return r;\n    }\n\n    static get minWireSize()\n    {\n        return 2;\n    }\n\n    static write(os, v)\n    {\n        os.writeProxy(v);\n    }\n\n    static read(is)\n    {\n        return is.readProxy(this);\n    }\n\n    static writeOptional(os, tag, v)\n    {\n        os.writeOptionalProxy(tag, v);\n    }\n\n    static readOptional(is, tag)\n    {\n        return is.readOptionalProxy(tag, this);\n    }\n\n    static _instanceof(T)\n    {\n        if(T === this)\n        {\n            return true;\n        }\n\n        for(const i in this._implements)\n        {\n            if(this._implements[i]._instanceof(T))\n            {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    static ice_staticId()\n    {\n        return this._id;\n    }\n\n    static get _implements()\n    {\n        return [];\n    }\n}\n\nIce.ObjectPrx = ObjectPrx;\nmodule.exports.Ice = Ice;\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/ObjectPrx.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/OpaqueEndpointI.js":
/*!*****************************************************!*\
  !*** ./node_modules/ice/src/Ice/OpaqueEndpointI.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nconst Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n\n__webpack_require__(/*! ../Ice/Base64 */ \"./node_modules/ice/src/Ice/Base64.js\");\n__webpack_require__(/*! ../Ice/Debug */ \"./node_modules/ice/src/Ice/Debug.js\");\n__webpack_require__(/*! ../Ice/EndpointI */ \"./node_modules/ice/src/Ice/EndpointI.js\");\n__webpack_require__(/*! ../Ice/FormatType */ \"./node_modules/ice/src/Ice/FormatType.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/LocalException */ \"./node_modules/ice/src/Ice/LocalException.js\");\n__webpack_require__(/*! ../Ice/StringUtil */ \"./node_modules/ice/src/Ice/StringUtil.js\");\n\nconst Base64 = Ice.Base64;\nconst Debug = Ice.Debug;\nconst EndpointParseException = Ice.EndpointParseException;\nconst HashUtil = Ice.HashUtil;\nconst StringUtil = Ice.StringUtil;\n\nclass OpaqueEndpointI extends Ice.EndpointI\n{\n    constructor(type)\n    {\n        super();\n        this._rawEncoding = Ice.Encoding_1_0;\n        this._type = type === undefined ? -1 : type;\n        this._rawBytes = null;\n    }\n\n    //\n    // Marshal the endpoint\n    //\n    streamWrite(s)\n    {\n        s.startEncapsulation(this._rawEncoding, Ice.FormatType.DefaultFormat);\n        s.writeBlob(this._rawBytes);\n        s.endEncapsulation();\n    }\n\n    //\n    // Return the endpoint information.\n    //\n    getInfo()\n    {\n        return new OpaqueEndpointInfoI(null, -1, false, this._rawEncoding, this._rawBytes, this._type);\n    }\n\n    //\n    // Return the endpoint type\n    //\n    type()\n    {\n        return this._type;\n    }\n\n    protocol()\n    {\n        return \"opaque\";\n    }\n\n    //\n    // Return the timeout for the endpoint in milliseconds. 0 means\n    // non-blocking, -1 means no timeout.\n    //\n    timeout()\n    {\n        return -1;\n    }\n\n    //\n    // Return a new endpoint with a different timeout value, provided\n    // that timeouts are supported by the endpoint. Otherwise the same\n    // endpoint is returned.\n    //\n    changeTimeout(t)\n    {\n        return this;\n    }\n\n    //\n    // Return a new endpoint with a different connection id.\n    //\n    changeConnectionId(connectionId)\n    {\n        return this;\n    }\n\n    //\n    // Return true if the endpoints support bzip2 compress, or false\n    // otherwise.\n    //\n    compress()\n    {\n        return false;\n    }\n\n    //\n    // Return a new endpoint with a different compression value,\n    // provided that compression is supported by the\n    // endpoint. Otherwise the same endpoint is returned.\n    //\n    changeCompress(compress)\n    {\n        return this;\n    }\n\n    //\n    // Return true if the endpoint is datagram-based.\n    //\n    datagram()\n    {\n        return false;\n    }\n\n    //\n    // Return true if the endpoint is secure.\n    //\n    secure()\n    {\n        return false;\n    }\n\n    //\n    // Get the encoded endpoint.\n    //\n    rawBytes()\n    {\n        return this._rawBytes; // Returns a Uint8Array\n    }\n\n    //\n    // Return a server side transceiver for this endpoint, or null if a\n    // transceiver can only be created by an acceptor. In case a\n    // transceiver is created, this operation also returns a new\n    // \"effective\" endpoint, which might differ from this endpoint,\n    // for example, if a dynamic port number is assigned.\n    //\n    transceiver(endpoint)\n    {\n        endpoint.value = null;\n        return null;\n    }\n\n    //\n    // Return an acceptor for this endpoint, or null if no acceptors\n    // is available. In case an acceptor is created, this operation\n    // also returns a new \"effective\" endpoint, which might differ\n    // from this endpoint, for example, if a dynamic port number is\n    // assigned.\n    //\n    acceptor(endpoint, adapterName)\n    {\n        endpoint.value = this;\n        return null;\n    }\n\n    connect()\n    {\n        return null;\n    }\n\n    hashCode()\n    {\n        if(this._hashCode === undefined)\n        {\n            let h = 5381;\n            h = HashUtil.addNumber(h, this._type);\n            h = HashUtil.addHashable(h, this._rawEncoding);\n            h = HashUtil.addArray(h, this._rawBytes, HashUtil.addNumber);\n            this._hashCode = h;\n        }\n        return this._hashCode;\n    }\n\n    options()\n    {\n        let s = \"\";\n        s += \" -t \" + this._type;\n        s += \" -e \" + Ice.encodingVersionToString(this._rawEncoding);\n        s += \" -v \" + Base64.encode(this._rawBytes);\n        return s;\n    }\n\n    //\n    // Compare endpoints for sorting purposes\n    //\n    equals(p)\n    {\n        if(!(p instanceof OpaqueEndpointI))\n        {\n            return false;\n        }\n\n        if(this === p)\n        {\n            return true;\n        }\n\n        if(this._type !== p._type)\n        {\n            return false;\n        }\n\n        if(!this._rawEncoding.equals(p._rawEncoding))\n        {\n            return false;\n        }\n\n        if(this._rawBytes.length !== p._rawBytes.length)\n        {\n            return false;\n        }\n        for(let i = 0; i < this._rawBytes.length; i++)\n        {\n            if(this._rawBytes[i] !== p._rawBytes[i])\n            {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    compareTo(p)\n    {\n        if(this === p)\n        {\n            return 0;\n        }\n\n        if(p === null)\n        {\n            return 1;\n        }\n\n        if(!(p instanceof OpaqueEndpointI))\n        {\n            return this.type() < p.type() ? -1 : 1;\n        }\n\n        if(this._type < p._type)\n        {\n            return -1;\n        }\n        else if(p._type < this._type)\n        {\n            return 1;\n        }\n\n        if(this._rawEncoding.major < p._rawEncoding.major)\n        {\n            return -1;\n        }\n        else if(p._rawEncoding.major < this._rawEncoding.major)\n        {\n            return 1;\n        }\n\n        if(this._rawEncoding.minor < p._rawEncoding.minor)\n        {\n            return -1;\n        }\n        else if(p._rawEncoding.minor < this._rawEncoding.minor)\n        {\n            return 1;\n        }\n\n        if(this._rawBytes.length < p._rawBytes.length)\n        {\n            return -1;\n        }\n        else if(p._rawBytes.length < this._rawBytes.length)\n        {\n            return 1;\n        }\n        for(let i = 0; i < this._rawBytes.length; i++)\n        {\n            if(this._rawBytes[i] < p._rawBytes[i])\n            {\n                return -1;\n            }\n            else if(p._rawBytes[i] < this._rawBytes[i])\n            {\n                return 1;\n            }\n        }\n\n        return 0;\n    }\n\n    checkOption(option, argument, endpoint)\n    {\n        switch(option.charAt(1))\n        {\n            case 't':\n            {\n                if(this._type > -1)\n                {\n                    throw new EndpointParseException(\"multiple -t options in endpoint \" + endpoint);\n                }\n                if(argument === null)\n                {\n                    throw new EndpointParseException(\"no argument provided for -t option in endpoint \" + endpoint);\n                }\n\n                let type;\n\n                try\n                {\n                    type = StringUtil.toInt(argument);\n                }\n                catch(ex)\n                {\n                    throw new EndpointParseException(\"invalid type value `\" + argument + \"' in endpoint \" + endpoint);\n                }\n\n                if(type < 0 || type > 65535)\n                {\n                    throw new EndpointParseException(\"type value `\" + argument + \"' out of range in endpoint \" +\n                                                     endpoint);\n                }\n\n                this._type = type;\n                return true;\n            }\n\n            case 'v':\n            {\n                if(this._rawBytes)\n                {\n                    throw new EndpointParseException(\"multiple -v options in endpoint \" + endpoint);\n                }\n                if(argument === null || argument.length === 0)\n                {\n                    throw new EndpointParseException(\"no argument provided for -v option in endpoint \" + endpoint);\n                }\n                for(let i = 0; i < argument.length; ++i)\n                {\n                    if(!Base64.isBase64(argument.charAt(i)))\n                    {\n                        throw new EndpointParseException(\"invalid base64 character `\" + argument.charAt(i) +\n                                                         \"' (ordinal \" + argument.charCodeAt(i) +\n                                                         \") in endpoint \" + endpoint);\n                    }\n                }\n                this._rawBytes = Base64.decode(argument);\n                return true;\n            }\n\n            case 'e':\n            {\n                if(argument === null)\n                {\n                    throw new EndpointParseException(\"no argument provided for -e option in endpoint \" + endpoint);\n                }\n                try\n                {\n                    this._rawEncoding = Ice.stringToEncodingVersion(argument);\n                }\n                catch(e)\n                {\n                    throw new EndpointParseException(\"invalid encoding version `\" + argument +\n                                                     \"' in endpoint \" + endpoint + \":\\n\" + e.str);\n                }\n                return true;\n            }\n\n            default:\n            {\n                return false;\n            }\n        }\n    }\n\n    initWithOptions(args)\n    {\n        super.initWithOptions(args);\n        Debug.assert(this._rawEncoding);\n\n        if(this._type < 0)\n        {\n            throw new EndpointParseException(\"no -t option in endpoint `\" + this + \"'\");\n        }\n        if(this._rawBytes === null || this._rawBytes.length === 0)\n        {\n            throw new EndpointParseException(\"no -v option in endpoint `\" + this + \"'\");\n        }\n    }\n\n    initWithStream(s)\n    {\n        this._rawEncoding = s.getEncoding();\n        this._rawBytes = s.readBlob(s.getEncapsulationSize());\n    }\n}\n\nclass OpaqueEndpointInfoI extends Ice.OpaqueEndpointInfo\n{\n    constructor(timeout, compress, rawEncoding, rawBytes, type)\n    {\n        super(-1, false, rawEncoding, rawBytes);\n        this._type = type;\n    }\n\n    type()\n    {\n        return this._type;\n    }\n\n    datagram()\n    {\n        return false;\n    }\n\n    secure()\n    {\n        return false;\n    }\n}\n\nIce.OpaqueEndpointI = OpaqueEndpointI;\nmodule.exports.Ice = Ice;\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/OpaqueEndpointI.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/Operation.js":
/*!***********************************************!*\
  !*** ./node_modules/ice/src/Ice/Operation.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nconst Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\nconst _ModuleRegistry = Ice._ModuleRegistry;\n\n__webpack_require__(/*! ../Ice/Current */ \"./node_modules/ice/src/Ice/Current.js\");\n__webpack_require__(/*! ../Ice/Exception */ \"./node_modules/ice/src/Ice/Exception.js\");\n__webpack_require__(/*! ../Ice/FormatType */ \"./node_modules/ice/src/Ice/FormatType.js\");\n__webpack_require__(/*! ../Ice/Object */ \"./node_modules/ice/src/Ice/Object.js\");\n__webpack_require__(/*! ../Ice/ObjectPrx */ \"./node_modules/ice/src/Ice/ObjectPrx.js\");\n__webpack_require__(/*! ../Ice/OptionalFormat */ \"./node_modules/ice/src/Ice/OptionalFormat.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\n\nconst builtinHelpers =\n[\n    Ice.ByteHelper,\n    Ice.BoolHelper,\n    Ice.ShortHelper,\n    Ice.IntHelper,\n    Ice.LongHelper,\n    Ice.FloatHelper,\n    Ice.DoubleHelper,\n    Ice.StringHelper,\n    Ice.Value,\n    Ice.ObjectPrx,\n    Ice.Value\n];\n\nfunction parseParam(p)\n{\n    let type = p[0];\n    const t = typeof type;\n    if(t === 'number')\n    {\n        type = builtinHelpers[p[0]];\n    }\n    else if(t === 'string')\n    {\n        type = _ModuleRegistry.type(type);\n    }\n\n    return {\n        type: type,\n        isObject: (p[1] === true),\n        tag: p[2] // Optional tag, which may not be present - an undefined tag means \"not optional\".\n    };\n}\n\n//\n// Each operation descriptor is a property. The key is the \"on-the-wire\"\n// name, and the value is an array consisting of the following elements:\n//\n//  0: native method name in case of a keyword conflict (e.g., \"_while\"),\n//     otherwise an empty string\n//  1: mode (undefined == Normal or int)\n//  2: sendMode (undefined == Normal or int)\n//  3: format (undefined == Default or int)\n//  4: return type (undefined if void, or [type, tag])\n//  5: in params (undefined if none, or array of [type, tag])\n//  6: out params (undefined if none, or array of [type, tag])\n//  7: exceptions (undefined if none, or array of types)\n//  8: sends classes (true or undefined)\n//  9: returns classes (true or undefined)\n//\nfunction parseOperation(name, arr)\n{\n    const r = {};\n\n    r.name = name;\n    r.servantMethod = arr[0] ? arr[0] : name;\n    r.mode = arr[1] ? Ice.OperationMode.valueOf(arr[1]) : Ice.OperationMode.Normal;\n    r.sendMode = arr[2] ? Ice.OperationMode.valueOf(arr[2]) : Ice.OperationMode.Normal;\n    r.format = arr[3] ? Ice.FormatType.valueOf(arr[3]) : Ice.FormatType.DefaultFormat;\n\n    let ret;\n    if(arr[4])\n    {\n        ret = parseParam(arr[4]);\n        ret.pos = 0;\n    }\n    r.returns = ret;\n\n    const inParams = [];\n    const inParamsOpt = [];\n    if(arr[5])\n    {\n        for(let i = 0; i < arr[5].length; ++i)\n        {\n            const p = parseParam(arr[5][i]);\n            p.pos = i;\n            inParams.push(p);\n            if(p.tag)\n            {\n                inParamsOpt.push(p);\n            }\n        }\n    }\n    inParamsOpt.sort((p1, p2) => p1.tag - p2.tag); // Sort by tag.\n    r.inParams = inParams;\n    r.inParamsOpt = inParamsOpt;\n\n    const outParams = [];\n    const outParamsOpt = [];\n    if(arr[6])\n    {\n        const offs = ret ? 1 : 0;\n        for(let i = 0; i < arr[6].length; ++i)\n        {\n            const p = parseParam(arr[6][i]);\n            p.pos = i + offs;\n            outParams.push(p);\n            if(p.tag)\n            {\n                outParamsOpt.push(p);\n            }\n        }\n    }\n    if(ret && ret.tag)\n    {\n        outParamsOpt.push(ret);\n    }\n    outParamsOpt.sort((p1, p2) => p1.tag - p2.tag); // Sort by tag.\n    r.outParams = outParams;\n    r.outParamsOpt = outParamsOpt;\n\n    const exceptions = [];\n    if(arr[7])\n    {\n        for(let i = 0; i < arr[7].length; ++i)\n        {\n            exceptions.push(arr[7][i]);\n        }\n    }\n    r.exceptions = exceptions;\n\n    r.sendsClasses = arr[8] === true;\n    r.returnsClasses = arr[9] === true;\n\n    return r;\n}\n\nclass OpTable\n{\n    constructor(ops)\n    {\n        this.raw = ops;\n        this.parsed = {};\n    }\n\n    find(name)\n    {\n        //\n        // Check if we've already parsed the operation.\n        //\n        let op = this.parsed[name];\n        if(op === undefined && this.raw[name] !== undefined)\n        {\n            //\n            // We haven't parsed it yet, but we found a match for the name, so parse it now.\n            //\n            op = parseOperation(name, this.raw[name]);\n            this.parsed[name] = op;\n        }\n        return op;\n    }\n}\n\nfunction unmarshalParams(is, retvalInfo, allParamInfo, optParamInfo, usesClasses, params, offset)\n{\n    const readParam = (p, optional) =>\n    {\n        if(optional)\n        {\n            if(p.isObject)\n            {\n                is.readOptionalValue(p.tag,\n                                     obj =>\n                                     {\n                                         params[p.pos + offset] = obj;\n                                     },\n                                     p.type);\n            }\n            else\n            {\n                params[p.pos + offset] = p.type.readOptional(is, p.tag);\n            }\n        }\n        else if(p.isObject)\n        {\n            is.readValue(obj =>\n                         {\n                             params[p.pos + offset] = obj;\n                         },\n                         p.type);\n        }\n        else\n        {\n            params[p.pos + offset] = p.type.read(is);\n        }\n    };\n\n    //\n    // First read all required params.\n    //\n    for(let i = 0; i < allParamInfo.length; ++i)\n    {\n        if(!allParamInfo[i].tag)\n        {\n            readParam(allParamInfo[i], false);\n        }\n    }\n\n    //\n    // Then read a required return value (if any).\n    //\n    if(retvalInfo)\n    {\n        readParam(retvalInfo, false);\n    }\n\n    //\n    // Then read all optional params.\n    //\n    for(let i = 0; i < optParamInfo.length; ++i)\n    {\n        readParam(optParamInfo[i], true);\n    }\n\n    if(usesClasses)\n    {\n        is.readPendingValues();\n    }\n}\n\nfunction marshalParams(os, params, retvalInfo, paramInfo, optParamInfo, usesClasses)\n{\n    //\n    // Write the required params.\n    //\n    for(let i = 0; i < paramInfo.length; ++i)\n    {\n        const p = paramInfo[i];\n        if(!p.tag)\n        {\n            p.type.write(os, params[p.pos]);\n        }\n    }\n\n    //\n    // retvalInfo should only be provided if there is a non-void required return value.\n    //\n    if(retvalInfo)\n    {\n        retvalInfo.type.write(os, params[retvalInfo.pos]);\n    }\n\n    //\n    // Write the optional params.\n    //\n    for(let i = 0; i < optParamInfo.length; ++i)\n    {\n        const p = optParamInfo[i];\n        p.type.writeOptional(os, p.tag, params[p.pos]);\n    }\n\n    if(usesClasses)\n    {\n        os.writePendingValues();\n    }\n}\n\nfunction dispatchImpl(servant, op, incomingAsync, current)\n{\n    //\n    // Check to make sure the servant implements the operation.\n    //\n    const method = servant[op.servantMethod];\n    if(method === undefined || typeof method !== \"function\")\n    {\n        throw new Ice.UnknownException(\"servant for identity \" + current.adapter.getCommunicator().identityToString(current.id) +\n                                       \" does not define operation `\" + op.servantMethod + \"'\");\n    }\n\n    //\n    // Unmarshal the in params (if any).\n    //\n    const params = [];\n    if(op.inParams.length === 0)\n    {\n        incomingAsync.readEmptyParams();\n    }\n    else\n    {\n        const is = incomingAsync.startReadParams();\n        unmarshalParams(is, undefined, op.inParams, op.inParamsOpt, op.sendsClasses, params, 0);\n        incomingAsync.endReadParams();\n    }\n\n    params.push(current);\n\n    incomingAsync.setFormat(op.format);\n\n    const marshalFn = function(params)\n    {\n        const numExpectedResults = op.outParams.length + (op.returns ? 1 : 0);\n        if(numExpectedResults > 1 && !(params instanceof Array))\n        {\n            throw new Ice.MarshalException(\"operation `\" + op.servantMethod + \"' should return an array\");\n        }\n        else if(numExpectedResults === 1)\n        {\n            params = [params]; // Wrap a single out parameter in an array.\n        }\n\n        if(op.returns === undefined && op.outParams.length === 0)\n        {\n            if(params && params.length > 0)\n            {\n                throw new Ice.MarshalException(\"operation `\" + op.servantMethod + \"' shouldn't return any value\");\n            }\n            else\n            {\n                incomingAsync.writeEmptyParams();\n            }\n        }\n        else\n        {\n            let retvalInfo;\n            if(op.returns && !op.returns.tag)\n            {\n                retvalInfo = op.returns;\n            }\n\n            const os = incomingAsync.startWriteParams();\n            marshalParams(os, params, retvalInfo, op.outParams, op.outParamsOpt, op.returnsClasses);\n            incomingAsync.endWriteParams();\n        }\n    };\n\n    const results = method.apply(servant, params);\n    if(results instanceof Promise)\n    {\n        return results.then(marshalFn);\n    }\n    else\n    {\n        marshalFn(results);\n        return null;\n    }\n}\n\nfunction getServantMethodFromInterfaces(interfaces, methodName, all)\n{\n    let method;\n    for(let i = 0; method === undefined && i < interfaces.length; ++i)\n    {\n        const intf = interfaces[i];\n        method = intf[methodName];\n        if(method === undefined)\n        {\n            if(all.indexOf(intf) === -1)\n            {\n                all.push(intf);\n            }\n            if(intf._iceImplements)\n            {\n                method = getServantMethodFromInterfaces(intf._iceImplements, methodName, all);\n            }\n        }\n    }\n    return method;\n}\n\nconst dispatchPrefix = \"_iceD_\";\n\nfunction getServantMethod(servantType, name)\n{\n    //\n    // The dispatch method is named _iceD_<Slice name> and is stored in the type (not the prototype).\n    //\n    const methodName = dispatchPrefix + name;\n\n    //\n    // First check the servant type.\n    //\n    let method = servantType[methodName];\n\n    let allInterfaces;\n\n    if(method === undefined)\n    {\n        allInterfaces = [];\n\n        //\n        // Now check the prototypes of the implemented interfaces.\n        //\n        let curr = servantType;\n        while(curr && method === undefined)\n        {\n            if(curr._iceImplements)\n            {\n                method = getServantMethodFromInterfaces(curr._iceImplements, methodName, allInterfaces);\n            }\n            curr = Object.getPrototypeOf(curr);\n        }\n\n        if(method !== undefined)\n        {\n            //\n            // Add the method to the servant's type.\n            //\n            servantType[methodName] = method;\n        }\n    }\n\n    if(method === undefined)\n    {\n        //\n        // Next check the op table for the servant's type.\n        //\n        let op;\n        if(servantType._iceOps)\n        {\n            op = servantType._iceOps.find(name);\n        }\n\n        let source;\n        if(op === undefined)\n        {\n            //\n            // Now check the op tables of the base types.\n            //\n            let parent = Object.getPrototypeOf(servantType);\n            while(op === undefined && parent)\n            {\n                if(parent._iceOps)\n                {\n                    if((op = parent._iceOps.find(name)) !== undefined)\n                    {\n                        source = parent;\n                    }\n                }\n                parent = Object.getPrototypeOf(parent);\n            }\n\n            //\n            // Now check the op tables of all base interfaces.\n            //\n            for(let i = 0; op === undefined && i < allInterfaces.length; ++i)\n            {\n                const intf = allInterfaces[i];\n                if(intf._iceOps)\n                {\n                    if((op = intf._iceOps.find(name)) !== undefined)\n                    {\n                        source = intf;\n                    }\n                }\n            }\n        }\n\n        if(op !== undefined)\n        {\n            method = function(servant, incomingAsync, current)\n            {\n                return dispatchImpl(servant, op, incomingAsync, current);\n            };\n\n            //\n            // Add the method to the servant type.\n            //\n            servantType[methodName] = method;\n\n            //\n            // Also add the method to the type in which the operation was found.\n            //\n            if(source)\n            {\n                source[methodName] = method;\n            }\n        }\n    }\n\n    return method;\n}\n\nfunction addProxyOperation(proxyType, name, data)\n{\n    const method = data[0] ? data[0] : name;\n\n    let op = null;\n\n    proxyType.prototype[method] = function(...args)\n    {\n        //\n        // Parse the operation data on the first invocation of a proxy method.\n        //\n        if(op === null)\n        {\n            op = parseOperation(name, data);\n        }\n\n        const ctx = args[op.inParams.length]; // The request context is the last argument (if present).\n\n        let marshalFn = null;\n        if(op.inParams.length > 0)\n        {\n            marshalFn = function(os, params)\n            {\n                //\n                // Validate the parameters.\n                //\n                for(let i = 0; i < op.inParams.length; ++i)\n                {\n                    const p = op.inParams[i];\n                    const v = params[p.pos];\n                    if(!p.tag || v !== undefined)\n                    {\n                        if(typeof p.type.validate === \"function\")\n                        {\n                            if(!p.type.validate(v))\n                            {\n                                throw new Ice.MarshalException(\"invalid value for argument \" + (i + 1) +\n                                                               \" in operation `\" + op.servantMethod + \"'\");\n                            }\n                        }\n                    }\n                }\n\n                marshalParams(os, params, undefined, op.inParams, op.inParamsOpt, op.sendsClasses);\n            };\n        }\n\n        let unmarshalFn = null;\n        if(op.returns || op.outParams.length > 0)\n        {\n            unmarshalFn = function(asyncResult)\n            {\n                //\n                // The results array holds the out parameters in the following format:\n                //\n                // [retval, out1, out2, ..., asyncResult]\n                //\n                const results = [];\n\n                const is = asyncResult.startReadParams();\n                let retvalInfo;\n                if(op.returns && !op.returns.tag)\n                {\n                    retvalInfo = op.returns;\n                }\n                unmarshalParams(is, retvalInfo, op.outParams, op.outParamsOpt, op.returnsClasses, results, 0);\n                asyncResult.endReadParams();\n                return results.length == 1 ? results[0] : results;\n            };\n        }\n        return Ice.ObjectPrx._invoke(this, op.name, op.sendMode, op.format, ctx, marshalFn, unmarshalFn,\n                                     op.exceptions, Array.prototype.slice.call(args));\n    };\n}\n\nconst Slice = Ice.Slice;\nSlice.defineOperations = function(classType, proxyType, ids, pos, ops)\n{\n    if(ops)\n    {\n        classType._iceOps = new OpTable(ops);\n    }\n\n    classType.prototype._iceDispatch = function(incomingAsync, current)\n    {\n        //\n        // Retrieve the dispatch method for this operation.\n        //\n        const method = getServantMethod(classType, current.operation);\n\n        if(method === undefined || typeof method !== 'function')\n        {\n            throw new Ice.OperationNotExistException(current.id, current.facet, current.operation);\n        }\n\n        return method.call(method, this, incomingAsync, current);\n    };\n\n    classType.prototype._iceMostDerivedType = function()\n    {\n        return classType;\n    };\n\n    Object.defineProperty(classType, \"_iceIds\", {\n        get: () => ids\n    });\n\n    Object.defineProperty(classType, \"_iceId\", {\n        get: () => ids[pos]\n    });\n\n    classType.ice_staticId = function()\n    {\n        return classType._iceId;\n    };\n\n    if(proxyType !== undefined)\n    {\n        if(ops)\n        {\n            for(const name in ops)\n            {\n                addProxyOperation(proxyType, name, ops[name]);\n            }\n        }\n\n        //\n        // Copy proxy methods from super-interfaces.\n        //\n        if(proxyType._implements)\n        {\n            for(const intf in proxyType._implements)\n            {\n                const proto = proxyType._implements[intf].prototype;\n                for(const f in proto)\n                {\n                    if(typeof proto[f] == \"function\" && proxyType.prototype[f] === undefined)\n                    {\n                        proxyType.prototype[f] = proto[f];\n                    }\n                }\n            }\n        }\n\n        Object.defineProperty(proxyType, \"_id\", {\n            get: () => ids[pos]\n        });\n    }\n};\n\n//\n// Define the \"built-in\" operations for all Ice objects.\n//\nSlice.defineOperations(Ice.Object, Ice.ObjectPrx, [\"::Ice::Object\"], 0,\n{\n    ice_ping: [undefined, 1, 1, undefined, undefined, undefined, undefined, undefined],\n    ice_isA: [undefined, 1, 1, undefined, [1], [[7]], undefined, undefined],\n    ice_id: [undefined, 1, 1, undefined, [7], undefined, undefined, undefined],\n    ice_ids: [undefined, 1, 1, undefined, [\"Ice.StringSeqHelper\"], undefined, undefined, undefined]\n});\n\nmodule.exports.Ice = Ice;\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/Operation.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/OptionalFormat.js":
/*!****************************************************!*\
  !*** ./node_modules/ice/src/Ice/OptionalFormat.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nconst Ice = (__webpack_require__(/*! ../Ice/EnumBase */ \"./node_modules/ice/src/Ice/EnumBase.js\").Ice);\nIce.OptionalFormat = Ice.Slice.defineEnum([['F1', 0], ['F2', 1], ['F4', 2], ['F8', 3], ['Size', 4], ['VSize', 5], ['FSize', 6], ['Class', 7]]);\nmodule.exports.Ice = Ice;\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/OptionalFormat.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/OutgoingAsync.js":
/*!***************************************************!*\
  !*** ./node_modules/ice/src/Ice/OutgoingAsync.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nconst Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n\n__webpack_require__(/*! ../Ice/AsyncResult */ \"./node_modules/ice/src/Ice/AsyncResult.js\");\n__webpack_require__(/*! ../Ice/AsyncStatus */ \"./node_modules/ice/src/Ice/AsyncStatus.js\");\n__webpack_require__(/*! ../Ice/BuiltinSequences */ \"./node_modules/ice/src/Ice/BuiltinSequences.js\");\n__webpack_require__(/*! ../Ice/Current */ \"./node_modules/ice/src/Ice/Current.js\");\n__webpack_require__(/*! ../Ice/Debug */ \"./node_modules/ice/src/Ice/Debug.js\");\n__webpack_require__(/*! ../Ice/Exception */ \"./node_modules/ice/src/Ice/Exception.js\");\n__webpack_require__(/*! ../Ice/Identity */ \"./node_modules/ice/src/Ice/Identity.js\");\n__webpack_require__(/*! ../Ice/LocalException */ \"./node_modules/ice/src/Ice/LocalException.js\");\n__webpack_require__(/*! ../Ice/Protocol */ \"./node_modules/ice/src/Ice/Protocol.js\");\n__webpack_require__(/*! ../Ice/RetryException */ \"./node_modules/ice/src/Ice/RetryException.js\");\n__webpack_require__(/*! ../Ice/Stream */ \"./node_modules/ice/src/Ice/Stream.js\");\n\nconst AsyncResult = Ice.AsyncResult;\nconst AsyncStatus = Ice.AsyncStatus;\nconst Debug = Ice.Debug;\nconst Identity = Ice.Identity;\nconst InputStream = Ice.InputStream;\nconst OutputStream = Ice.OutputStream;\nconst Protocol = Ice.Protocol;\nconst RetryException = Ice.RetryException;\n\nclass OutgoingAsyncBase extends AsyncResult\n{\n    constructor(communicator, operation, connection, proxy, adapter)\n    {\n        super(communicator, operation, connection, proxy, adapter);\n        this._os = new OutputStream(this._instance, Protocol.currentProtocolEncoding);\n    }\n\n    getOs()\n    {\n        return this._os;\n    }\n\n    sent()\n    {\n        this.markSent(true);\n    }\n\n    completedEx(ex)\n    {\n        this.markFinishedEx(ex);\n    }\n}\n\nclass ProxyOutgoingAsyncBase extends OutgoingAsyncBase\n{\n    constructor(prx, operation)\n    {\n        if (prx)\n        {\n            super(prx.ice_getCommunicator(), operation, null, prx, null);\n        }\n        else\n        {\n            super();\n        }\n        this._mode = null;\n        this._cnt = 0;\n        this._sent = false;\n        this._handler = null;\n    }\n\n    completedEx(ex)\n    {\n        try\n        {\n            this._instance.retryQueue().add(this, this.handleException(ex));\n        }\n        catch(ex)\n        {\n            this.markFinishedEx(ex);\n        }\n    }\n\n    retryException(ex)\n    {\n        try\n        {\n            this._proxy._updateRequestHandler(this._handler, null); // Clear request handler and always retry.\n            this._instance.retryQueue().add(this, 0);\n        }\n        catch(ex)\n        {\n            this.completedEx(ex);\n        }\n    }\n\n    retry()\n    {\n        this.invokeImpl(false);\n    }\n\n    abort(ex)\n    {\n        this.markFinishedEx(ex);\n    }\n\n    invokeImpl(userThread)\n    {\n        try\n        {\n            if(userThread)\n            {\n                const invocationTimeout = this._proxy._getReference().getInvocationTimeout();\n                if(invocationTimeout > 0)\n                {\n                    this._timeoutToken = this._instance.timer().schedule(\n                        () =>\n                        {\n                            this.cancelWithException(new Ice.InvocationTimeoutException());\n                        },\n                        invocationTimeout);\n                }\n            }\n\n            while(true)\n            {\n                try\n                {\n                    this._sent = false;\n                    this._handler = this._proxy._getRequestHandler();\n                    if((this._handler.sendAsyncRequest(this) & AsyncStatus.Sent) > 0)\n                    {\n                        if(userThread)\n                        {\n                            this._sentSynchronously = true;\n                        }\n                    }\n                    return; // We're done!\n                }\n                catch(ex)\n                {\n                    if(ex instanceof RetryException)\n                    {\n                        // Clear request handler and always retry\n                        this._proxy._updateRequestHandler(this._handler, null);\n                    }\n                    else\n                    {\n                        const interval = this.handleException(ex);\n                        if(interval > 0)\n                        {\n                            this._instance.retryQueue().add(this, interval);\n                            return;\n                        }\n                    }\n                }\n            }\n        }\n        catch(ex)\n        {\n            this.markFinishedEx(ex);\n        }\n    }\n\n    markSent(done)\n    {\n        this._sent = true;\n        if(done)\n        {\n            if(this._timeoutToken)\n            {\n                this._instance.timer().cancel(this._timeoutToken);\n            }\n        }\n        super.markSent.call(this, done);\n    }\n\n    markFinishedEx(ex)\n    {\n        if(this._timeoutToken)\n        {\n            this._instance.timer().cancel(this._timeoutToken);\n        }\n        super.markFinishedEx.call(this, ex);\n    }\n\n    handleException(ex)\n    {\n        const interval = {value: 0};\n        this._cnt = this._proxy._handleException(ex, this._handler, this._mode, this._sent, interval, this._cnt);\n        return interval.value;\n    }\n}\n\nclass OutgoingAsync extends ProxyOutgoingAsyncBase\n{\n    constructor(prx, operation, completed)\n    {\n        super(prx, operation);\n        if (prx)\n        {\n            this._encoding = Protocol.getCompatibleEncoding(this._proxy._getReference().getEncoding());\n            this._completed = completed;\n        }\n    }\n\n    prepare(op, mode, ctx)\n    {\n        Protocol.checkSupportedProtocol(Protocol.getCompatibleProtocol(this._proxy._getReference().getProtocol()));\n\n        this._mode = mode;\n        if(ctx === null)\n        {\n            ctx = OutgoingAsync._emptyContext;\n        }\n\n        if(this._proxy.ice_isBatchOneway() || this._proxy.ice_isBatchDatagram())\n        {\n            this._proxy._getBatchRequestQueue().prepareBatchRequest(this._os);\n        }\n        else\n        {\n            this._os.writeBlob(Protocol.requestHdr);\n        }\n\n        const ref = this._proxy._getReference();\n\n        ref.getIdentity()._write(this._os);\n\n        //\n        // For compatibility with the old FacetPath.\n        //\n        const facet = ref.getFacet();\n        if(facet === null || facet.length === 0)\n        {\n            Ice.StringSeqHelper.write(this._os, null);\n        }\n        else\n        {\n            Ice.StringSeqHelper.write(this._os, [facet]);\n        }\n\n        this._os.writeString(this._operation);\n\n        this._os.writeByte(mode.value);\n\n        if(ctx !== undefined)\n        {\n            if(ctx !== null && !(ctx instanceof Map))\n            {\n                throw new RangeError(\"illegal context value, expecting null or Map\");\n            }\n\n            //\n            // Explicit context\n            //\n            Ice.ContextHelper.write(this._os, ctx);\n        }\n        else\n        {\n            //\n            // Implicit context\n            //\n            const implicitContext = ref.getInstance().getImplicitContext();\n            const prxContext = ref.getContext();\n\n            if(implicitContext === null)\n            {\n                Ice.ContextHelper.write(this._os, prxContext);\n            }\n            else\n            {\n                implicitContext.write(prxContext, this._os);\n            }\n        }\n    }\n\n    sent()\n    {\n        this.markSent(!this._proxy.ice_isTwoway());\n    }\n\n    invokeRemote(connection, response)\n    {\n        return connection.sendAsyncRequest(this, response, 0);\n    }\n\n    abort(ex)\n    {\n        if(this._proxy.ice_isBatchOneway() || this._proxy.ice_isBatchDatagram())\n        {\n            this._proxy._getBatchRequestQueue().abortBatchRequest(this._os);\n        }\n        super.abort(ex);\n    }\n\n    invoke()\n    {\n        if(this._proxy.ice_isBatchOneway() || this._proxy.ice_isBatchDatagram())\n        {\n            this._sentSynchronously = true;\n            this._proxy._getBatchRequestQueue().finishBatchRequest(this._os, this._proxy, this._operation);\n            this.markFinished(true);\n            return;\n        }\n\n        //\n        // NOTE: invokeImpl doesn't throw so this can be called from the\n        // try block with the catch block calling abort() in case of an\n        // exception.\n        //\n        this.invokeImpl(true); // userThread = true\n    }\n\n    completed(istr)\n    {\n        Debug.assert(this._proxy.ice_isTwoway()); // Can only be called for twoways.\n\n        let replyStatus;\n        try\n        {\n            if(this._is === null) // _is can already be initialized if the invocation is retried\n            {\n                this._is = new InputStream(this._instance, Protocol.currentProtocolEncoding);\n            }\n            this._is.swap(istr);\n            replyStatus = this._is.readByte();\n\n            switch(replyStatus)\n            {\n                case Protocol.replyOK:\n                case Protocol.replyUserException:\n                {\n                    break;\n                }\n\n                case Protocol.replyObjectNotExist:\n                case Protocol.replyFacetNotExist:\n                case Protocol.replyOperationNotExist:\n                {\n                    const id = new Identity();\n                    id._read(this._is);\n\n                    //\n                    // For compatibility with the old FacetPath.\n                    //\n                    const facetPath = Ice.StringSeqHelper.read(this._is);\n                    let facet;\n                    if(facetPath.length > 0)\n                    {\n                        if(facetPath.length > 1)\n                        {\n                            throw new Ice.MarshalException();\n                        }\n                        facet = facetPath[0];\n                    }\n                    else\n                    {\n                        facet = \"\";\n                    }\n\n                    const operation = this._is.readString();\n\n                    let rfe = null;\n                    switch(replyStatus)\n                    {\n                    case Protocol.replyObjectNotExist:\n                    {\n                        rfe = new Ice.ObjectNotExistException();\n                        break;\n                    }\n\n                    case Protocol.replyFacetNotExist:\n                    {\n                        rfe = new Ice.FacetNotExistException();\n                        break;\n                    }\n\n                    case Protocol.replyOperationNotExist:\n                    {\n                        rfe = new Ice.OperationNotExistException();\n                        break;\n                    }\n\n                    default:\n                    {\n                        Debug.assert(false);\n                        break;\n                    }\n                    }\n\n                    rfe.id = id;\n                    rfe.facet = facet;\n                    rfe.operation = operation;\n                    throw rfe;\n                }\n\n                case Protocol.replyUnknownException:\n                case Protocol.replyUnknownLocalException:\n                case Protocol.replyUnknownUserException:\n                {\n                    const unknown = this._is.readString();\n\n                    let ue = null;\n                    switch(replyStatus)\n                    {\n                    case Protocol.replyUnknownException:\n                    {\n                        ue = new Ice.UnknownException();\n                        break;\n                    }\n\n                    case Protocol.replyUnknownLocalException:\n                    {\n                        ue = new Ice.UnknownLocalException();\n                        break;\n                    }\n\n                    case Protocol.replyUnknownUserException:\n                    {\n                        ue = new Ice.UnknownUserException();\n                        break;\n                    }\n\n                    default:\n                    {\n                        Debug.assert(false);\n                        break;\n                    }\n                    }\n\n                    ue.unknown = unknown;\n                    throw ue;\n                }\n\n                default:\n                {\n                    throw new Ice.UnknownReplyStatusException();\n                }\n            }\n\n            this.markFinished(replyStatus == Protocol.replyOK, this._completed);\n        }\n        catch(ex)\n        {\n            this.completedEx(ex);\n        }\n    }\n\n    startWriteParams(format)\n    {\n        this._os.startEncapsulation(this._encoding, format);\n        return this._os;\n    }\n\n    endWriteParams()\n    {\n        this._os.endEncapsulation();\n    }\n\n    writeEmptyParams()\n    {\n        this._os.writeEmptyEncapsulation(this._encoding);\n    }\n\n    startReadParams()\n    {\n        this._is.startEncapsulation();\n        return this._is;\n    }\n\n    endReadParams()\n    {\n        this._is.endEncapsulation();\n    }\n\n    readEmptyParams()\n    {\n        this._is.skipEmptyEncapsulation();\n    }\n\n    throwUserException()\n    {\n        Debug.assert((this._state & AsyncResult.Done) !== 0);\n        if((this._state & AsyncResult.OK) === 0)\n        {\n            try\n            {\n                this._is.startEncapsulation();\n                this._is.throwException();\n            }\n            catch(ex)\n            {\n                if(ex instanceof Ice.UserException)\n                {\n                    this._is.endEncapsulation();\n                }\n                throw ex;\n            }\n        }\n    }\n}\n\nOutgoingAsync._emptyContext = new Map(); // Map<string, string>\n\nclass ProxyFlushBatch extends ProxyOutgoingAsyncBase\n{\n    constructor(prx, operation)\n    {\n        super(prx, operation);\n        this._batchRequestNum = prx._getBatchRequestQueue().swap(this._os);\n    }\n\n    invokeRemote(connection, response)\n    {\n        if(this._batchRequestNum === 0)\n        {\n            this.sent();\n            return AsyncStatus.Sent;\n        }\n        return connection.sendAsyncRequest(this, response, this._batchRequestNum);\n    }\n\n    invoke()\n    {\n        Protocol.checkSupportedProtocol(Protocol.getCompatibleProtocol(this._proxy._getReference().getProtocol()));\n        this.invokeImpl(true); // userThread = true\n    }\n}\n\nclass ProxyGetConnection extends ProxyOutgoingAsyncBase\n{\n    invokeRemote(connection, response)\n    {\n        this.markFinished(true, r => r.resolve(connection));\n        return AsyncStatus.Sent;\n    }\n\n    invoke()\n    {\n        this.invokeImpl(true); // userThread = true\n    }\n}\n\nclass ConnectionFlushBatch extends OutgoingAsyncBase\n{\n    constructor(con, communicator, operation)\n    {\n        super(communicator, operation, con, null, null);\n    }\n\n    invoke()\n    {\n        try\n        {\n            const batchRequestNum = this._connection.getBatchRequestQueue().swap(this._os);\n            let status;\n            if(batchRequestNum === 0)\n            {\n                this.sent();\n                status = AsyncStatus.Sent;\n            }\n            else\n            {\n                status = this._connection.sendAsyncRequest(this, false, batchRequestNum);\n            }\n\n            if((status & AsyncStatus.Sent) > 0)\n            {\n                this._sentSynchronously = true;\n            }\n        }\n        catch(ex)\n        {\n            this.completedEx(ex);\n        }\n    }\n}\n\nclass HeartbeatAsync extends OutgoingAsyncBase\n{\n    constructor(con, communicator)\n    {\n        super(communicator, \"heartbeat\", con, null, null);\n    }\n\n    invoke()\n    {\n        try\n        {\n            this._os.writeBlob(Protocol.magic);\n            Protocol.currentProtocol._write(this._os);\n            Protocol.currentProtocolEncoding._write(this._os);\n            this._os.writeByte(Protocol.validateConnectionMsg);\n            this._os.writeByte(0);\n            this._os.writeInt(Protocol.headerSize); // Message size.\n\n            const status = this._connection.sendAsyncRequest(this, false, 0);\n            if((status & AsyncStatus.Sent) > 0)\n            {\n                this._sentSynchronously = true;\n            }\n        }\n        catch(ex)\n        {\n            this.completedEx(ex);\n        }\n    }\n}\n\nIce.OutgoingAsync = OutgoingAsync;\nIce.ProxyFlushBatch = ProxyFlushBatch;\nIce.ProxyGetConnection = ProxyGetConnection;\nIce.ConnectionFlushBatch = ConnectionFlushBatch;\nIce.HeartbeatAsync = HeartbeatAsync;\n\nmodule.exports.Ice = Ice;\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/OutgoingAsync.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/OutgoingConnectionFactory.js":
/*!***************************************************************!*\
  !*** ./node_modules/ice/src/Ice/OutgoingConnectionFactory.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nconst Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n\n__webpack_require__(/*! ../Ice/ACM */ \"./node_modules/ice/src/Ice/ACM.js\");\n__webpack_require__(/*! ../Ice/AsyncResultBase */ \"./node_modules/ice/src/Ice/AsyncResultBase.js\");\n__webpack_require__(/*! ../Ice/ConnectionI */ \"./node_modules/ice/src/Ice/ConnectionI.js\");\n__webpack_require__(/*! ../Ice/Debug */ \"./node_modules/ice/src/Ice/Debug.js\");\n__webpack_require__(/*! ../Ice/EndpointTypes */ \"./node_modules/ice/src/Ice/EndpointTypes.js\");\n__webpack_require__(/*! ../Ice/Exception */ \"./node_modules/ice/src/Ice/Exception.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/LocalException */ \"./node_modules/ice/src/Ice/LocalException.js\");\n__webpack_require__(/*! ../Ice/Promise */ \"./node_modules/ice/src/Ice/Promise.js\");\n\nconst AsyncResultBase = Ice.AsyncResultBase;\nconst ConnectionI = Ice.ConnectionI;\nconst Debug = Ice.Debug;\nconst FactoryACMMonitor = Ice.FactoryACMMonitor;\nconst HashMap = Ice.HashMap;\n\n//\n// Only for use by Instance.\n//\nclass OutgoingConnectionFactory\n{\n    constructor(communicator, instance)\n    {\n        this._communicator = communicator;\n        this._instance = instance;\n        this._destroyed = false;\n\n        this._monitor = new FactoryACMMonitor(this._instance, this._instance.clientACM());\n\n        this._connectionsByEndpoint = new ConnectionListMap(); // map<EndpointI, Array<Ice.ConnectionI>>\n        this._pending = new HashMap(HashMap.compareEquals); // map<EndpointI, Array<ConnectCallback>>\n        this._pendingConnectCount = 0;\n\n        this._waitPromise = null;\n    }\n\n    destroy()\n    {\n        if(this._destroyed)\n        {\n            return;\n        }\n\n        this._connectionsByEndpoint.forEach(connection => connection.destroy(ConnectionI.CommunicatorDestroyed));\n\n        this._destroyed = true;\n        this._communicator = null;\n        this.checkFinished();\n    }\n\n    waitUntilFinished()\n    {\n        this._waitPromise = new Ice.Promise();\n        this.checkFinished();\n        return this._waitPromise;\n    }\n\n    //\n    // Returns a promise, success callback receives the connection\n    //\n    create(endpts, hasMore, selType)\n    {\n        Debug.assert(endpts.length > 0);\n\n        //\n        // Apply the overrides.\n        //\n        const endpoints = this.applyOverrides(endpts);\n\n        //\n        // Try to find a connection to one of the given endpoints.\n        //\n        try\n        {\n            const connection = this.findConnectionByEndpoint(endpoints);\n            if(connection !== null)\n            {\n                return Ice.Promise.resolve(connection);\n            }\n        }\n        catch(ex)\n        {\n            return Ice.Promise.reject(ex);\n        }\n\n        return new ConnectCallback(this, endpoints, hasMore, selType).start();\n    }\n\n    setRouterInfo(routerInfo)\n    {\n        return Ice.Promise.try(() =>\n            {\n                if(this._destroyed)\n                {\n                    throw new Ice.CommunicatorDestroyedException();\n                }\n                return routerInfo.getClientEndpoints();\n            }\n        ).then(\n            endpoints =>\n            {\n                //\n                // Search for connections to the router's client proxy\n                // endpoints, and update the object adapter for such\n                // connections, so that callbacks from the router can be\n                // received over such connections.\n                //\n                const adapter = routerInfo.getAdapter();\n                const defaultsAndOverrides = this._instance.defaultsAndOverrides();\n                endpoints.forEach(endpoint =>\n                {\n                    //\n                    // Modify endpoints with overrides.\n                    //\n                    if(defaultsAndOverrides.overrideTimeout)\n                    {\n                        endpoint = endpoint.changeTimeout(defaultsAndOverrides.overrideTimeoutValue);\n                    }\n\n                    //\n                    // The Connection object does not take the compression flag of\n                    // endpoints into account, but instead gets the information\n                    // about whether messages should be compressed or not from\n                    // other sources. In order to allow connection sharing for\n                    // endpoints that differ in the value of the compression flag\n                    // only, we always set the compression flag to false here in\n                    // this connection factory.\n                    //\n                    endpoint = endpoint.changeCompress(false);\n\n                    this._connectionsByEndpoint.forEach(connection =>\n                                                        {\n                                                            if(connection.endpoint().equals(endpoint))\n                                                            {\n                                                                connection.setAdapter(adapter);\n                                                            }\n                                                        });\n                });\n            });\n    }\n\n    removeAdapter(adapter)\n    {\n        if(this._destroyed)\n        {\n            return;\n        }\n        this._connectionsByEndpoint.forEach(connection =>\n                                            {\n                                                if(connection.getAdapter() === adapter)\n                                                {\n                                                    connection.setAdapter(null);\n                                                }\n                                            });\n    }\n\n    flushAsyncBatchRequests()\n    {\n        const promise = new AsyncResultBase(this._communicator, \"flushBatchRequests\", null, null, null);\n        if(this._destroyed)\n        {\n            promise.resolve();\n            return promise;\n        }\n\n        Ice.Promise.all(\n            this._connectionsByEndpoint.map(\n                connection =>\n                {\n                    if(connection.isActiveOrHolding())\n                    {\n                        return connection.flushBatchRequests().catch(\n                            ex =>\n                            {\n                                if(ex instanceof Ice.LocalException)\n                                {\n                                    // Ignore\n                                }\n                                else\n                                {\n                                    throw ex;\n                                }\n                            });\n                    }\n                })).then(promise.resolve, promise.reject);\n        return promise;\n    }\n\n    applyOverrides(endpts)\n    {\n        const defaultsAndOverrides = this._instance.defaultsAndOverrides();\n        return endpts.map(\n            endpoint =>\n                {\n                    if(defaultsAndOverrides.overrideTimeout)\n                    {\n                        return endpoint.changeTimeout(defaultsAndOverrides.overrideTimeoutValue);\n                    }\n                    else\n                    {\n                        return endpoint;\n                    }\n                });\n    }\n\n    findConnectionByEndpoint(endpoints)\n    {\n        if(this._destroyed)\n        {\n            throw new Ice.CommunicatorDestroyedException();\n        }\n\n        Debug.assert(endpoints.length > 0);\n\n        for(let i = 0; i < endpoints.length; ++i)\n        {\n            const endpoint = endpoints[i];\n\n            if(this._pending.has(endpoint))\n            {\n                continue;\n            }\n\n            const connectionList = this._connectionsByEndpoint.get(endpoint);\n            if(connectionList === undefined)\n            {\n                continue;\n            }\n\n            for(let j = 0; j < connectionList.length; ++j)\n            {\n                if(connectionList[j].isActiveOrHolding()) // Don't return destroyed or un-validated connections\n                {\n                    return connectionList[j];\n                }\n            }\n        }\n\n        return null;\n    }\n\n    incPendingConnectCount()\n    {\n        //\n        // Keep track of the number of pending connects. The outgoing connection factory\n        // waitUntilFinished() method waits for all the pending connects to terminate before\n        // to return. This ensures that the communicator client thread pool isn't destroyed\n        // too soon and will still be available to execute the ice_exception() callbacks for\n        // the asynchronous requests waiting on a connection to be established.\n        //\n\n        if(this._destroyed)\n        {\n            throw new Ice.CommunicatorDestroyedException();\n        }\n        ++this._pendingConnectCount;\n    }\n\n    decPendingConnectCount()\n    {\n        --this._pendingConnectCount;\n        Debug.assert(this._pendingConnectCount >= 0);\n        if(this._destroyed && this._pendingConnectCount === 0)\n        {\n            this.checkFinished();\n        }\n    }\n\n    getConnection(endpoints, cb)\n    {\n        if(this._destroyed)\n        {\n            throw new Ice.CommunicatorDestroyedException();\n        }\n\n        //\n        // Reap closed connections\n        //\n        const cons = this._monitor.swapReapedConnections();\n        if(cons !== null)\n        {\n            cons.forEach(c =>\n                {\n                    this._connectionsByEndpoint.removeConnection(c.endpoint(), c);\n                    this._connectionsByEndpoint.removeConnection(c.endpoint().changeCompress(true), c);\n                });\n        }\n\n        //\n        // Try to get the connection.\n        //\n        while(true)\n        {\n            if(this._destroyed)\n            {\n                throw new Ice.CommunicatorDestroyedException();\n            }\n\n            //\n            // Search for a matching connection. If we find one, we're done.\n            //\n            const connection = this.findConnectionByEndpoint(endpoints);\n            if(connection !== null)\n            {\n                return connection;\n            }\n\n            if(this.addToPending(cb, endpoints))\n            {\n                //\n                // A connection is already pending.\n                //\n                return null;\n            }\n            else\n            {\n                //\n                // No connection is currently pending to one of our endpoints, so we\n                // get out of this loop and start the connection establishment to one of the\n                // given endpoints.\n                //\n                break;\n            }\n        }\n\n        //\n        // At this point, we're responsible for establishing the connection to one of\n        // the given endpoints. If it's a non-blocking connect, calling nextEndpoint\n        // will start the connection establishment. Otherwise, we return null to get\n        // the caller to establish the connection.\n        //\n        cb.nextEndpoint();\n\n        return null;\n    }\n\n    createConnection(transceiver, endpoint)\n    {\n        Debug.assert(this._pending.has(endpoint) && transceiver !== null);\n\n        //\n        // Create and add the connection to the connection map. Adding the connection to the map\n        // is necessary to support the interruption of the connection initialization and validation\n        // in case the communicator is destroyed.\n        //\n        let connection = null;\n        try\n        {\n            if(this._destroyed)\n            {\n                throw new Ice.CommunicatorDestroyedException();\n            }\n\n            connection = new ConnectionI(this._communicator, this._instance, this._monitor, transceiver,\n                                         endpoint.changeCompress(false), false, null);\n        }\n        catch(ex)\n        {\n            if(ex instanceof Ice.LocalException)\n            {\n                try\n                {\n                    transceiver.close();\n                }\n                catch(exc)\n                {\n                    // Ignore\n                }\n            }\n            throw ex;\n        }\n\n        this._connectionsByEndpoint.set(connection.endpoint(), connection);\n        this._connectionsByEndpoint.set(connection.endpoint().changeCompress(true), connection);\n        return connection;\n    }\n\n    finishGetConnection(endpoints, endpoint, connection, cb)\n    {\n        // cb is-a ConnectCallback\n\n        const connectionCallbacks = [];\n        if(cb !== null)\n        {\n            connectionCallbacks.push(cb);\n        }\n\n        const callbacks = [];\n        endpoints.forEach(endpt =>\n            {\n                const cbs = this._pending.get(endpt);\n                if(cbs !== undefined)\n                {\n                    this._pending.delete(endpt);\n                    cbs.forEach(cc =>\n                        {\n                            if(cc.hasEndpoint(endpoint))\n                            {\n                                if(connectionCallbacks.indexOf(cc) === -1)\n                                {\n                                    connectionCallbacks.push(cc);\n                                }\n                            }\n                            else if(callbacks.indexOf(cc) === -1)\n                            {\n                                callbacks.push(cc);\n                            }\n                        });\n                }\n            });\n\n        connectionCallbacks.forEach(cc =>\n            {\n                cc.removeFromPending();\n                const idx = callbacks.indexOf(cc);\n                if(idx !== -1)\n                {\n                    callbacks.splice(idx, 1);\n                }\n            });\n\n        callbacks.forEach(cc => cc.removeFromPending());\n\n        callbacks.forEach(cc => cc.getConnection());\n        connectionCallbacks.forEach(cc => cc.setConnection(connection));\n\n        this.checkFinished();\n    }\n\n    finishGetConnectionEx(endpoints, ex, cb)\n    {\n        // cb is-a ConnectCallback\n\n        const failedCallbacks = [];\n        if(cb !== null)\n        {\n            failedCallbacks.push(cb);\n        }\n\n        const callbacks = [];\n        endpoints.forEach(endpt =>\n            {\n                const cbs = this._pending.get(endpt);\n                if(cbs !== undefined)\n                {\n                    this._pending.delete(endpt);\n                    cbs.forEach(cc =>\n                        {\n                            if(cc.removeEndpoints(endpoints))\n                            {\n                                if(failedCallbacks.indexOf(cc) === -1)\n                                {\n                                    failedCallbacks.push(cc);\n                                }\n                            }\n                            else if(callbacks.indexOf(cc) === -1)\n                            {\n                                callbacks.push(cc);\n                            }\n                        });\n                }\n            });\n\n        callbacks.forEach(cc =>\n            {\n                Debug.assert(failedCallbacks.indexOf(cc) === -1);\n                cc.removeFromPending();\n            });\n        this.checkFinished();\n        callbacks.forEach(cc => cc.getConnection());\n        failedCallbacks.forEach(cc => cc.setException(ex));\n    }\n\n    addToPending(cb, endpoints)\n    {\n        // cb is-a ConnectCallback\n\n        //\n        // Add the callback to each pending list.\n        //\n        let found = false;\n        if(cb !== null)\n        {\n            endpoints.forEach(p =>\n                {\n                    const cbs = this._pending.get(p);\n                    if(cbs !== undefined)\n                    {\n                        found = true;\n                        if(cbs.indexOf(cb) === -1)\n                        {\n                            cbs.push(cb); // Add the callback to each pending endpoint.\n                        }\n                    }\n                });\n        }\n\n        if(found)\n        {\n            return true;\n        }\n\n        //\n        // If there's no pending connection for the given endpoints, we're\n        // responsible for its establishment. We add empty pending lists,\n        // other callbacks to the same endpoints will be queued.\n        //\n        endpoints.forEach(p =>\n            {\n                if(!this._pending.has(p))\n                {\n                    this._pending.set(p, []);\n                }\n            });\n\n        return false;\n    }\n\n    removeFromPending(cb, endpoints)\n    {\n        // cb is-a ConnectCallback\n        endpoints.forEach(p =>\n            {\n                const cbs = this._pending.get(p);\n                if(cbs !== undefined)\n                {\n                    const idx = cbs.indexOf(cb);\n                    if(idx !== -1)\n                    {\n                        cbs.splice(idx, 1);\n                    }\n                }\n            });\n    }\n\n    handleConnectionException(ex, hasMore)\n    {\n        const traceLevels = this._instance.traceLevels();\n        if(traceLevels.network >= 2)\n        {\n            const s = [];\n            s.push(\"connection to endpoint failed\");\n            if(ex instanceof Ice.CommunicatorDestroyedException)\n            {\n                s.push(\"\\n\");\n            }\n            else if(hasMore)\n            {\n                s.push(\", trying next endpoint\\n\");\n            }\n            else\n            {\n                s.push(\" and no more endpoints to try\\n\");\n            }\n            s.push(ex.toString());\n            this._instance.initializationData().logger.trace(traceLevels.networkCat, s.join(\"\"));\n        }\n    }\n\n    handleException(ex, hasMore)\n    {\n        const traceLevels = this._instance.traceLevels();\n        if(traceLevels.network >= 2)\n        {\n            const s = [];\n            s.push(\"couldn't resolve endpoint host\");\n            if(ex instanceof Ice.CommunicatorDestroyedException)\n            {\n                s.push(\"\\n\");\n            }\n            else if(hasMore)\n            {\n                s.push(\", trying next endpoint\\n\");\n            }\n            else\n            {\n                s.push(\" and no more endpoints to try\\n\");\n            }\n            s.push(ex.toString());\n            this._instance.initializationData().logger.trace(traceLevels.networkCat, s.join(\"\"));\n        }\n    }\n\n    checkFinished()\n    {\n        //\n        // Can't continue until the factory is destroyed and there are no pending connections.\n        //\n        if(!this._waitPromise || !this._destroyed || this._pending.size > 0 || this._pendingConnectCount > 0)\n        {\n            return;\n        }\n\n        Ice.Promise.all(\n            this._connectionsByEndpoint.map(\n                connection => connection.waitUntilFinished().catch(ex => Debug.assert(false)))\n        ).then(\n            () =>\n            {\n                const cons = this._monitor.swapReapedConnections();\n                if(cons !== null)\n                {\n                    const arr = [];\n                    this._connectionsByEndpoint.forEach(connection =>\n                    {\n                        if(arr.indexOf(connection) === -1)\n                        {\n                            arr.push(connection);\n                        }\n                    });\n                    Debug.assert(cons.length === arr.length);\n                    this._connectionsByEndpoint.clear();\n                }\n                else\n                {\n                    Debug.assert(this._connectionsByEndpoint.size === 0);\n                }\n\n                Debug.assert(this._waitPromise !== null);\n                this._waitPromise.resolve();\n                this._monitor.destroy();\n            });\n    }\n}\n\nIce.OutgoingConnectionFactory = OutgoingConnectionFactory;\nmodule.exports.Ice = Ice;\n\n//\n// Value is a Vector<Ice.ConnectionI>\n//\nclass ConnectionListMap extends HashMap\n{\n    constructor(h)\n    {\n        super(h || HashMap.compareEquals);\n    }\n\n    set(key, value)\n    {\n        let list = this.get(key);\n        if(list === undefined)\n        {\n            list = [];\n            super.set(key, list);\n        }\n        Debug.assert(value instanceof ConnectionI);\n        list.push(value);\n        return undefined;\n    }\n\n    removeConnection(key, conn)\n    {\n        const list = this.get(key);\n        Debug.assert(list !== null);\n        const idx = list.indexOf(conn);\n        Debug.assert(idx !== -1);\n        list.splice(idx, 1);\n        if(list.length === 0)\n        {\n            this.delete(key);\n        }\n    }\n\n    map(fn)\n    {\n        const arr = [];\n        this.forEach(c => arr.push(fn(c)));\n        return arr;\n    }\n\n    forEach(fn)\n    {\n        for(const connections of this.values())\n        {\n            connections.forEach(fn);\n        }\n    }\n}\n\nclass ConnectCallback\n{\n    constructor(f, endpoints, more, selType)\n    {\n        this._factory = f;\n        this._endpoints = endpoints;\n        this._hasMore = more;\n        this._selType = selType;\n        this._promise = new Ice.Promise();\n        this._index = 0;\n        this._current = null;\n    }\n\n    //\n    // Methods from ConnectionI_StartCallback\n    //\n    connectionStartCompleted(connection)\n    {\n        connection.activate();\n        this._factory.finishGetConnection(this._endpoints, this._current, connection, this);\n    }\n\n    connectionStartFailed(connection, ex)\n    {\n        Debug.assert(this._current !== null);\n        if(this.connectionStartFailedImpl(ex))\n        {\n            this.nextEndpoint();\n        }\n    }\n\n    setConnection(connection)\n    {\n        //\n        // Callback from the factory: the connection to one of the callback\n        // connectors has been established.\n        //\n        this._promise.resolve(connection);\n        this._factory.decPendingConnectCount(); // Must be called last.\n    }\n\n    setException(ex)\n    {\n        //\n        // Callback from the factory: connection establishment failed.\n        //\n        this._promise.reject(ex);\n        this._factory.decPendingConnectCount(); // Must be called last.\n    }\n\n    hasEndpoint(endpoint)\n    {\n        return this.findEndpoint(endpoint) !== -1;\n    }\n\n    findEndpoint(endpoint)\n    {\n        return this._endpoints.findIndex(value => endpoint.equals(value));\n    }\n\n    removeEndpoints(endpoints)\n    {\n        endpoints.forEach(endpoint =>\n            {\n                const idx = this.findEndpoint(endpoint);\n                if(idx !== -1)\n                {\n                    this._endpoints.splice(idx, 1);\n                }\n            });\n        this._index = 0;\n        return this._endpoints.length === 0;\n    }\n\n    removeFromPending()\n    {\n        this._factory.removeFromPending(this, this._endpoints);\n    }\n\n    start()\n    {\n        try\n        {\n            //\n            // Notify the factory that there's an async connect pending. This is necessary\n            // to prevent the outgoing connection factory to be destroyed before all the\n            // pending asynchronous connects are finished.\n            //\n            this._factory.incPendingConnectCount();\n        }\n        catch(ex)\n        {\n            this._promise.reject(ex);\n            return;\n        }\n\n        this.getConnection();\n        return this._promise;\n    }\n\n    getConnection()\n    {\n        try\n        {\n            //\n            // Ask the factory to get a connection.\n            //\n            const connection = this._factory.getConnection(this._endpoints, this);\n            if(connection === null)\n            {\n                //\n                // A null return value from getConnection indicates that the connection\n                // is being established and that everthing has been done to ensure that\n                // the callback will be notified when the connection establishment is\n                // done.\n                //\n                return;\n            }\n\n            this._promise.resolve(connection);\n            this._factory.decPendingConnectCount(); // Must be called last.\n        }\n        catch(ex)\n        {\n            this._promise.reject(ex);\n            this._factory.decPendingConnectCount(); // Must be called last.\n        }\n    }\n\n    nextEndpoint()\n    {\n\n        const start = connection =>\n            {\n                connection.start().then(\n                    () =>\n                    {\n                        this.connectionStartCompleted(connection);\n                    },\n                    ex =>\n                    {\n                        this.connectionStartFailed(connection, ex);\n                    });\n            };\n\n        while(true)\n        {\n            const traceLevels = this._factory._instance.traceLevels();\n            try\n            {\n                Debug.assert(this._index < this._endpoints.length);\n                this._current = this._endpoints[this._index++];\n\n                if(traceLevels.network >= 2)\n                {\n                    const s = [];\n                    s.push(\"trying to establish \");\n                    s.push(this._current.protocol());\n                    s.push(\" connection to \");\n                    s.push(this._current.toConnectorString());\n                    this._factory._instance.initializationData().logger.trace(traceLevels.networkCat, s.join(\"\"));\n                }\n\n                start(this._factory.createConnection(this._current.connect(), this._current));\n            }\n            catch(ex)\n            {\n                if(traceLevels.network >= 2)\n                {\n                    const s = [];\n                    s.push(\"failed to establish \");\n                    s.push(this._current.protocol());\n                    s.push(\" connection to \");\n                    s.push(this._current.toString());\n                    s.push(\"\\n\");\n                    s.push(ex.toString());\n                    this._factory._instance.initializationData().logger.trace(traceLevels.networkCat, s.join(\"\"));\n                }\n\n                if(this.connectionStartFailedImpl(ex))\n                {\n                    continue;\n                }\n            }\n            break;\n        }\n    }\n\n    connectionStartFailedImpl(ex)\n    {\n        if(ex instanceof Ice.LocalException)\n        {\n            this._factory.handleConnectionException(ex, this._hasMore || this._index < this._endpoints.length);\n            if(ex instanceof Ice.CommunicatorDestroyedException) // No need to continue.\n            {\n                this._factory.finishGetConnectionEx(this._endpoints, ex, this);\n            }\n            else if(this._index < this._endpoints.length) // Try the next endpoint.\n            {\n                return true;\n            }\n            else\n            {\n                this._factory.finishGetConnectionEx(this._endpoints, ex, this);\n            }\n        }\n        else\n        {\n            this._factory.finishGetConnectionEx(this._endpoints, ex, this);\n        }\n        return false;\n    }\n}\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/OutgoingConnectionFactory.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/PluginF.js":
/*!*********************************************!*\
  !*** ./node_modules/ice/src/Ice/PluginF.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n//\n// Ice version 3.7.10\n//\n// <auto-generated>\n//\n// Generated from file `PluginF.ice'\n//\n// Warning: do not edit this file.\n//\n// </auto-generated>\n//\n\n/* eslint-disable */\n/* jshint ignore: start */\n\n/* slice2js browser-bundle-skip */\nconst _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\nconst Ice = _ModuleRegistry.module(\"Ice\");\n\nconst Slice = Ice.Slice;\n/* slice2js browser-bundle-skip-end */\n/* slice2js browser-bundle-skip */\nexports.Ice = Ice;\n/* slice2js browser-bundle-skip-end */\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/PluginF.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/Process.js":
/*!*********************************************!*\
  !*** ./node_modules/ice/src/Ice/Process.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n//\n// Ice version 3.7.10\n//\n// <auto-generated>\n//\n// Generated from file `Process.ice'\n//\n// Warning: do not edit this file.\n//\n// </auto-generated>\n//\n\n/* eslint-disable */\n/* jshint ignore: start */\n\n/* slice2js browser-bundle-skip */\nconst _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\n__webpack_require__(/*! ../Ice/Object */ \"./node_modules/ice/src/Ice/Object.js\");\n__webpack_require__(/*! ../Ice/Value */ \"./node_modules/ice/src/Ice/Value.js\");\n__webpack_require__(/*! ../Ice/ObjectPrx */ \"./node_modules/ice/src/Ice/ObjectPrx.js\");\n__webpack_require__(/*! ../Ice/Operation */ \"./node_modules/ice/src/Ice/Operation.js\");\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\nconst Ice = _ModuleRegistry.module(\"Ice\");\n\nconst Slice = Ice.Slice;\n/* slice2js browser-bundle-skip-end */\n\nconst iceC_Ice_Process_ids = [\n    \"::Ice::Object\",\n    \"::Ice::Process\"\n];\n\n/**\n * An administrative interface for process management. Managed servers must\n * implement this interface.\n *\n * <p class=\"Note\">A servant implementing this interface is a potential target\n * for denial-of-service attacks, therefore proper security precautions\n * should be taken. For example, the servant can use a UUID to make its\n * identity harder to guess, and be registered in an object adapter with\n * a secured endpoint.\n *\n **/\nIce.Process = class extends Ice.Object\n{\n};\n\nIce.ProcessPrx = class extends Ice.ObjectPrx\n{\n};\n\nSlice.defineOperations(Ice.Process, Ice.ProcessPrx, iceC_Ice_Process_ids, 1,\n{\n    \"shutdown\": [, , , , , , , , , ],\n    \"writeMessage\": [, , , , , [[7], [3]], , , , ]\n});\n/* slice2js browser-bundle-skip */\nexports.Ice = Ice;\n/* slice2js browser-bundle-skip-end */\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/Process.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/ProcessLogger.js":
/*!***************************************************!*\
  !*** ./node_modules/ice/src/Ice/ProcessLogger.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nconst Ice = (__webpack_require__(/*! ../Ice/LoggerI */ \"./node_modules/ice/src/Ice/LoggerI.js\").Ice);\nconst Logger = Ice.Logger;\n\nlet processLogger = null;\n\nIce.getProcessLogger = function()\n{\n    if(processLogger === null)\n    {\n        //\n        // TODO: Would be nice to be able to use process name as prefix by default.\n        //\n        processLogger = new Logger(\"\", \"\");\n    }\n\n    return processLogger;\n};\n\nIce.setProcessLogger = function(logger)\n{\n    processLogger = logger;\n};\n\nmodule.exports.Ice = Ice;\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/ProcessLogger.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/Promise.js":
/*!*********************************************!*\
  !*** ./node_modules/ice/src/Ice/Promise.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nconst Ice = (__webpack_require__(/*! ../Ice/Timer */ \"./node_modules/ice/src/Ice/Timer.js\").Ice);\n\nconst Timer = Ice.Timer;\n\nclass P extends Promise\n{\n    constructor(cb)\n    {\n        let res;\n        let rej;\n        super((resolve, reject) =>\n            {\n                res = resolve;\n                rej = reject;\n\n                if(cb)\n                {\n                    cb(resolve, reject);\n                }\n            });\n\n        this.resolve = res;\n        this.reject = rej;\n    }\n\n    delay(ms)\n    {\n        return this.then(\n            value => new P((resolve, reject) => Timer.setTimeout(() => resolve(value), ms)),\n            reason => new P((resolve, reject) => Timer.setTimeout(() => reject(reason), ms)));\n    }\n\n    static get [Symbol.species]()\n    {\n        return P;\n    }\n\n    static delay(ms, value)\n    {\n        return new P(resolve => Timer.setTimeout(() => resolve(value), ms));\n    }\n\n    static try(cb)\n    {\n        return P.resolve().then(cb);\n    }\n}\n\nIce.Promise = P;\nmodule.exports.Ice = Ice;\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/Promise.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/Properties.js":
/*!************************************************!*\
  !*** ./node_modules/ice/src/Ice/Properties.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n//\n// Ice version 3.7.10\n//\n// <auto-generated>\n//\n// Generated from file `Properties.ice'\n//\n// Warning: do not edit this file.\n//\n// </auto-generated>\n//\n\n/* eslint-disable */\n/* jshint ignore: start */\n\n/* slice2js browser-bundle-skip */\nconst _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\n__webpack_require__(/*! ../Ice/Object */ \"./node_modules/ice/src/Ice/Object.js\");\n__webpack_require__(/*! ../Ice/Value */ \"./node_modules/ice/src/Ice/Value.js\");\n__webpack_require__(/*! ../Ice/ObjectPrx */ \"./node_modules/ice/src/Ice/ObjectPrx.js\");\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\n__webpack_require__(/*! ../Ice/PropertiesAdmin */ \"./node_modules/ice/src/Ice/PropertiesAdmin.js\");\nconst Ice = _ModuleRegistry.module(\"Ice\");\n\nconst Slice = Ice.Slice;\n/* slice2js browser-bundle-skip-end */\n/* slice2js browser-bundle-skip */\nexports.Ice = Ice;\n/* slice2js browser-bundle-skip-end */\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/Properties.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/PropertiesAdmin.js":
/*!*****************************************************!*\
  !*** ./node_modules/ice/src/Ice/PropertiesAdmin.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n//\n// Ice version 3.7.10\n//\n// <auto-generated>\n//\n// Generated from file `PropertiesAdmin.ice'\n//\n// Warning: do not edit this file.\n//\n// </auto-generated>\n//\n\n/* eslint-disable */\n/* jshint ignore: start */\n\n/* slice2js browser-bundle-skip */\nconst _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\n__webpack_require__(/*! ../Ice/Object */ \"./node_modules/ice/src/Ice/Object.js\");\n__webpack_require__(/*! ../Ice/Value */ \"./node_modules/ice/src/Ice/Value.js\");\n__webpack_require__(/*! ../Ice/ObjectPrx */ \"./node_modules/ice/src/Ice/ObjectPrx.js\");\n__webpack_require__(/*! ../Ice/Operation */ \"./node_modules/ice/src/Ice/Operation.js\");\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\n__webpack_require__(/*! ../Ice/BuiltinSequences */ \"./node_modules/ice/src/Ice/BuiltinSequences.js\");\nconst Ice = _ModuleRegistry.module(\"Ice\");\n\nconst Slice = Ice.Slice;\n/* slice2js browser-bundle-skip-end */\n\nSlice.defineDictionary(Ice, \"PropertyDict\", \"PropertyDictHelper\", \"Ice.StringHelper\", \"Ice.StringHelper\", false, undefined, undefined);\n\nconst iceC_Ice_PropertiesAdmin_ids = [\n    \"::Ice::Object\",\n    \"::Ice::PropertiesAdmin\"\n];\n\n/**\n * The PropertiesAdmin interface provides remote access to the properties\n * of a communicator.\n *\n **/\nIce.PropertiesAdmin = class extends Ice.Object\n{\n};\n\nIce.PropertiesAdminPrx = class extends Ice.ObjectPrx\n{\n};\n\nSlice.defineOperations(Ice.PropertiesAdmin, Ice.PropertiesAdminPrx, iceC_Ice_PropertiesAdmin_ids, 1,\n{\n    \"getProperty\": [, , , , [7], [[7]], , , , ],\n    \"getPropertiesForPrefix\": [, , , , [\"Ice.PropertyDictHelper\"], [[7]], , , , ],\n    \"setProperties\": [, , , , , [[\"Ice.PropertyDictHelper\"]], , , , ]\n});\n/* slice2js browser-bundle-skip */\nexports.Ice = Ice;\n/* slice2js browser-bundle-skip-end */\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/PropertiesAdmin.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/PropertiesI.js":
/*!*************************************************!*\
  !*** ./node_modules/ice/src/Ice/PropertiesI.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nconst Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n\n__webpack_require__(/*! ../Ice/Debug */ \"./node_modules/ice/src/Ice/Debug.js\");\n__webpack_require__(/*! ../Ice/LocalException */ \"./node_modules/ice/src/Ice/LocalException.js\");\n__webpack_require__(/*! ../Ice/ProcessLogger */ \"./node_modules/ice/src/Ice/ProcessLogger.js\");\n__webpack_require__(/*! ../Ice/ProcessLogger */ \"./node_modules/ice/src/Ice/ProcessLogger.js\");\n__webpack_require__(/*! ../Ice/PropertyNames */ \"./node_modules/ice/src/Ice/PropertyNames.js\");\n__webpack_require__(/*! ../Ice/StringUtil */ \"./node_modules/ice/src/Ice/StringUtil.js\");\n\nconst StringUtil = Ice.StringUtil;\nconst PropertyNames = Ice.PropertyNames;\nconst Debug = Ice.Debug;\nconst getProcessLogger = Ice.getProcessLogger;\nconst InitializationException = Ice.InitializationException;\n\nconst ParseStateKey = 0;\nconst ParseStateValue = 1;\n//\n// Ice.Properties\n//\nclass Properties\n{\n    constructor(args, defaults)\n    {\n        this._properties = new Map();\n\n        if(defaults !== undefined && defaults !== null)\n        {\n            //\n            // NOTE: we can't just do a shallow copy of the map as the map values\n            // would otherwise be shared between the two PropertiesI object.\n            //\n            for(const [key, property] of defaults._properties)\n            {\n                this._properties.set(key, {value: property.value, used: false});\n            }\n        }\n\n        if(args !== undefined && args !== null)\n        {\n            const v = this.parseIceCommandLineOptions(args);\n            args.length = 0;\n            for(let i = 0; i < v.length; ++i)\n            {\n                args.push(v[i]);\n            }\n        }\n    }\n\n    getProperty(key)\n    {\n        return this.getPropertyWithDefault(key, \"\");\n    }\n\n    getPropertyWithDefault(key, value)\n    {\n        const pv = this._properties.get(key);\n        if(pv !== undefined)\n        {\n            pv.used = true;\n            return pv.value;\n        }\n        else\n        {\n            return value;\n        }\n    }\n\n    getPropertyAsInt(key)\n    {\n        return this.getPropertyAsIntWithDefault(key, 0);\n    }\n\n    getPropertyAsIntWithDefault(key, value)\n    {\n        const pv = this._properties.get(key);\n        if(pv !== undefined)\n        {\n            pv.used = true;\n            return parseInt(pv.value);\n        }\n        else\n        {\n            return value;\n        }\n    }\n\n    getPropertyAsList(key)\n    {\n        return this.getPropertyAsListWithDefault(key, 0);\n    }\n\n    getPropertyAsListWithDefault(key, value)\n    {\n        if(value === undefined || value === null)\n        {\n            value = [];\n        }\n\n        const pv = this._properties.get(key);\n        if(pv !== undefined)\n        {\n            pv.used = true;\n\n            let result = StringUtil.splitString(pv.value, \", \\t\\r\\n\");\n            if(result === null)\n            {\n                getProcessLogger().warning(\"mismatched quotes in property \" + key + \"'s value, returning default value\");\n                return value;\n            }\n            if(result.length === 0)\n            {\n                result = value;\n            }\n            return result;\n        }\n        else\n        {\n            return value;\n        }\n    }\n\n    getPropertiesForPrefix(prefix = \"\")\n    {\n        const result = new Map();\n        this._properties.forEach((property, key) =>\n            {\n                if(key.indexOf(prefix) === 0)\n                {\n                    property.used = true;\n                    result.set(key, property.value);\n                }\n            });\n        return result;\n    }\n\n    setProperty(key = \"\", value = \"\")\n    {\n        //\n        // Trim whitespace\n        //\n        if(key !== null)\n        {\n            key = key.trim();\n        }\n\n        //\n        // Check if the property is legal.\n        //\n        const logger = getProcessLogger();\n        if(key === null || key.length === 0)\n        {\n            throw new InitializationException(\"Attempt to set property with empty key\");\n        }\n\n        let dotPos = key.indexOf(\".\");\n        if(dotPos !== -1)\n        {\n            const prefix = key.substr(0, dotPos);\n            for(let i = 0; i < PropertyNames.validProps.length; ++i)\n            {\n                let pattern = PropertyNames.validProps[i][0].pattern;\n                dotPos = pattern.indexOf(\".\");\n                //\n                // Each top level prefix describes a non-empty namespace. Having a string without a\n                // prefix followed by a dot is an error.\n                //\n                Debug.assert(dotPos != -1);\n                if(pattern.substring(0, dotPos - 1) != prefix)\n                {\n                    continue;\n                }\n\n                let found = false;\n                let mismatchCase = false;\n                let otherKey;\n                for(let j = 0; j < PropertyNames.validProps[i][j].length && !found; ++j)\n                {\n                    pattern = PropertyNames.validProps[i][j].pattern();\n                    let pComp = new RegExp(pattern);\n                    found = pComp.test(key);\n\n                    if(found && PropertyNames.validProps[i][j].deprecated)\n                    {\n                        logger.warning(\"deprecated property: \" + key);\n                        if(PropertyNames.validProps[i][j].deprecatedBy !== null)\n                        {\n                            key = PropertyNames.validProps[i][j].deprecatedBy;\n                        }\n                    }\n\n                    if(found)\n                    {\n                        break;\n                    }\n                    else\n                    {\n                        pComp = new RegExp(pattern.toUpperCase());\n                        found = pComp.test(key.toUpperCase());\n                        if(found)\n                        {\n                            mismatchCase = true;\n                            otherKey = pattern.substr(2);\n                            otherKey = otherKey.substr(0, otherKey.length - 1);\n                            otherKey = otherKey.replace(/\\\\/g, \"\");\n                            break;\n                        }\n                    }\n                }\n\n                if(!found)\n                {\n                    logger.warning(\"unknown property: \" + key);\n                }\n                else if(mismatchCase)\n                {\n                    logger.warning(\"unknown property: `\" + key + \"'; did you mean `\" + otherKey + \"'\");\n                }\n            }\n        }\n\n        //\n        // Set or clear the property.\n        //\n        if(value !== null && value.length > 0)\n        {\n            const pv = this._properties.get(key);\n            if(pv !== undefined)\n            {\n                pv.value = value;\n            }\n            else\n            {\n                this._properties.set(key, {value: value, used: false});\n            }\n        }\n        else\n        {\n            this._properties.delete(key);\n        }\n    }\n\n    getCommandLineOptions()\n    {\n        const result = [];\n        this._properties.forEach((property, key) =>\n            {\n                result.push(\"--\" + key + \"=\" + property.value);\n            });\n        return result;\n    }\n\n    parseCommandLineOptions(pfx, options)\n    {\n        if(pfx.length > 0 && pfx.charAt(pfx.length - 1) != \".\")\n        {\n            pfx += \".\";\n        }\n        pfx = \"--\" + pfx;\n\n        const result = [];\n\n        options.forEach(opt =>\n            {\n                if(opt.indexOf(pfx) === 0)\n                {\n                    if(opt.indexOf('=') === -1)\n                    {\n                        opt += \"=1\";\n                    }\n\n                    this.parseLine(opt.substring(2));\n                }\n                else\n                {\n                    result.push(opt);\n                }\n            });\n        return result;\n    }\n\n    parseIceCommandLineOptions(options)\n    {\n        let args = options.slice();\n        for(let i = 0; i < PropertyNames.clPropNames.length; ++i)\n        {\n            args = this.parseCommandLineOptions(PropertyNames.clPropNames[i], args);\n        }\n        return args;\n    }\n\n    parse(data)\n    {\n        data.match(/[^\\r\\n]+/g).forEach(line => this.parseLine(line));\n    }\n\n    parseLine(line)\n    {\n        let key = \"\";\n        let value = \"\";\n\n        let state = ParseStateKey;\n\n        let whitespace = \"\";\n        let escapedspace = \"\";\n        let finished = false;\n\n        for(let i = 0; i < line.length; ++i)\n        {\n            let c = line.charAt(i);\n            switch(state)\n            {\n                case ParseStateKey:\n                {\n                    switch(c)\n                    {\n                        case '\\\\':\n                            if(i < line.length - 1)\n                            {\n                                c = line.charAt(++i);\n                                switch(c)\n                                {\n                                    case '\\\\':\n                                    case '#':\n                                    case '=':\n                                        key += whitespace;\n                                        whitespace = \"\";\n                                        key += c;\n                                        break;\n\n                                    case ' ':\n                                        if(key.length !== 0)\n                                        {\n                                            whitespace += c;\n                                        }\n                                        break;\n\n                                    default:\n                                        key += whitespace;\n                                        whitespace = \"\";\n                                        key += '\\\\';\n                                        key += c;\n                                        break;\n                                }\n                            }\n                            else\n                            {\n                                key += whitespace;\n                                key += c;\n                            }\n                            break;\n\n                        case ' ':\n                        case '\\t':\n                        case '\\r':\n                        case '\\n':\n                            if(key.length !== 0)\n                            {\n                                whitespace += c;\n                            }\n                            break;\n\n                        case '=':\n                            whitespace = \"\";\n                            state = ParseStateValue;\n                            break;\n\n                        case '#':\n                            finished = true;\n                            break;\n\n                        default:\n                            key += whitespace;\n                            whitespace = \"\";\n                            key += c;\n                            break;\n                    }\n                    break;\n                }\n\n                case ParseStateValue:\n                {\n                    switch(c)\n                    {\n                        case '\\\\':\n                            if(i < line.length - 1)\n                            {\n                                c = line.charAt(++i);\n                                switch(c)\n                                {\n                                    case '\\\\':\n                                    case '#':\n                                    case '=':\n                                        value += value.length === 0 ? escapedspace : whitespace;\n                                        whitespace = \"\";\n                                        escapedspace = \"\";\n                                        value += c;\n                                        break;\n\n                                    case ' ':\n                                        whitespace += c;\n                                        escapedspace += c;\n                                        break;\n\n                                    default:\n                                        value += value.length === 0 ? escapedspace : whitespace;\n                                        whitespace = \"\";\n                                        escapedspace = \"\";\n                                        value += '\\\\';\n                                        value += c;\n                                        break;\n                                }\n                            }\n                            else\n                            {\n                                value += value.length === 0 ? escapedspace : whitespace;\n                                value += c;\n                            }\n                            break;\n\n                        case ' ':\n                        case '\\t':\n                        case '\\r':\n                        case '\\n':\n                            if(value.length !== 0)\n                            {\n                                whitespace += c;\n                            }\n                            break;\n\n                        case '#':\n                            finished = true;\n                            break;\n\n                        default:\n                            value += value.length === 0 ? escapedspace : whitespace;\n                            whitespace = \"\";\n                            escapedspace = \"\";\n                            value += c;\n                            break;\n                    }\n                    break;\n                }\n\n                default:\n                {\n                    Debug.assert(false);\n                    break;\n                }\n            }\n            if(finished)\n            {\n                break;\n            }\n        }\n        value += escapedspace;\n\n        if((state === ParseStateKey && key.length !== 0) ||\n           (state == ParseStateValue && key.length === 0))\n        {\n            getProcessLogger().warning(\"invalid config file entry: \\\"\" + line + \"\\\"\");\n            return;\n        }\n        else if(key.length === 0)\n        {\n            return;\n        }\n\n        this.setProperty(key, value);\n    }\n\n    clone()\n    {\n        return new Properties(null, this);\n    }\n\n    getUnusedProperties()\n    {\n        const unused = [];\n        this._properties.forEach((property, key) =>\n            {\n                if(!property.used)\n                {\n                    unused.push(key);\n                }\n            });\n        return unused;\n    }\n\n    static createProperties(args, defaults)\n    {\n        return new Properties(args, defaults);\n    }\n}\n\nIce.Properties = Properties;\nmodule.exports.Ice = Ice;\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/PropertiesI.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/Property.js":
/*!**********************************************!*\
  !*** ./node_modules/ice/src/Ice/Property.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nconst Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n\nIce.Property = class\n{\n    constructor(pattern, deprecated, deprecatedBy)\n    {\n        this._pattern = pattern;\n        this._deprecated = deprecated;\n        this._deprecatedBy = deprecatedBy;\n    }\n\n    get pattern()\n    {\n        return this._pattern;\n    }\n\n    get deprecated()\n    {\n        return this._deprecated;\n    }\n\n    get deprecatedBy()\n    {\n        return this._deprecatedBy;\n    }\n};\n\nmodule.exports.Ice = Ice;\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/Property.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/PropertyNames.js":
/*!***************************************************!*\
  !*** ./node_modules/ice/src/Ice/PropertyNames.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n// Generated by makeprops.py from file ..\\config\\PropertyNames.xml, Fri Jan  7 10:30:00 2022\n\n// IMPORTANT: Do not edit this file -- any edits made here will be lost!\n\n/* eslint comma-dangle: \"off\" */\n/* eslint array-bracket-newline: \"off\" */\n/* eslint no-useless-escape: \"off\" */\n\nconst Ice = (__webpack_require__(/*! ../Ice/Property */ \"./node_modules/ice/src/Ice/Property.js\").Ice);\nconst PropertyNames = {};\nconst Property = Ice.Property;\nPropertyNames.IceProps =\n[\n    new Property(\"/^Ice\\.AcceptClassCycles/\", false, null),\n    new Property(\"/^Ice\\.ACM\\.Client/\", true, null),\n    new Property(\"/^Ice\\.ACM\\.Server/\", true, null),\n    new Property(\"/^Ice\\.ACM\\.Timeout/\", false, null),\n    new Property(\"/^Ice\\.ACM\\.Heartbeat/\", false, null),\n    new Property(\"/^Ice\\.ACM\\.Close/\", false, null),\n    new Property(\"/^Ice\\.ACM/\", false, null),\n    new Property(\"/^Ice\\.ACM\\.Client\\.Timeout/\", false, null),\n    new Property(\"/^Ice\\.ACM\\.Client\\.Heartbeat/\", false, null),\n    new Property(\"/^Ice\\.ACM\\.Client\\.Close/\", false, null),\n    new Property(\"/^Ice\\.ACM\\.Client/\", false, null),\n    new Property(\"/^Ice\\.ACM\\.Server\\.Timeout/\", false, null),\n    new Property(\"/^Ice\\.ACM\\.Server\\.Heartbeat/\", false, null),\n    new Property(\"/^Ice\\.ACM\\.Server\\.Close/\", false, null),\n    new Property(\"/^Ice\\.ACM\\.Server/\", false, null),\n    new Property(\"/^Ice\\.Admin\\.ACM\\.Timeout/\", false, null),\n    new Property(\"/^Ice\\.Admin\\.ACM\\.Heartbeat/\", false, null),\n    new Property(\"/^Ice\\.Admin\\.ACM\\.Close/\", false, null),\n    new Property(\"/^Ice\\.Admin\\.ACM/\", false, null),\n    new Property(\"/^Ice\\.Admin\\.AdapterId/\", false, null),\n    new Property(\"/^Ice\\.Admin\\.Endpoints/\", false, null),\n    new Property(\"/^Ice\\.Admin\\.Locator\\.EndpointSelection/\", false, null),\n    new Property(\"/^Ice\\.Admin\\.Locator\\.ConnectionCached/\", false, null),\n    new Property(\"/^Ice\\.Admin\\.Locator\\.PreferSecure/\", false, null),\n    new Property(\"/^Ice\\.Admin\\.Locator\\.LocatorCacheTimeout/\", false, null),\n    new Property(\"/^Ice\\.Admin\\.Locator\\.InvocationTimeout/\", false, null),\n    new Property(\"/^Ice\\.Admin\\.Locator\\.Locator/\", false, null),\n    new Property(\"/^Ice\\.Admin\\.Locator\\.Router/\", false, null),\n    new Property(\"/^Ice\\.Admin\\.Locator\\.CollocationOptimized/\", false, null),\n    new Property(\"/^Ice\\.Admin\\.Locator\\.Context\\../\", false, null),\n    new Property(\"/^Ice\\.Admin\\.Locator/\", false, null),\n    new Property(\"/^Ice\\.Admin\\.PublishedEndpoints/\", false, null),\n    new Property(\"/^Ice\\.Admin\\.ReplicaGroupId/\", false, null),\n    new Property(\"/^Ice\\.Admin\\.Router\\.EndpointSelection/\", false, null),\n    new Property(\"/^Ice\\.Admin\\.Router\\.ConnectionCached/\", false, null),\n    new Property(\"/^Ice\\.Admin\\.Router\\.PreferSecure/\", false, null),\n    new Property(\"/^Ice\\.Admin\\.Router\\.LocatorCacheTimeout/\", false, null),\n    new Property(\"/^Ice\\.Admin\\.Router\\.InvocationTimeout/\", false, null),\n    new Property(\"/^Ice\\.Admin\\.Router\\.Locator/\", false, null),\n    new Property(\"/^Ice\\.Admin\\.Router\\.Router/\", false, null),\n    new Property(\"/^Ice\\.Admin\\.Router\\.CollocationOptimized/\", false, null),\n    new Property(\"/^Ice\\.Admin\\.Router\\.Context\\../\", false, null),\n    new Property(\"/^Ice\\.Admin\\.Router/\", false, null),\n    new Property(\"/^Ice\\.Admin\\.ProxyOptions/\", false, null),\n    new Property(\"/^Ice\\.Admin\\.ThreadPool\\.Size/\", false, null),\n    new Property(\"/^Ice\\.Admin\\.ThreadPool\\.SizeMax/\", false, null),\n    new Property(\"/^Ice\\.Admin\\.ThreadPool\\.SizeWarn/\", false, null),\n    new Property(\"/^Ice\\.Admin\\.ThreadPool\\.StackSize/\", false, null),\n    new Property(\"/^Ice\\.Admin\\.ThreadPool\\.Serialize/\", false, null),\n    new Property(\"/^Ice\\.Admin\\.ThreadPool\\.ThreadIdleTime/\", false, null),\n    new Property(\"/^Ice\\.Admin\\.ThreadPool\\.ThreadPriority/\", false, null),\n    new Property(\"/^Ice\\.Admin\\.MessageSizeMax/\", false, null),\n    new Property(\"/^Ice\\.Admin\\.DelayCreation/\", false, null),\n    new Property(\"/^Ice\\.Admin\\.Enabled/\", false, null),\n    new Property(\"/^Ice\\.Admin\\.Facets/\", false, null),\n    new Property(\"/^Ice\\.Admin\\.InstanceName/\", false, null),\n    new Property(\"/^Ice\\.Admin\\.Logger\\.KeepLogs/\", false, null),\n    new Property(\"/^Ice\\.Admin\\.Logger\\.KeepTraces/\", false, null),\n    new Property(\"/^Ice\\.Admin\\.Logger\\.Properties/\", false, null),\n    new Property(\"/^Ice\\.Admin\\.ServerId/\", false, null),\n    new Property(\"/^Ice\\.BackgroundLocatorCacheUpdates/\", false, null),\n    new Property(\"/^Ice\\.BatchAutoFlush/\", true, null),\n    new Property(\"/^Ice\\.BatchAutoFlushSize/\", false, null),\n    new Property(\"/^Ice\\.ChangeUser/\", false, null),\n    new Property(\"/^Ice\\.ClassGraphDepthMax/\", false, null),\n    new Property(\"/^Ice\\.ClientAccessPolicyProtocol/\", false, null),\n    new Property(\"/^Ice\\.Compression\\.Level/\", false, null),\n    new Property(\"/^Ice\\.CollectObjects/\", false, null),\n    new Property(\"/^Ice\\.Config/\", false, null),\n    new Property(\"/^Ice\\.ConsoleListener/\", false, null),\n    new Property(\"/^Ice\\.Default\\.CollocationOptimized/\", false, null),\n    new Property(\"/^Ice\\.Default\\.EncodingVersion/\", false, null),\n    new Property(\"/^Ice\\.Default\\.EndpointSelection/\", false, null),\n    new Property(\"/^Ice\\.Default\\.Host/\", false, null),\n    new Property(\"/^Ice\\.Default\\.Locator\\.EndpointSelection/\", false, null),\n    new Property(\"/^Ice\\.Default\\.Locator\\.ConnectionCached/\", false, null),\n    new Property(\"/^Ice\\.Default\\.Locator\\.PreferSecure/\", false, null),\n    new Property(\"/^Ice\\.Default\\.Locator\\.LocatorCacheTimeout/\", false, null),\n    new Property(\"/^Ice\\.Default\\.Locator\\.InvocationTimeout/\", false, null),\n    new Property(\"/^Ice\\.Default\\.Locator\\.Locator/\", false, null),\n    new Property(\"/^Ice\\.Default\\.Locator\\.Router/\", false, null),\n    new Property(\"/^Ice\\.Default\\.Locator\\.CollocationOptimized/\", false, null),\n    new Property(\"/^Ice\\.Default\\.Locator\\.Context\\../\", false, null),\n    new Property(\"/^Ice\\.Default\\.Locator/\", false, null),\n    new Property(\"/^Ice\\.Default\\.LocatorCacheTimeout/\", false, null),\n    new Property(\"/^Ice\\.Default\\.InvocationTimeout/\", false, null),\n    new Property(\"/^Ice\\.Default\\.Package/\", false, null),\n    new Property(\"/^Ice\\.Default\\.PreferSecure/\", false, null),\n    new Property(\"/^Ice\\.Default\\.Protocol/\", false, null),\n    new Property(\"/^Ice\\.Default\\.Router\\.EndpointSelection/\", false, null),\n    new Property(\"/^Ice\\.Default\\.Router\\.ConnectionCached/\", false, null),\n    new Property(\"/^Ice\\.Default\\.Router\\.PreferSecure/\", false, null),\n    new Property(\"/^Ice\\.Default\\.Router\\.LocatorCacheTimeout/\", false, null),\n    new Property(\"/^Ice\\.Default\\.Router\\.InvocationTimeout/\", false, null),\n    new Property(\"/^Ice\\.Default\\.Router\\.Locator/\", false, null),\n    new Property(\"/^Ice\\.Default\\.Router\\.Router/\", false, null),\n    new Property(\"/^Ice\\.Default\\.Router\\.CollocationOptimized/\", false, null),\n    new Property(\"/^Ice\\.Default\\.Router\\.Context\\../\", false, null),\n    new Property(\"/^Ice\\.Default\\.Router/\", false, null),\n    new Property(\"/^Ice\\.Default\\.SlicedFormat/\", false, null),\n    new Property(\"/^Ice\\.Default\\.SourceAddress/\", false, null),\n    new Property(\"/^Ice\\.Default\\.Timeout/\", false, null),\n    new Property(\"/^Ice\\.EventLog\\.Source/\", false, null),\n    new Property(\"/^Ice\\.FactoryAssemblies/\", false, null),\n    new Property(\"/^Ice\\.HTTPProxyHost/\", false, null),\n    new Property(\"/^Ice\\.HTTPProxyPort/\", false, null),\n    new Property(\"/^Ice\\.ImplicitContext/\", false, null),\n    new Property(\"/^Ice\\.InitPlugins/\", false, null),\n    new Property(\"/^Ice\\.IPv4/\", false, null),\n    new Property(\"/^Ice\\.IPv6/\", false, null),\n    new Property(\"/^Ice\\.LogFile/\", false, null),\n    new Property(\"/^Ice\\.LogFile\\.SizeMax/\", false, null),\n    new Property(\"/^Ice\\.LogStdErr\\.Convert/\", false, null),\n    new Property(\"/^Ice\\.MessageSizeMax/\", false, null),\n    new Property(\"/^Ice\\.Nohup/\", false, null),\n    new Property(\"/^Ice\\.NullHandleAbort/\", false, null),\n    new Property(\"/^Ice\\.Override\\.CloseTimeout/\", false, null),\n    new Property(\"/^Ice\\.Override\\.Compress/\", false, null),\n    new Property(\"/^Ice\\.Override\\.ConnectTimeout/\", false, null),\n    new Property(\"/^Ice\\.Override\\.Timeout/\", false, null),\n    new Property(\"/^Ice\\.Override\\.Secure/\", false, null),\n    new Property(\"/^Ice\\.Package\\../\", false, null),\n    new Property(\"/^Ice\\.Plugin\\../\", false, null),\n    new Property(\"/^Ice\\.PluginLoadOrder/\", false, null),\n    new Property(\"/^Ice\\.PreferIPv6Address/\", false, null),\n    new Property(\"/^Ice\\.PreloadAssemblies/\", false, null),\n    new Property(\"/^Ice\\.PrintAdapterReady/\", false, null),\n    new Property(\"/^Ice\\.PrintProcessId/\", false, null),\n    new Property(\"/^Ice\\.PrintStackTraces/\", false, null),\n    new Property(\"/^Ice\\.ProgramName/\", false, null),\n    new Property(\"/^Ice\\.RetryIntervals/\", false, null),\n    new Property(\"/^Ice\\.ServerIdleTime/\", false, null),\n    new Property(\"/^Ice\\.SOCKSProxyHost/\", false, null),\n    new Property(\"/^Ice\\.SOCKSProxyPort/\", false, null),\n    new Property(\"/^Ice\\.StdErr/\", false, null),\n    new Property(\"/^Ice\\.StdOut/\", false, null),\n    new Property(\"/^Ice\\.SyslogFacility/\", false, null),\n    new Property(\"/^Ice\\.ThreadPool\\.Client\\.Size/\", false, null),\n    new Property(\"/^Ice\\.ThreadPool\\.Client\\.SizeMax/\", false, null),\n    new Property(\"/^Ice\\.ThreadPool\\.Client\\.SizeWarn/\", false, null),\n    new Property(\"/^Ice\\.ThreadPool\\.Client\\.StackSize/\", false, null),\n    new Property(\"/^Ice\\.ThreadPool\\.Client\\.Serialize/\", false, null),\n    new Property(\"/^Ice\\.ThreadPool\\.Client\\.ThreadIdleTime/\", false, null),\n    new Property(\"/^Ice\\.ThreadPool\\.Client\\.ThreadPriority/\", false, null),\n    new Property(\"/^Ice\\.ThreadPool\\.Server\\.Size/\", false, null),\n    new Property(\"/^Ice\\.ThreadPool\\.Server\\.SizeMax/\", false, null),\n    new Property(\"/^Ice\\.ThreadPool\\.Server\\.SizeWarn/\", false, null),\n    new Property(\"/^Ice\\.ThreadPool\\.Server\\.StackSize/\", false, null),\n    new Property(\"/^Ice\\.ThreadPool\\.Server\\.Serialize/\", false, null),\n    new Property(\"/^Ice\\.ThreadPool\\.Server\\.ThreadIdleTime/\", false, null),\n    new Property(\"/^Ice\\.ThreadPool\\.Server\\.ThreadPriority/\", false, null),\n    new Property(\"/^Ice\\.ThreadPriority/\", false, null),\n    new Property(\"/^Ice\\.ToStringMode/\", false, null),\n    new Property(\"/^Ice\\.Trace\\.Admin\\.Properties/\", false, null),\n    new Property(\"/^Ice\\.Trace\\.Admin\\.Logger/\", false, null),\n    new Property(\"/^Ice\\.Trace\\.Locator/\", false, null),\n    new Property(\"/^Ice\\.Trace\\.Network/\", false, null),\n    new Property(\"/^Ice\\.Trace\\.Protocol/\", false, null),\n    new Property(\"/^Ice\\.Trace\\.Retry/\", false, null),\n    new Property(\"/^Ice\\.Trace\\.Slicing/\", false, null),\n    new Property(\"/^Ice\\.Trace\\.ThreadPool/\", false, null),\n    new Property(\"/^Ice\\.UDP\\.RcvSize/\", false, null),\n    new Property(\"/^Ice\\.UDP\\.SndSize/\", false, null),\n    new Property(\"/^Ice\\.TCP\\.Backlog/\", false, null),\n    new Property(\"/^Ice\\.TCP\\.RcvSize/\", false, null),\n    new Property(\"/^Ice\\.TCP\\.SndSize/\", false, null),\n    new Property(\"/^Ice\\.UseApplicationClassLoader/\", false, null),\n    new Property(\"/^Ice\\.UseOSLog/\", false, null),\n    new Property(\"/^Ice\\.UseSyslog/\", false, null),\n    new Property(\"/^Ice\\.UseSystemdJournal/\", false, null),\n    new Property(\"/^Ice\\.Warn\\.AMICallback/\", false, null),\n    new Property(\"/^Ice\\.Warn\\.Connections/\", false, null),\n    new Property(\"/^Ice\\.Warn\\.Datagrams/\", false, null),\n    new Property(\"/^Ice\\.Warn\\.Dispatch/\", false, null),\n    new Property(\"/^Ice\\.Warn\\.Endpoints/\", false, null),\n    new Property(\"/^Ice\\.Warn\\.UnknownProperties/\", false, null),\n    new Property(\"/^Ice\\.Warn\\.UnusedProperties/\", false, null),\n    new Property(\"/^Ice\\.CacheMessageBuffers/\", false, null),\n    new Property(\"/^Ice\\.ThreadInterruptSafe/\", false, null),\n];\n\nPropertyNames.validProps =\n[\n    PropertyNames.IceProps,\n];\n\nPropertyNames.clPropNames =\n[\n    \"Ice\",\n];\n\nIce.PropertyNames = PropertyNames;\nmodule.exports.Ice = Ice;\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/PropertyNames.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/Protocol.js":
/*!**********************************************!*\
  !*** ./node_modules/ice/src/Ice/Protocol.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nconst Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n\n__webpack_require__(/*! ../Ice/Buffer */ \"./node_modules/ice/src/Ice/Buffer.js\");\n__webpack_require__(/*! ../Ice/LocalException */ \"./node_modules/ice/src/Ice/LocalException.js\");\n__webpack_require__(/*! ../Ice/StringUtil */ \"./node_modules/ice/src/Ice/StringUtil.js\");\n__webpack_require__(/*! ../Ice/Version */ \"./node_modules/ice/src/Ice/Version.js\");\n\nconst StringUtil = Ice.StringUtil;\n\nconst Protocol = {};\n\nIce.Encoding_1_0 = new Ice.EncodingVersion(1, 0);\nIce.Encoding_1_1 = new Ice.EncodingVersion(1, 1);\n\nIce.Protocol_1_0 = new Ice.ProtocolVersion(1, 0);\n\n//\n// Size of the Ice protocol header\n//\n// Magic number (4 bytes)\n// Protocol version major (Byte)\n// Protocol version minor (Byte)\n// Encoding version major (Byte)\n// Encoding version minor (Byte)\n// Message type (Byte)\n// Compression status (Byte)\n// Message size (Int)\n//\nProtocol.headerSize = 14;\n\n//\n// The magic number at the front of each message ['I', 'c', 'e', 'P']\n//\nProtocol.magic = new Uint8Array([0x49, 0x63, 0x65, 0x50]);\n\n//\n// The current Ice protocol and encoding version\n//\nProtocol.protocolMajor = 1;\nProtocol.protocolMinor = 0;\nProtocol.protocolEncodingMajor = 1;\nProtocol.protocolEncodingMinor = 0;\n\nProtocol.encodingMajor = 1;\nProtocol.encodingMinor = 1;\n\n//\n// The Ice protocol message types\n//\nProtocol.requestMsg = 0;\nProtocol.requestBatchMsg = 1;\nProtocol.replyMsg = 2;\nProtocol.validateConnectionMsg = 3;\nProtocol.closeConnectionMsg = 4;\n\n//\n// Reply status\n//\nProtocol.replyOK = 0;\nProtocol.replyUserException = 1;\nProtocol.replyObjectNotExist = 2;\nProtocol.replyFacetNotExist = 3;\nProtocol.replyOperationNotExist = 4;\nProtocol.replyUnknownLocalException = 5;\nProtocol.replyUnknownUserException = 6;\nProtocol.replyUnknownException = 7;\n\nProtocol.requestHdr = new Uint8Array([\n    Protocol.magic[0],\n    Protocol.magic[1],\n    Protocol.magic[2],\n    Protocol.magic[3],\n    Protocol.protocolMajor,\n    Protocol.protocolMinor,\n    Protocol.protocolEncodingMajor,\n    Protocol.protocolEncodingMinor,\n    Protocol.requestMsg,\n    0, // Compression status.\n    0, 0, 0, 0, // Message size (placeholder).\n    0, 0, 0, 0 // Request ID (placeholder).\n]);\n\nProtocol.requestBatchHdr = new Uint8Array([\n    Protocol.magic[0],\n    Protocol.magic[1],\n    Protocol.magic[2],\n    Protocol.magic[3],\n    Protocol.protocolMajor,\n    Protocol.protocolMinor,\n    Protocol.protocolEncodingMajor,\n    Protocol.protocolEncodingMinor,\n    Protocol.requestBatchMsg,\n    0, // Compression status.\n    0, 0, 0, 0, // Message size (placeholder).\n    0, 0, 0, 0 // Number of requests in batch (placeholder).\n]);\n\nProtocol.replyHdr = new Uint8Array([\n    Protocol.magic[0],\n    Protocol.magic[1],\n    Protocol.magic[2],\n    Protocol.magic[3],\n    Protocol.protocolMajor,\n    Protocol.protocolMinor,\n    Protocol.protocolEncodingMajor,\n    Protocol.protocolEncodingMinor,\n    Protocol.replyMsg,\n    0, // Compression status.\n    0, 0, 0, 0 // Message size (placeholder).\n]);\n\nProtocol.currentProtocol = new Ice.ProtocolVersion(Protocol.protocolMajor, Protocol.protocolMinor);\nProtocol.currentProtocolEncoding = new Ice.EncodingVersion(Protocol.protocolEncodingMajor,\n                                                            Protocol.protocolEncodingMinor);\n\nProtocol.currentEncoding = new Ice.EncodingVersion(Protocol.encodingMajor, Protocol.encodingMinor);\n\nProtocol.checkSupportedProtocol = function(v)\n{\n    if(v.major !== Protocol.currentProtocol.major || v.minor > Protocol.currentProtocol.minor)\n    {\n        throw new Ice.UnsupportedProtocolException(\"\", v, Protocol.currentProtocol);\n    }\n};\n\nProtocol.checkSupportedProtocolEncoding = function(v)\n{\n    if(v.major !== Protocol.currentProtocolEncoding.major ||\n    v.minor > Protocol.currentProtocolEncoding.minor)\n    {\n        throw new Ice.UnsupportedEncodingException(\"\", v, Protocol.currentProtocolEncoding);\n    }\n};\n\nProtocol.checkSupportedEncoding = function(v)\n{\n    if(v.major !== Protocol.currentEncoding.major || v.minor > Protocol.currentEncoding.minor)\n    {\n        throw new Ice.UnsupportedEncodingException(\"\", v, Protocol.currentEncoding);\n    }\n};\n\n//\n// Either return the given protocol if not compatible, or the greatest\n// supported protocol otherwise.\n//\nProtocol.getCompatibleProtocol = function(v)\n{\n    if(v.major !== Protocol.currentProtocol.major)\n    {\n        return v; // Unsupported protocol, return as is.\n    }\n    else if(v.minor < Protocol.currentProtocol.minor)\n    {\n        return v; // Supported protocol.\n    }\n    else\n    {\n        //\n        // Unsupported but compatible, use the currently supported\n        // protocol, that's the best we can do.\n        //\n        return Protocol.currentProtocol;\n    }\n};\n\n//\n// Either return the given encoding if not compatible, or the greatest\n// supported encoding otherwise.\n//\nProtocol.getCompatibleEncoding = function(v)\n{\n    if(v.major !== Protocol.currentEncoding.major)\n    {\n        return v; // Unsupported encoding, return as is.\n    }\n    else if(v.minor < Protocol.currentEncoding.minor)\n    {\n        return v; // Supported encoding.\n    }\n    else\n    {\n        //\n        // Unsupported but compatible, use the currently supported\n        // encoding, that's the best we can do.\n        //\n        return Protocol.currentEncoding;\n    }\n};\n\nProtocol.isSupported = function(version, supported)\n{\n    return version.major === supported.major && version.minor <= supported.minor;\n};\n\n/**\n* Converts a string to a protocol version.\n*\n* @param version The string to convert.\n*\n* @return The converted protocol version.\n**/\nIce.stringToProtocolVersion = function(version)\n{\n    return new Ice.ProtocolVersion(stringToMajor(version), stringToMinor(version));\n};\n\n/**\n* Converts a string to an encoding version.\n*\n* @param version The string to convert.\n*\n* @return The converted object identity.\n**/\nIce.stringToEncodingVersion = function(version)\n{\n    return new Ice.EncodingVersion(stringToMajor(version), stringToMinor(version));\n};\n\n/**\n* Converts a protocol version to a string.\n*\n* @param v The protocol version to convert.\n*\n* @return The converted string.\n**/\nIce.protocolVersionToString = function(v)\n{\n    return majorMinorToString(v.major, v.minor);\n};\n\n/**\n * Converts an encoding version to a string.\n *\n * @param v The encoding version to convert.\n *\n * @return The converted string.\n **/\nIce.encodingVersionToString = function(v)\n{\n    return majorMinorToString(v.major, v.minor);\n};\n\nProtocol.OPTIONAL_END_MARKER = 0xFF;\nProtocol.FLAG_HAS_TYPE_ID_STRING = (1 << 0);\nProtocol.FLAG_HAS_TYPE_ID_INDEX = (1 << 1);\nProtocol.FLAG_HAS_TYPE_ID_COMPACT = (1 << 1 | 1 << 0);\nProtocol.FLAG_HAS_OPTIONAL_MEMBERS = (1 << 2);\nProtocol.FLAG_HAS_INDIRECTION_TABLE = (1 << 3);\nProtocol.FLAG_HAS_SLICE_SIZE = (1 << 4);\nProtocol.FLAG_IS_LAST_SLICE = (1 << 5);\n\nIce.Protocol = Protocol;\nmodule.exports.Ice = Ice;\n\nfunction stringToMajor(str)\n{\n    const pos = str.indexOf('.');\n    if(pos === -1)\n    {\n        throw new Ice.VersionParseException(\"malformed version value `\" + str + \"'\");\n    }\n\n    try\n    {\n        const majVersion = StringUtil.toInt(str.substring(0, pos));\n        if(majVersion < 1 || majVersion > 255)\n        {\n            throw new Ice.VersionParseException(\"range error in version `\" + str + \"'\");\n        }\n        return majVersion;\n    }\n    catch(ex)\n    {\n        throw new Ice.VersionParseException(\"invalid version value `\" + str + \"'\");\n    }\n}\n\nfunction stringToMinor(str)\n{\n    const pos = str.indexOf('.');\n    if(pos === -1)\n    {\n        throw new Ice.VersionParseException(\"malformed version value `\" + str + \"'\");\n    }\n\n    try\n    {\n        const minVersion = StringUtil.toInt(str.substring(pos + 1));\n        if(minVersion < 0 || minVersion > 255)\n        {\n            throw new Ice.VersionParseException(\"range error in version `\" + str + \"'\");\n        }\n        return minVersion;\n    }\n    catch(ex)\n    {\n        throw new Ice.VersionParseException(\"invalid version value `\" + str + \"'\");\n    }\n}\n\nfunction majorMinorToString(major, minor)\n{\n    return major + \".\" + minor;\n}\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/Protocol.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/ProtocolInstance.js":
/*!******************************************************!*\
  !*** ./node_modules/ice/src/Ice/ProtocolInstance.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nconst Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n\nclass ProtocolInstance\n{\n    constructor(instance, type, protocol, secure)\n    {\n        this._instance = instance;\n        this._traceLevel = instance.traceLevels().network;\n        this._traceCategory = instance.traceLevels().networkCat;\n        this._logger = instance.initializationData().logger;\n        this._properties = instance.initializationData().properties;\n        this._type = type;\n        this._protocol = protocol;\n        this._secure = secure;\n    }\n\n    traceLevel()\n    {\n        return this._traceLevel;\n    }\n\n    traceCategory()\n    {\n        return this._traceCategory;\n    }\n\n    logger()\n    {\n        return this._logger;\n    }\n\n    protocol()\n    {\n        return this._protocol;\n    }\n\n    type()\n    {\n        return this._type;\n    }\n\n    secure()\n    {\n        return this._secure;\n    }\n\n    properties()\n    {\n        return this._properties;\n    }\n\n    defaultHost()\n    {\n        return this._instance.defaultsAndOverrides().defaultHost;\n    }\n\n    defaultSourceAddress()\n    {\n        return this._instance.defaultsAndOverrides().defaultSourceAddress;\n    }\n\n    defaultEncoding()\n    {\n        return this._instance.defaultsAndOverrides().defaultEncoding;\n    }\n\n    defaultTimeout()\n    {\n        return this._instance.defaultsAndOverrides().defaultTimeout;\n    }\n\n    messageSizeMax()\n    {\n        return this._instance.messageSizeMax();\n    }\n}\n\nIce.ProtocolInstance = ProtocolInstance;\nmodule.exports.Ice = Ice;\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/ProtocolInstance.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/ProxyFactory.js":
/*!**************************************************!*\
  !*** ./node_modules/ice/src/Ice/ProxyFactory.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nconst Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n\n__webpack_require__(/*! ../Ice/Debug */ \"./node_modules/ice/src/Ice/Debug.js\");\n__webpack_require__(/*! ../Ice/Identity */ \"./node_modules/ice/src/Ice/Identity.js\");\n__webpack_require__(/*! ../Ice/LocalException */ \"./node_modules/ice/src/Ice/LocalException.js\");\n__webpack_require__(/*! ../Ice/ObjectPrx */ \"./node_modules/ice/src/Ice/ObjectPrx.js\");\n__webpack_require__(/*! ../Ice/Reference */ \"./node_modules/ice/src/Ice/Reference.js\");\n__webpack_require__(/*! ../Ice/StringUtil */ \"./node_modules/ice/src/Ice/StringUtil.js\");\n\nconst Debug = Ice.Debug;\nconst Identity = Ice.Identity;\nconst ObjectPrx = Ice.ObjectPrx;\nconst StringUtil = Ice.StringUtil;\n\n//\n// Only for use by Instance.\n//\nclass ProxyFactory\n{\n    constructor(instance)\n    {\n        this._instance = instance;\n\n        const arr = this._instance.initializationData().properties.getPropertyAsList(\"Ice.RetryIntervals\");\n\n        if(arr.length > 0)\n        {\n            this._retryIntervals = [];\n\n            for(let i = 0; i < arr.length; i++)\n            {\n                let v;\n\n                try\n                {\n                    v = StringUtil.toInt(arr[i]);\n                }\n                catch(ex)\n                {\n                    v = 0;\n                }\n\n                //\n                // If -1 is the first value, no retry and wait intervals.\n                //\n                if(i === 0 && v === -1)\n                {\n                    break;\n                }\n\n                this._retryIntervals[i] = v > 0 ? v : 0;\n            }\n        }\n        else\n        {\n            this._retryIntervals = [0];\n        }\n    }\n\n    stringToProxy(str)\n    {\n        return this.referenceToProxy(this._instance.referenceFactory().createFromString(str, null));\n    }\n\n    proxyToString(proxy)\n    {\n        return proxy === null ? \"\" : proxy._getReference().toString();\n    }\n\n    propertyToProxy(prefix)\n    {\n        const proxy = this._instance.initializationData().properties.getProperty(prefix);\n        const ref = this._instance.referenceFactory().createFromString(proxy, prefix);\n        return this.referenceToProxy(ref);\n    }\n\n    proxyToProperty(proxy, prefix)\n    {\n        return proxy === null ? new Map() : proxy._getReference().toProperty(prefix);\n    }\n\n    streamToProxy(s, type)\n    {\n        const ident = new Identity();\n        ident._read(s);\n        return this.referenceToProxy(this._instance.referenceFactory().createFromStream(ident, s), type);\n    }\n\n    referenceToProxy(ref, type)\n    {\n        if(ref !== null)\n        {\n            const proxy = type ? new type() : new ObjectPrx();\n            proxy._setup(ref);\n            return proxy;\n        }\n        else\n        {\n            return null;\n        }\n    }\n\n    checkRetryAfterException(ex, ref, sleepInterval, cnt)\n    {\n        const traceLevels = this._instance.traceLevels();\n        const logger = this._instance.initializationData().logger;\n\n        //\n        // We don't retry batch requests because the exception might have caused\n        // the all the requests batched with the connection to be aborted and we\n        // want the application to be notified.\n        //\n        if(ref.getMode() === Ice.Reference.ModeBatchOneway || ref.getMode() === Ice.Reference.ModeBatchDatagram)\n        {\n            throw ex;\n        }\n\n        //\n        // If it's a fixed proxy, retrying isn't useful as the proxy is tied to\n        // the connection and the request will fail with the exception.\n        //\n        if(ref instanceof Ice.FixedReference)\n        {\n            throw ex;\n        }\n\n        if(ex instanceof Ice.ObjectNotExistException)\n        {\n            if(ref.getRouterInfo() !== null && ex.operation === \"ice_add_proxy\")\n            {\n                //\n                // If we have a router, an ObjectNotExistException with an\n                // operation name \"ice_add_proxy\" indicates to the client\n                // that the router isn't aware of the proxy (for example,\n                // because it was evicted by the router). In this case, we\n                // must *always* retry, so that the missing proxy is added\n                // to the router.\n                //\n\n                ref.getRouterInfo().clearCache(ref);\n\n                if(traceLevels.retry >= 1)\n                {\n                    logger.trace(traceLevels.retryCat, \"retrying operation call to add proxy to router\\n\" +\n                                 ex.toString());\n                }\n\n                if(sleepInterval !== null)\n                {\n                    sleepInterval.value = 0;\n                }\n                return cnt; // We must always retry, so we don't look at the retry count.\n            }\n            else if(ref.isIndirect())\n            {\n                //\n                // We retry ObjectNotExistException if the reference is\n                // indirect.\n                //\n\n                if(ref.isWellKnown())\n                {\n                    const li = ref.getLocatorInfo();\n                    if(li !== null)\n                    {\n                        li.clearCache(ref);\n                    }\n                }\n            }\n            else\n            {\n                //\n                // For all other cases, we don't retry ObjectNotExistException.\n                //\n                throw ex;\n            }\n        }\n        else if(ex instanceof Ice.RequestFailedException)\n        {\n            //\n            // For all other cases, we don't retry ObjectNotExistException\n            //\n            throw ex;\n        }\n\n        //\n        // There is no point in retrying an operation that resulted in a\n        // MarshalException. This must have been raised locally (because\n        // if it happened in a server it would result in an\n        // UnknownLocalException instead), which means there was a problem\n        // in this process that will not change if we try again.\n        //\n        // The most likely cause for a MarshalException is exceeding the\n        // maximum message size, which is represented by the the subclass\n        // MemoryLimitException. For example, a client can attempt to send\n        // a message that exceeds the maximum memory size, or accumulate\n        // enough batch requests without flushing that the maximum size is\n        // reached.\n        //\n        // This latter case is especially problematic, because if we were\n        // to retry a batch request after a MarshalException, we would in\n        // fact silently discard the accumulated requests and allow new\n        // batch requests to accumulate. If the subsequent batched\n        // requests do not exceed the maximum message size, it appears to\n        // the client that all of the batched requests were accepted, when\n        // in reality only the last few are actually sent.\n        //\n        if(ex instanceof Ice.MarshalException)\n        {\n            throw ex;\n        }\n\n        //\n        // Don't retry if the communicator is destroyed, object adapter is deactivated,\n        // or connection is manually closed.\n        //\n        if(ex instanceof Ice.CommunicatorDestroyedException ||\n           ex instanceof Ice.ObjectAdapterDeactivatedException ||\n           ex instanceof Ice.ConnectionManuallyClosedException)\n        {\n            throw ex;\n        }\n\n        //\n        // Don't retry invocation timeouts.\n        //\n        if(ex instanceof Ice.InvocationTimeoutException || ex instanceof Ice.InvocationCanceledException)\n        {\n            throw ex;\n        }\n\n        ++cnt;\n        Debug.assert(cnt > 0);\n\n        let interval;\n        if(cnt === (this._retryIntervals.length + 1) && ex instanceof Ice.CloseConnectionException)\n        {\n            //\n            // A close connection exception is always retried at least once, even if the retry\n            // limit is reached.\n            //\n            interval = 0;\n        }\n        else if(cnt > this._retryIntervals.length)\n        {\n            if(traceLevels.retry >= 1)\n            {\n                logger.trace(traceLevels.retryCat,\n                             \"cannot retry operation call because retry limit has been exceeded\\n\" + ex.toString());\n            }\n            throw ex;\n        }\n        else\n        {\n            interval = this._retryIntervals[cnt - 1];\n        }\n\n        if(traceLevels.retry >= 1)\n        {\n            let msg = \"retrying operation call\";\n            if(interval > 0)\n            {\n                msg += \" in \" + interval + \"ms\";\n            }\n            msg += \" because of exception\\n\" + ex.toString();\n            logger.trace(traceLevels.retryCat, msg);\n        }\n\n        Debug.assert(sleepInterval !== null);\n        sleepInterval.value = interval;\n\n        return cnt;\n    }\n}\n\nIce.ProxyFactory = ProxyFactory;\nmodule.exports.Ice = Ice;\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/ProxyFactory.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/Reference.js":
/*!***********************************************!*\
  !*** ./node_modules/ice/src/Ice/Reference.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nconst Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/BatchRequestQueue */ \"./node_modules/ice/src/Ice/BatchRequestQueue.js\");\n__webpack_require__(/*! ../Ice/BuiltinSequences */ \"./node_modules/ice/src/Ice/BuiltinSequences.js\");\n__webpack_require__(/*! ../Ice/ConnectionRequestHandler */ \"./node_modules/ice/src/Ice/ConnectionRequestHandler.js\");\n__webpack_require__(/*! ../Ice/Debug */ \"./node_modules/ice/src/Ice/Debug.js\");\n__webpack_require__(/*! ../Ice/EndpointTypes */ \"./node_modules/ice/src/Ice/EndpointTypes.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/Identity */ \"./node_modules/ice/src/Ice/Identity.js\");\n__webpack_require__(/*! ../Ice/LocalException */ \"./node_modules/ice/src/Ice/LocalException.js\");\n__webpack_require__(/*! ../Ice/Locator */ \"./node_modules/ice/src/Ice/Locator.js\");\n__webpack_require__(/*! ../Ice/MapUtil */ \"./node_modules/ice/src/Ice/MapUtil.js\");\n__webpack_require__(/*! ../Ice/OpaqueEndpointI */ \"./node_modules/ice/src/Ice/OpaqueEndpointI.js\");\n__webpack_require__(/*! ../Ice/Promise */ \"./node_modules/ice/src/Ice/Promise.js\");\n__webpack_require__(/*! ../Ice/PropertyNames */ \"./node_modules/ice/src/Ice/PropertyNames.js\");\n__webpack_require__(/*! ../Ice/ReferenceMode */ \"./node_modules/ice/src/Ice/ReferenceMode.js\");\n__webpack_require__(/*! ../Ice/Router */ \"./node_modules/ice/src/Ice/Router.js\");\n__webpack_require__(/*! ../Ice/StringUtil */ \"./node_modules/ice/src/Ice/StringUtil.js\");\n__webpack_require__(/*! ../Ice/Version */ \"./node_modules/ice/src/Ice/Version.js\");\n\nconst ArrayUtil = Ice.ArrayUtil;\nconst BatchRequestQueue = Ice.BatchRequestQueue;\nconst ConnectionRequestHandler = Ice.ConnectionRequestHandler;\nconst Debug = Ice.Debug;\nconst EndpointSelectionType = Ice.EndpointSelectionType;\nconst HashUtil = Ice.HashUtil;\nconst Identity = Ice.Identity;\nconst LocatorPrx = Ice.LocatorPrx;\nconst MapUtil = Ice.MapUtil;\nconst OpaqueEndpointI = Ice.OpaqueEndpointI;\nconst PropertyNames = Ice.PropertyNames;\nconst RefMode = Ice.ReferenceMode;\nconst RouterPrx = Ice.RouterPrx;\nconst StringSeqHelper = Ice.StringSeqHelper;\nconst StringUtil = Ice.StringUtil;\n\nconst suffixes =\n[\n    \"EndpointSelection\",\n    \"ConnectionCached\",\n    \"PreferSecure\",\n    \"EncodingVersion\",\n    \"LocatorCacheTimeout\",\n    \"InvocationTimeout\",\n    \"Locator\",\n    \"Router\",\n    \"CollocationOptimized\"\n];\n\n//\n// Only for use by Instance\n//\nclass ReferenceFactory\n{\n    constructor(instance, communicator)\n    {\n        this._instance = instance;\n        this._communicator = communicator;\n        this._defaultRouter = null;\n        this._defaultLocator = null;\n    }\n\n    create(ident, facet, tmpl, endpoints)\n    {\n        if(ident.name.length === 0 && ident.category.length === 0)\n        {\n            return null;\n        }\n\n        return this.createImpl(ident, facet, tmpl.getMode(), tmpl.getSecure(), tmpl.getProtocol(), tmpl.getEncoding(),\n                               endpoints, null, null);\n    }\n\n    createWithAdapterId(ident, facet, tmpl, adapterId)\n    {\n        if(ident.name.length === 0 && ident.category.length === 0)\n        {\n            return null;\n        }\n\n        return this.createImpl(ident, facet, tmpl.getMode(), tmpl.getSecure(), tmpl.getProtocol(), tmpl.getEncoding(),\n                               null, adapterId, null);\n    }\n\n    createFixed(ident, fixedConnection)\n    {\n        if(ident.name.length === 0 && ident.category.length === 0)\n        {\n            return null;\n        }\n\n        //\n        // Create new reference\n        //\n        return new FixedReference(\n            this._instance,\n            this._communicator,\n            ident,\n            \"\", // Facet\n            fixedConnection.endpoint().datagram() ? RefMode.ModeDatagram : RefMode.ModeTwoway,\n            fixedConnection.endpoint().secure(),\n            Ice.Protocol_1_0,\n            this._instance.defaultsAndOverrides().defaultEncoding,\n            fixedConnection,\n            -1,\n            null);\n    }\n\n    copy(r)\n    {\n        const ident = r.getIdentity();\n        if(ident.name.length === 0 && ident.category.length === 0)\n        {\n            return null;\n        }\n        return r.clone();\n    }\n\n    createFromString(s, propertyPrefix)\n    {\n        if(s === undefined || s === null || s.length === 0)\n        {\n            return null;\n        }\n\n        const delim = \" \\t\\n\\r\";\n\n        let end = 0;\n        let beg = StringUtil.findFirstNotOf(s, delim, end);\n        if(beg == -1)\n        {\n            throw new Ice.ProxyParseException(\"no non-whitespace characters found in `\" + s + \"'\");\n        }\n\n        //\n        // Extract the identity, which may be enclosed in single\n        // or double quotation marks.\n        //\n        let idstr = null;\n        end = StringUtil.checkQuote(s, beg);\n        if(end === -1)\n        {\n            throw new Ice.ProxyParseException(\"mismatched quotes around identity in `\" + s + \"'\");\n        }\n        else if(end === 0)\n        {\n            end = StringUtil.findFirstOf(s, delim + \":@\", beg);\n            if(end === -1)\n            {\n                end = s.length;\n            }\n            idstr = s.substring(beg, end);\n        }\n        else\n        {\n            beg++; // Skip leading quote\n            idstr = s.substring(beg, end);\n            end++; // Skip trailing quote\n        }\n\n        if(beg === end)\n        {\n            throw new Ice.ProxyParseException(\"no identity in `\" + s + \"'\");\n        }\n\n        //\n        // Parsing the identity may raise IdentityParseException.\n        //\n        const ident = Ice.stringToIdentity(idstr);\n\n        if(ident.name.length === 0)\n        {\n            //\n            // An identity with an empty name and a non-empty\n            // category is illegal.\n            //\n            if(ident.category.length > 0)\n            {\n                throw new Ice.IllegalIdentityException(ident);\n            }\n            //\n            // Treat a stringified proxy containing two double\n            // quotes (\"\") the same as an empty string, i.e.,\n            // a null proxy, but only if nothing follows the\n            // quotes.\n            //\n            else if(StringUtil.findFirstNotOf(s, delim, end) != -1)\n            {\n                throw new Ice.ProxyParseException(\"invalid characters after identity in `\" + s + \"'\");\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        let facet = \"\";\n        let mode = RefMode.ModeTwoway;\n        let secure = false;\n        let encoding = this._instance.defaultsAndOverrides().defaultEncoding;\n        let protocol = Ice.Protocol_1_0;\n        let adapter = \"\";\n\n        while(true)\n        {\n            beg = StringUtil.findFirstNotOf(s, delim, end);\n            if(beg === -1)\n            {\n                break;\n            }\n\n            if(s.charAt(beg) == ':' || s.charAt(beg) == '@')\n            {\n                break;\n            }\n\n            end = StringUtil.findFirstOf(s, delim + \":@\", beg);\n            if(end == -1)\n            {\n                end = s.length;\n            }\n\n            if(beg == end)\n            {\n                break;\n            }\n\n            const option = s.substring(beg, end);\n            if(option.length != 2 || option.charAt(0) != '-')\n            {\n                throw new Ice.ProxyParseException(\"expected a proxy option but found `\" + option + \"' in `\" + s + \"'\");\n            }\n\n            //\n            // Check for the presence of an option argument. The\n            // argument may be enclosed in single or double\n            // quotation marks.\n            //\n            let argument = null;\n            const argumentBeg = StringUtil.findFirstNotOf(s, delim, end);\n            if(argumentBeg != -1)\n            {\n                const ch = s.charAt(argumentBeg);\n                if(ch != \"@\" && ch != \":\" && ch != \"-\")\n                {\n                    beg = argumentBeg;\n                    end = StringUtil.checkQuote(s, beg);\n                    if(end == -1)\n                    {\n                        throw new Ice.ProxyParseException(\"mismatched quotes around value for \" + option +\n                                                          \" option in `\" + s + \"'\");\n                    }\n                    else if(end === 0)\n                    {\n                        end = StringUtil.findFirstOf(s, delim + \":@\", beg);\n                        if(end === -1)\n                        {\n                            end = s.length;\n                        }\n                        argument = s.substring(beg, end);\n                    }\n                    else\n                    {\n                        beg++; // Skip leading quote\n                        argument = s.substring(beg, end);\n                        end++; // Skip trailing quote\n                    }\n                }\n            }\n\n            //\n            // If any new options are added here,\n            // IceInternal::Reference::toString() and its derived classes must be updated as well.\n            //\n            switch(option.charAt(1))\n            {\n                case 'f':\n                {\n                    if(argument === null)\n                    {\n                        throw new Ice.ProxyParseException(\"no argument provided for -f option in `\" + s + \"'\");\n                    }\n\n                    try\n                    {\n                        facet = StringUtil.unescapeString(argument, 0, argument.length);\n                    }\n                    catch(ex)\n                    {\n                        throw new Ice.ProxyParseException(\"invalid facet in `\" + s + \"': \" + ex.message);\n                    }\n\n                    break;\n                }\n\n                case 't':\n                {\n                    if(argument !== null)\n                    {\n                        throw new Ice.ProxyParseException(\"unexpected argument `\" + argument +\n                                                          \"' provided for -t option in `\" + s + \"'\");\n                    }\n                    mode = RefMode.ModeTwoway;\n                    break;\n                }\n\n                case 'o':\n                {\n                    if(argument !== null)\n                    {\n                        throw new Ice.ProxyParseException(\"unexpected argument `\" + argument +\n                                                          \"' provided for -o option in `\" + s + \"'\");\n                    }\n                    mode = RefMode.ModeOneway;\n                    break;\n                }\n\n                case 'O':\n                {\n                    if(argument !== null)\n                    {\n                        throw new Ice.ProxyParseException(\"unexpected argument `\" + argument +\n                                                          \"' provided for -O option in `\" + s + \"'\");\n                    }\n                    mode = RefMode.ModeBatchOneway;\n                    break;\n                }\n\n                case 'd':\n                {\n                    if(argument !== null)\n                    {\n                        throw new Ice.ProxyParseException(\"unexpected argument `\" + argument +\n                                                          \"' provided for -d option in `\" + s + \"'\");\n                    }\n                    mode = RefMode.ModeDatagram;\n                    break;\n                }\n\n                case 'D':\n                {\n                    if(argument !== null)\n                    {\n                        throw new Ice.ProxyParseException(\"unexpected argument `\" + argument +\n                                                          \"' provided for -D option in `\" + s + \"'\");\n                    }\n                    mode = RefMode.ModeBatchDatagram;\n                    break;\n                }\n\n                case 's':\n                {\n                    if(argument !== null)\n                    {\n                        throw new Ice.ProxyParseException(\"unexpected argument `\" + argument +\n                                                          \"' provided for -s option in `\" + s + \"'\");\n                    }\n                    secure = true;\n                    break;\n                }\n\n                case 'e':\n                {\n                    if(argument === null)\n                    {\n                        throw new Ice.ProxyParseException(\"no argument provided for -e option in `\" + s + \"'\");\n                    }\n\n                    try\n                    {\n                        encoding = Ice.stringToEncodingVersion(argument);\n                    }\n                    catch(e) // VersionParseException\n                    {\n                        throw new Ice.ProxyParseException(\"invalid encoding version `\" + argument + \"' in `\" + s +\n                                                          \"':\\n\" + e.str);\n                    }\n                    break;\n                }\n\n                case 'p':\n                {\n                    if(argument === null)\n                    {\n                        throw new Ice.ProxyParseException(\"no argument provided for -p option in `\" + s + \"'\");\n                    }\n\n                    try\n                    {\n                        protocol = Ice.stringToProtocolVersion(argument);\n                    }\n                    catch(e) // VersionParseException\n                    {\n                        throw new Ice.ProxyParseException(\"invalid protocol version `\" + argument + \"' in `\" + s +\n                                                          \"':\\n\" + e.str);\n                    }\n                    break;\n                }\n\n                default:\n                {\n                    throw new Ice.ProxyParseException(\"unknown option `\" + option + \"' in `\" + s + \"'\");\n                }\n            }\n        }\n\n        if(beg === -1)\n        {\n            return this.createImpl(ident, facet, mode, secure, protocol, encoding, null, null, propertyPrefix);\n        }\n\n        const endpoints = [];\n\n        if(s.charAt(beg) == ':')\n        {\n            const unknownEndpoints = [];\n            end = beg;\n\n            while(end < s.length && s.charAt(end) == ':')\n            {\n                beg = end + 1;\n\n                end = beg;\n                while(true)\n                {\n                    end = s.indexOf(':', end);\n                    if(end == -1)\n                    {\n                        end = s.length;\n                        break;\n                    }\n                    else\n                    {\n                        let quoted = false;\n                        let quote = beg;\n                        while(true)\n                        {\n                            quote = s.indexOf(\"\\\"\", quote);\n                            if(quote == -1 || end < quote)\n                            {\n                                break;\n                            }\n                            else\n                            {\n                                quote = s.indexOf(\"\\\"\", ++quote);\n                                if(quote == -1)\n                                {\n                                    break;\n                                }\n                                else if(end < quote)\n                                {\n                                    quoted = true;\n                                    break;\n                                }\n                                ++quote;\n                            }\n                        }\n                        if(!quoted)\n                        {\n                            break;\n                        }\n                        ++end;\n                    }\n                }\n\n                const es = s.substring(beg, end);\n                const endp = this._instance.endpointFactoryManager().create(es, false);\n                if(endp !== null)\n                {\n                    endpoints.push(endp);\n                }\n                else\n                {\n                    unknownEndpoints.push(es);\n                }\n            }\n            if(endpoints.length === 0)\n            {\n                Debug.assert(unknownEndpoints.length > 0);\n                throw new Ice.EndpointParseException(\"invalid endpoint `\" + unknownEndpoints[0] + \"' in `\" + s + \"'\");\n            }\n            else if(unknownEndpoints.length !== 0 &&\n                    this._instance.initializationData().properties.getPropertyAsIntWithDefault(\"Ice.Warn.Endpoints\", 1) > 0)\n            {\n                const msg = [];\n                msg.push(\"Proxy contains unknown endpoints:\");\n                unknownEndpoints.forEach(unknownEndpoint =>\n                    {\n                        msg.push(\" `\");\n                        msg.push(unknownEndpoint);\n                        msg.push(\"'\");\n                    });\n                this._instance.initializationData().logger.warning(msg.join(\"\"));\n            }\n\n            return this.createImpl(ident, facet, mode, secure, protocol, encoding, endpoints, null, propertyPrefix);\n        }\n        else if(s.charAt(beg) == '@')\n        {\n            beg = StringUtil.findFirstNotOf(s, delim, beg + 1);\n            if(beg == -1)\n            {\n                throw new Ice.ProxyParseException(\"missing adapter id in `\" + s + \"'\");\n            }\n\n            let adapterstr = null;\n            end = StringUtil.checkQuote(s, beg);\n            if(end === -1)\n            {\n                throw new Ice.ProxyParseException(\"mismatched quotes around adapter id in `\" + s + \"'\");\n            }\n            else if(end === 0)\n            {\n                end = StringUtil.findFirstOf(s, delim, beg);\n                if(end === -1)\n                {\n                    end = s.length;\n                }\n                adapterstr = s.substring(beg, end);\n            }\n            else\n            {\n                beg++; // Skip leading quote\n                adapterstr = s.substring(beg, end);\n                end++; // Skip trailing quote\n            }\n\n            if(end !== s.length && StringUtil.findFirstNotOf(s, delim, end) !== -1)\n            {\n                throw new Ice.ProxyParseException(\"invalid trailing characters after `\" + s.substring(0, end + 1) +\n                                                    \"' in `\" + s + \"'\");\n            }\n\n            try\n            {\n                adapter = StringUtil.unescapeString(adapterstr, 0, adapterstr.length);\n            }\n            catch(ex)\n            {\n                throw new Ice.ProxyParseException(\"invalid adapter id in `\" + s + \"': \" + ex.message);\n            }\n            if(adapter.length === 0)\n            {\n                throw new Ice.ProxyParseException(\"empty adapter id in `\" + s + \"'\");\n            }\n            return this.createImpl(ident, facet, mode, secure, protocol, encoding, null, adapter, propertyPrefix);\n        }\n\n        throw new Ice.ProxyParseException(\"malformed proxy `\" + s + \"'\");\n    }\n\n    createFromStream(ident, s)\n    {\n        //\n        // Don't read the identity here. Operations calling this\n        // constructor read the identity, and pass it as a parameter.\n        //\n\n        if(ident.name.length === 0 && ident.category.length === 0)\n        {\n            return null;\n        }\n\n        //\n        // For compatibility with the old FacetPath.\n        //\n        const facetPath = StringSeqHelper.read(s); // String[]\n        let facet;\n        if(facetPath.length > 0)\n        {\n            if(facetPath.length > 1)\n            {\n                throw new Ice.ProxyUnmarshalException();\n            }\n            facet = facetPath[0];\n        }\n        else\n        {\n            facet = \"\";\n        }\n\n        const mode = s.readByte();\n        if(mode < 0 || mode > RefMode.ModeLast)\n        {\n            throw new Ice.ProxyUnmarshalException();\n        }\n\n        const secure = s.readBool();\n\n        let protocol = null;\n        let encoding = null;\n        if(!s.getEncoding().equals(Ice.Encoding_1_0))\n        {\n            protocol = new Ice.ProtocolVersion();\n            protocol._read(s);\n            encoding = new Ice.EncodingVersion();\n            encoding._read(s);\n        }\n        else\n        {\n            protocol = Ice.Protocol_1_0;\n            encoding = Ice.Encoding_1_0;\n        }\n\n        let endpoints = null; // EndpointI[]\n        let adapterId = null;\n\n        const sz = s.readSize();\n        if(sz > 0)\n        {\n            endpoints = [];\n            for(let i = 0; i < sz; i++)\n            {\n                endpoints[i] = this._instance.endpointFactoryManager().read(s);\n            }\n        }\n        else\n        {\n            adapterId = s.readString();\n        }\n\n        return this.createImpl(ident, facet, mode, secure, protocol, encoding, endpoints, adapterId, null);\n    }\n\n    setDefaultRouter(defaultRouter)\n    {\n        if(this._defaultRouter === null ? defaultRouter === null : this._defaultRouter.equals(defaultRouter))\n        {\n            return this;\n        }\n\n        const factory = new ReferenceFactory(this._instance, this._communicator);\n        factory._defaultLocator = this._defaultLocator;\n        factory._defaultRouter = defaultRouter;\n        return factory;\n    }\n\n    getDefaultRouter()\n    {\n        return this._defaultRouter;\n    }\n\n    setDefaultLocator(defaultLocator)\n    {\n        if(this._defaultLocator === null ? defaultLocator === null : this._defaultLocator.equals(defaultLocator))\n        {\n            return this;\n        }\n\n        const factory = new ReferenceFactory(this._instance, this._communicator);\n        factory._defaultRouter = this._defaultRouter;\n        factory._defaultLocator = defaultLocator;\n        return factory;\n    }\n\n    getDefaultLocator()\n    {\n        return this._defaultLocator;\n    }\n\n    checkForUnknownProperties(prefix)\n    {\n        let unknownProps = [];\n        //\n        // Do not warn about unknown properties for Ice prefixes (Ice, Glacier2, etc.)\n        //\n        for(let i = 0; i < PropertyNames.clPropNames.length; ++i)\n        {\n            if(prefix.indexOf(PropertyNames.clPropNames[i] + \".\") === 0)\n            {\n                return;\n            }\n        }\n\n        const properties = this._instance.initializationData().properties.getPropertiesForPrefix(prefix + \".\");\n        unknownProps = unknownProps.concat(Array.from(properties.keys()).filter(\n            key => !suffixes.some(suffix => key === prefix + \".\" + suffix)));\n        if(unknownProps.length > 0)\n        {\n            const message = [];\n            message.push(\"found unknown properties for proxy '\");\n            message.push(prefix);\n            message.push(\"':\");\n            unknownProps.forEach(unknownProp => message.push(\"\\n    \", unknownProp));\n            this._instance.initializationData().logger.warning(message.join(\"\"));\n        }\n    }\n\n    createImpl(ident, facet, mode, secure, protocol, encoding, endpoints, adapterId, propertyPrefix)\n    {\n        const defaultsAndOverrides = this._instance.defaultsAndOverrides();\n\n        //\n        // Default local proxy options.\n        //\n        let locatorInfo = null;\n        if(this._defaultLocator !== null)\n        {\n            if(!this._defaultLocator._getReference().getEncoding().equals(encoding))\n            {\n                locatorInfo = this._instance.locatorManager().find(\n                    this._defaultLocator.ice_encodingVersion(encoding));\n            }\n            else\n            {\n                locatorInfo = this._instance.locatorManager().find(this._defaultLocator);\n            }\n        }\n        let routerInfo = this._instance.routerManager().find(this._defaultRouter);\n        let cacheConnection = true;\n        let preferSecure = defaultsAndOverrides.defaultPreferSecure;\n        let endpointSelection = defaultsAndOverrides.defaultEndpointSelection;\n        let locatorCacheTimeout = defaultsAndOverrides.defaultLocatorCacheTimeout;\n        let invocationTimeout = defaultsAndOverrides.defaultInvocationTimeout;\n\n        //\n        // Override the defaults with the proxy properties if a property prefix is defined.\n        //\n        if(propertyPrefix !== null && propertyPrefix.length > 0)\n        {\n            const properties = this._instance.initializationData().properties;\n\n            //\n            // Warn about unknown properties.\n            //\n            if(properties.getPropertyAsIntWithDefault(\"Ice.Warn.UnknownProperties\", 1) > 0)\n            {\n                this.checkForUnknownProperties(propertyPrefix);\n            }\n\n            let property = propertyPrefix + \".Locator\";\n            const locator = LocatorPrx.uncheckedCast(this._communicator.propertyToProxy(property));\n            if(locator !== null)\n            {\n                if(!locator._getReference().getEncoding().equals(encoding))\n                {\n                    locatorInfo = this._instance.locatorManager().find(locator.ice_encodingVersion(encoding));\n                }\n                else\n                {\n                    locatorInfo = this._instance.locatorManager().find(locator);\n                }\n            }\n\n            property = propertyPrefix + \".Router\";\n            const router = RouterPrx.uncheckedCast(this._communicator.propertyToProxy(property));\n            if(router !== null)\n            {\n                if(propertyPrefix.endsWith(\"Router\"))\n                {\n                    this._instance.initializationData().logger.warning(\n                        \"`\" + property + \"=\" + properties.getProperty(property) +\n                        \"': cannot set a router on a router; setting ignored\");\n                }\n                else\n                {\n                    routerInfo = this._instance.routerManager().find(router);\n                }\n            }\n\n            property = propertyPrefix + \".ConnectionCached\";\n            cacheConnection = properties.getPropertyAsIntWithDefault(property, cacheConnection ? 1 : 0) > 0;\n\n            property = propertyPrefix + \".PreferSecure\";\n            preferSecure = properties.getPropertyAsIntWithDefault(property, preferSecure ? 1 : 0) > 0;\n\n            property = propertyPrefix + \".EndpointSelection\";\n            if(properties.getProperty(property).length > 0)\n            {\n                const type = properties.getProperty(property);\n                if(type == \"Random\")\n                {\n                    endpointSelection = EndpointSelectionType.Random;\n                }\n                else if(type == \"Ordered\")\n                {\n                    endpointSelection = EndpointSelectionType.Ordered;\n                }\n                else\n                {\n                    throw new Ice.EndpointSelectionTypeParseException(\"illegal value `\" + type +\n                                                                      \"'; expected `Random' or `Ordered'\");\n                }\n            }\n\n            property = propertyPrefix + \".LocatorCacheTimeout\";\n            let value = properties.getProperty(property);\n            if(value.length !== 0)\n            {\n                locatorCacheTimeout = properties.getPropertyAsIntWithDefault(property, locatorCacheTimeout);\n                if(locatorCacheTimeout < -1)\n                {\n                    locatorCacheTimeout = -1;\n                    this._instance.initializationData().logger.warning(\n                        \"invalid value for\" + property + \"`\" + properties.getProperty(property) +\n                        \"': defaulting to -1\");\n                }\n            }\n\n            property = propertyPrefix + \".InvocationTimeout\";\n            value = properties.getProperty(property);\n            if(value.length !== 0)\n            {\n                invocationTimeout = properties.getPropertyAsIntWithDefault(property, invocationTimeout);\n                if(invocationTimeout < 1 && invocationTimeout !== -1)\n                {\n                    invocationTimeout = -1;\n                    this._instance.initializationData().logger.warning(\n                        \"invalid value for\" + property + \"`\" + properties.getProperty(property) +\n                        \"': defaulting to -1\");\n                }\n            }\n        }\n\n        //\n        // Create new reference\n        //\n        return new RoutableReference(this._instance,\n                                     this._communicator,\n                                     ident,\n                                     facet,\n                                     mode,\n                                     secure,\n                                     protocol,\n                                     encoding,\n                                     endpoints,\n                                     adapterId,\n                                     locatorInfo,\n                                     routerInfo,\n                                     cacheConnection,\n                                     preferSecure,\n                                     endpointSelection,\n                                     locatorCacheTimeout,\n                                     invocationTimeout);\n    }\n}\n\nIce.ReferenceFactory = ReferenceFactory;\n\nclass Reference\n{\n    constructor(instance, communicator, identity, facet, mode, secure, protocol, encoding, invocationTimeout, context)\n    {\n        //\n        // Validate string arguments.\n        //\n        Debug.assert(identity === undefined || identity.name !== null);\n        Debug.assert(identity === undefined || identity.category !== null);\n        Debug.assert(facet === undefined || facet !== null);\n\n        this._instance = instance;\n        this._communicator = communicator;\n        this._mode = mode;\n        this._secure = secure;\n        this._identity = identity;\n        this._context = context === undefined ? Reference._emptyContext : context;\n        this._facet = facet;\n        this._protocol = protocol;\n        this._encoding = encoding;\n        this._invocationTimeout = invocationTimeout;\n        this._hashInitialized = false;\n    }\n\n    getMode()\n    {\n        return this._mode;\n    }\n\n    getSecure()\n    {\n        return this._secure;\n    }\n\n    getProtocol()\n    {\n        return this._protocol;\n    }\n\n    getEncoding()\n    {\n        return this._encoding;\n    }\n\n    getIdentity()\n    {\n        return this._identity;\n    }\n\n    getFacet()\n    {\n        return this._facet;\n    }\n\n    getInstance()\n    {\n        return this._instance;\n    }\n\n    getContext()\n    {\n        return this._context; // Map\n    }\n\n    getInvocationTimeout()\n    {\n        return this._invocationTimeout;\n    }\n\n    getCommunicator()\n    {\n        return this._communicator;\n    }\n\n    getEndpoints()\n    {\n        // Abstract\n        Debug.assert(false);\n        return null;\n    }\n\n    getAdapterId()\n    {\n        // Abstract\n        Debug.assert(false);\n        return \"\";\n    }\n\n    getRouterInfo()\n    {\n        // Abstract\n        Debug.assert(false);\n        return null;\n    }\n\n    getLocatorInfo()\n    {\n        // Abstract\n        Debug.assert(false);\n        return null;\n    }\n\n    getCacheConnection()\n    {\n        // Abstract\n        Debug.assert(false);\n        return false;\n    }\n\n    getPreferSecure()\n    {\n        // Abstract\n        Debug.assert(false);\n        return false;\n    }\n\n    getEndpointSelection()\n    {\n        // Abstract\n        Debug.assert(false);\n        return null;\n    }\n\n    getLocatorCacheTimeout()\n    {\n        // Abstract\n        Debug.assert(false);\n        return 0;\n    }\n\n    getConnectionId()\n    {\n        // Abstract\n        Debug.assert(false);\n        return \"\";\n    }\n\n    getTimeout()\n    {\n        // Abstract\n        Debug.assert(false);\n        return \"\";\n    }\n\n    //\n    // The change* methods (here and in derived classes) create\n    // a new reference based on the existing one, with the\n    // corresponding value changed.\n    //\n    changeContext(newContext)\n    {\n        if(newContext === undefined || newContext === null)\n        {\n            newContext = Reference._emptyContext;\n        }\n        const r = this._instance.referenceFactory().copy(this);\n        if(newContext.size === 0)\n        {\n            r._context = Reference._emptyContext;\n        }\n        else\n        {\n            r._context = new Map(newContext);\n        }\n        return r;\n    }\n\n    changeMode(newMode)\n    {\n        if(newMode === this._mode)\n        {\n            return this;\n        }\n        const r = this._instance.referenceFactory().copy(this);\n        r._mode = newMode;\n        return r;\n    }\n\n    changeSecure(newSecure)\n    {\n        if(newSecure === this._secure)\n        {\n            return this;\n        }\n        const r = this._instance.referenceFactory().copy(this);\n        r._secure = newSecure;\n        return r;\n    }\n\n    changeIdentity(newIdentity)\n    {\n        if(newIdentity.equals(this._identity))\n        {\n            return this;\n        }\n        const r = this._instance.referenceFactory().copy(this);\n        r._identity = new Identity(newIdentity.name, newIdentity.category);\n        return r;\n    }\n\n    changeFacet(newFacet)\n    {\n        if(newFacet === this._facet)\n        {\n            return this;\n        }\n        const r = this._instance.referenceFactory().copy(this);\n        r._facet = newFacet;\n        return r;\n    }\n\n    changeInvocationTimeout(newInvocationTimeout)\n    {\n        if(newInvocationTimeout === this._invocationTimeout)\n        {\n            return this;\n        }\n        const r = this._instance.referenceFactory().copy(this);\n        r._invocationTimeout = newInvocationTimeout;\n        return r;\n    }\n\n    changeEncoding(newEncoding)\n    {\n        if(newEncoding.equals(this._encoding))\n        {\n            return this;\n        }\n        const r = this._instance.referenceFactory().copy(this);\n        r._encoding = newEncoding;\n        return r;\n    }\n\n    changeAdapterId(newAdapterId)\n    {\n        // Abstract\n        Debug.assert(false);\n        return null;\n    }\n\n    changeEndpoints(newEndpoints)\n    {\n        // Abstract\n        Debug.assert(false);\n        return null;\n    }\n\n    changeLocator(newLocator)\n    {\n        // Abstract\n        Debug.assert(false);\n        return null;\n    }\n\n    changeRouter(newRouter)\n    {\n        // Abstract\n        Debug.assert(false);\n        return null;\n    }\n\n    changeCacheConnection(newCache)\n    {\n        // Abstract\n        Debug.assert(false);\n        return null;\n    }\n\n    changePreferSecure(newPreferSecure)\n    {\n        // Abstract\n        Debug.assert(false);\n        return null;\n    }\n\n    changeEndpointSelection(newType)\n    {\n        // Abstract\n        Debug.assert(false);\n        return null;\n    }\n\n    changeLocatorCacheTimeout(newTimeout)\n    {\n        // Abstract\n        Debug.assert(false);\n        return null;\n    }\n\n    changeTimeout(newTimeout)\n    {\n        // Abstract\n        Debug.assert(false);\n        return null;\n    }\n\n    changeConnectionId(connectionId)\n    {\n        // Abstract\n        Debug.assert(false);\n        return null;\n    }\n\n    changeConnection(connection)\n    {\n        // Abstract\n        Debug.assert(false);\n        return null;\n    }\n\n    hashCode()\n    {\n        if(this._hashInitialized)\n        {\n            return this._hashValue;\n        }\n\n        let h = 5381;\n        h = HashUtil.addNumber(h, this._mode);\n        h = HashUtil.addBoolean(h, this._secure);\n        h = HashUtil.addHashable(h, this._identity);\n        if(this._context !== null && this._context !== undefined)\n        {\n            for(const [key, value] of this._context)\n            {\n                h = HashUtil.addString(h, key);\n                h = HashUtil.addString(h, value);\n            }\n        }\n        h = HashUtil.addString(h, this._facet);\n        h = HashUtil.addHashable(h, this._protocol);\n        h = HashUtil.addHashable(h, this._encoding);\n        h = HashUtil.addNumber(h, this._invocationTimeout);\n\n        this._hashValue = h;\n        this._hashInitialized = true;\n\n        return this._hashValue;\n    }\n\n    //\n    // Utility methods\n    //\n    isIndirect()\n    {\n        // Abstract\n        Debug.assert(false);\n        return false;\n    }\n\n    isWellKnown()\n    {\n        // Abstract\n        Debug.assert(false);\n        return false;\n    }\n\n    //\n    // Marshal the reference.\n    //\n    streamWrite(s)\n    {\n        //\n        // Don't write the identity here. Operations calling streamWrite\n        // write the identity.\n        //\n\n        //\n        // For compatibility with the old FacetPath.\n        //\n        if(this._facet.length === 0)\n        {\n            s.writeSize(0); // Empty string sequence\n        }\n        else\n        {\n            s.writeSize(1); // String sequence with one element\n            s.writeString(this._facet);\n        }\n\n        s.writeByte(this._mode);\n\n        s.writeBool(this._secure);\n\n        if(!s.getEncoding().equals(Ice.Encoding_1_0))\n        {\n            this._protocol._write(s);\n            this._encoding._write(s);\n        }\n\n        // Derived class writes the remainder of the reference.\n    }\n\n    //\n    // Convert the reference to its string form.\n    //\n    toString()\n    {\n        //\n        // WARNING: Certain features, such as proxy validation in Glacier2,\n        // depend on the format of proxy strings. Changes to toString() and\n        // methods called to generate parts of the reference string could break\n        // these features. Please review for all features that depend on the\n        // format of proxyToString() before changing this and related code.\n        //\n        const s = [];\n\n        const toStringMode = this._instance.toStringMode();\n\n        //\n        // If the encoded identity string contains characters which\n        // the reference parser uses as separators, then we enclose\n        // the identity string in quotes.\n        //\n\n        const id = Ice.identityToString(this._identity, toStringMode);\n        if(id.search(/[ :@]/) != -1)\n        {\n            s.push('\"');\n            s.push(id);\n            s.push('\"');\n        }\n        else\n        {\n            s.push(id);\n        }\n\n        if(this._facet.length > 0)\n        {\n            //\n            // If the encoded facet string contains characters which\n            // the reference parser uses as separators, then we enclose\n            // the facet string in quotes.\n            //\n            s.push(\" -f \");\n            const fs = StringUtil.escapeString(this._facet, \"\", toStringMode);\n            if(fs.search(/[ :@]/) != -1)\n            {\n                s.push('\"');\n                s.push(fs);\n                s.push('\"');\n            }\n            else\n            {\n                s.push(fs);\n            }\n        }\n\n        switch(this._mode)\n        {\n            case RefMode.ModeTwoway:\n            {\n                s.push(\" -t\");\n                break;\n            }\n\n            case RefMode.ModeOneway:\n            {\n                s.push(\" -o\");\n                break;\n            }\n\n            case RefMode.ModeBatchOneway:\n            {\n                s.push(\" -O\");\n                break;\n            }\n\n            case RefMode.ModeDatagram:\n            {\n                s.push(\" -d\");\n                break;\n            }\n\n            case RefMode.ModeBatchDatagram:\n            {\n                s.push(\" -D\");\n                break;\n            }\n\n            default:\n            {\n                Debug.assert(false);\n                break;\n            }\n        }\n\n        if(this._secure)\n        {\n            s.push(\" -s\");\n        }\n\n        if(!this._protocol.equals(Ice.Protocol_1_0))\n        {\n            //\n            // We only print the protocol if it's not 1.0. It's fine as\n            // long as we don't add Ice.Default.ProtocolVersion, a\n            // stringified proxy will convert back to the same proxy with\n            // stringToProxy.\n            //\n            s.push(\" -p \");\n            s.push(Ice.protocolVersionToString(this._protocol));\n        }\n\n        //\n        // Always print the encoding version to ensure a stringified proxy\n        // will convert back to a proxy with the same encoding with\n        // stringToProxy (and won't use Ice.Default.EncodingVersion).\n        //\n        s.push(\" -e \");\n        s.push(Ice.encodingVersionToString(this._encoding));\n\n        return s.join(\"\");\n\n        // Derived class writes the remainder of the string.\n    }\n\n    //\n    // Convert the reference to its property form.\n    //\n    toProperty(prefix)\n    {\n        // Abstract\n        Debug.assert(false);\n        return null;\n    }\n\n    getRequestHandler(proxy)\n    {\n        // Abstract\n        Debug.assert(false);\n    }\n\n    getBatchRequestQueue()\n    {\n        // Abstract\n        Debug.assert(false);\n    }\n\n    equals(r)\n    {\n        //\n        // Note: if(this === r) and type test are performed by each non-abstract derived class.\n        //\n\n        if(this._mode !== r._mode)\n        {\n            return false;\n        }\n\n        if(this._secure !== r._secure)\n        {\n            return false;\n        }\n\n        if(!this._identity.equals(r._identity))\n        {\n            return false;\n        }\n\n        if(!MapUtil.equals(this._context, r._context))\n        {\n            return false;\n        }\n\n        if(this._facet !== r._facet)\n        {\n            return false;\n        }\n\n        if(!this._protocol.equals(r._protocol))\n        {\n            return false;\n        }\n\n        if(!this._encoding.equals(r._encoding))\n        {\n            return false;\n        }\n\n        if(this._invocationTimeout !== r._invocationTimeout)\n        {\n            return false;\n        }\n\n        return true;\n    }\n\n    clone()\n    {\n        // Abstract\n        Debug.assert(false);\n        return null;\n    }\n\n    copyMembers(r)\n    {\n        //\n        // Copy the members that are not passed to the constructor.\n        //\n        r._context = this._context;\n    }\n}\n\nReference._emptyContext = new Map();\nReference._emptyEndpoints = [];\n\nIce.Reference = Reference;\n\nclass FixedReference extends Reference\n{\n    constructor(instance, communicator, identity, facet, mode, secure, protocol, encoding, connection,\n                invocationTimeout, context)\n    {\n        super(instance, communicator, identity, facet, mode, secure, protocol, encoding, invocationTimeout, context);\n        this._fixedConnection = connection;\n    }\n\n    getEndpoints()\n    {\n        return Reference._emptyEndpoints;\n    }\n\n    getAdapterId()\n    {\n        return \"\";\n    }\n\n    getRouterInfo()\n    {\n        return null;\n    }\n\n    getLocatorInfo()\n    {\n        return null;\n    }\n\n    getCacheConnection()\n    {\n        return true;\n    }\n\n    getPreferSecure()\n    {\n        return false;\n    }\n\n    getEndpointSelection()\n    {\n        return EndpointSelectionType.Random;\n    }\n\n    getLocatorCacheTimeout()\n    {\n        return 0;\n    }\n\n    getConnectionId()\n    {\n        return \"\";\n    }\n\n    getTimeout()\n    {\n        return undefined;\n    }\n\n    changeAdapterId(newAdapterId)\n    {\n        throw new Ice.FixedProxyException();\n    }\n\n    changeEndpoints(newEndpoints)\n    {\n        throw new Ice.FixedProxyException();\n    }\n\n    changeLocato(newLocator)\n    {\n        throw new Ice.FixedProxyException();\n    }\n\n    changeRouter(newRouter)\n    {\n        throw new Ice.FixedProxyException();\n    }\n\n    changeCacheConnection(newCache)\n    {\n        throw new Ice.FixedProxyException();\n    }\n\n    changePreferSecure(prefSec)\n    {\n        throw new Ice.FixedProxyException();\n    }\n\n    changeEndpointSelection(newType)\n    {\n        throw new Ice.FixedProxyException();\n    }\n\n    changeLocatorCacheTimeout(newTimeout)\n    {\n        throw new Ice.FixedProxyException();\n    }\n\n    changeTimeout(newTimeout)\n    {\n        throw new Ice.FixedProxyException();\n    }\n\n    changeConnectionId(connectionId)\n    {\n        throw new Ice.FixedProxyException();\n    }\n\n    changeConnection(newConnection)\n    {\n        if(newConnection == this._fixedConnection)\n        {\n            return this;\n        }\n        const r = this.getInstance().referenceFactory().copy(this);\n        r._fixedConnection = newConnection;\n        return r;\n    }\n\n    isIndirect()\n    {\n        return false;\n    }\n\n    isWellKnown()\n    {\n        return false;\n    }\n\n    streamWrite(s)\n    {\n        throw new Ice.FixedProxyException();\n    }\n\n    toProperty(prefix)\n    {\n        throw new Ice.FixedProxyException();\n    }\n\n    clone()\n    {\n        const r = new FixedReference(this.getInstance(),\n                                     this.getCommunicator(),\n                                     this.getIdentity(),\n                                     this.getFacet(),\n                                     this.getMode(),\n                                     this.getSecure(),\n                                     this.getProtocol(),\n                                     this.getEncoding(),\n                                     this._fixedConnection,\n                                     this.getInvocationTimeout(),\n                                     this.getContext());\n        this.copyMembers(r);\n        return r;\n    }\n\n    getRequestHandler(proxy)\n    {\n        switch(this.getMode())\n        {\n            case RefMode.ModeTwoway:\n            case RefMode.ModeOneway:\n            case RefMode.ModeBatchOneway:\n            {\n                if(this._fixedConnection.endpoint().datagram())\n                {\n                    throw new Ice.NoEndpointException(this.toString());\n                }\n                break;\n            }\n\n            case RefMode.ModeDatagram:\n            case RefMode.ModeBatchDatagram:\n            {\n                if(!this._fixedConnection.endpoint().datagram())\n                {\n                    throw new Ice.NoEndpointException(this.toString());\n                }\n                break;\n            }\n\n            default:\n            {\n                Debug.assert(false);\n                break;\n            }\n        }\n\n        //\n        // If a secure connection is requested or secure overrides is set,\n        // check if the connection is secure.\n        //\n        const defaultsAndOverrides = this.getInstance().defaultsAndOverrides();\n        const secure = defaultsAndOverrides.overrideSecure ? defaultsAndOverrides.overrideSecureValue : this.getSecure();\n        if(secure && !this._fixedConnection.endpoint().secure())\n        {\n            throw new Ice.NoEndpointException(this.toString());\n        }\n\n        this._fixedConnection.throwException(); // Throw in case our connection is already destroyed.\n\n        return proxy._setRequestHandler(new ConnectionRequestHandler(this, this._fixedConnection));\n    }\n\n    getBatchRequestQueue()\n    {\n        return this._fixedConnection.getBatchRequestQueue();\n    }\n\n    equals(rhs)\n    {\n        if(this === rhs)\n        {\n            return true;\n        }\n        if(!(rhs instanceof FixedReference))\n        {\n            return false;\n        }\n        if(!super.equals(rhs))\n        {\n            return false;\n        }\n        return this._fixedConnection == rhs._fixedConnection;\n    }\n}\n\nIce.FixedReference = FixedReference;\n\nclass RoutableReference extends Reference\n{\n    constructor(instance, communicator, identity, facet, mode, secure, protocol, encoding, endpoints,\n                adapterId, locatorInfo, routerInfo, cacheConnection, preferSecure, endpointSelection,\n                locatorCacheTimeout, invocationTimeout, context)\n    {\n        super(instance, communicator, identity, facet, mode, secure, protocol, encoding, invocationTimeout, context);\n        this._endpoints = endpoints;\n        this._adapterId = adapterId;\n        this._locatorInfo = locatorInfo;\n        this._routerInfo = routerInfo;\n        this._cacheConnection = cacheConnection;\n        this._preferSecure = preferSecure;\n        this._endpointSelection = endpointSelection;\n        this._locatorCacheTimeout = locatorCacheTimeout;\n        this._overrideTimeout = false;\n        this._timeout = -1;\n\n        if(this._endpoints === null)\n        {\n            this._endpoints = Reference._emptyEndpoints;\n        }\n        if(this._adapterId === null)\n        {\n            this._adapterId = \"\";\n        }\n        this._connectionId = \"\";\n        Debug.assert(this._adapterId.length === 0 || this._endpoints.length === 0);\n    }\n\n    getEndpoints()\n    {\n        return this._endpoints;\n    }\n\n    getAdapterId()\n    {\n        return this._adapterId;\n    }\n\n    getRouterInfo()\n    {\n        return this._routerInfo;\n    }\n\n    getLocatorInfo()\n    {\n        return this._locatorInfo;\n    }\n\n    getCacheConnection()\n    {\n        return this._cacheConnection;\n    }\n\n    getPreferSecure()\n    {\n        return this._preferSecure;\n    }\n\n    getEndpointSelection()\n    {\n        return this._endpointSelection;\n    }\n\n    getLocatorCacheTimeout()\n    {\n        return this._locatorCacheTimeout;\n    }\n\n    getConnectionId()\n    {\n        return this._connectionId;\n    }\n\n    getTimeout()\n    {\n        return this._overrideTimeout ? this._timeout : undefined;\n    }\n\n    changeEncoding(newEncoding)\n    {\n        const r = super.changeEncoding(newEncoding);\n        if(r !== this)\n        {\n            if(r._locatorInfo !== null && !r._locatorInfo.getLocator().ice_getEncodingVersion().equals(newEncoding))\n            {\n                r._locatorInfo = this.getInstance().locatorManager().find(\n                    r._locatorInfo.getLocator().ice_encodingVersion(newEncoding));\n            }\n        }\n        return r;\n    }\n\n    changeAdapterId(newAdapterId)\n    {\n        if(this._adapterId === newAdapterId)\n        {\n            return this;\n        }\n        const r = this.getInstance().referenceFactory().copy(this);\n        r._adapterId = newAdapterId;\n        r._endpoints = Reference._emptyEndpoints;\n        return r;\n    }\n\n    changeEndpoints(newEndpoints)\n    {\n        if(ArrayUtil.equals(newEndpoints, this._endpoints, (e1, e2) => e1.equals(e2)))\n        {\n            return this;\n        }\n        const r = this.getInstance().referenceFactory().copy(this);\n        r._endpoints = newEndpoints;\n        r._adapterId = \"\";\n        r.applyOverrides(r._endpoints);\n        return r;\n    }\n\n    changeLocator(newLocator)\n    {\n        const newLocatorInfo = this.getInstance().locatorManager().find(newLocator);\n        if(newLocatorInfo !== null && this._locatorInfo !== null && newLocatorInfo.equals(this._locatorInfo))\n        {\n            return this;\n        }\n        const r = this.getInstance().referenceFactory().copy(this);\n        r._locatorInfo = newLocatorInfo;\n        return r;\n    }\n\n    changeRouter(newRouter)\n    {\n        const newRouterInfo = this.getInstance().routerManager().find(newRouter);\n        if(newRouterInfo !== null && this._routerInfo !== null && newRouterInfo.equals(this._routerInfo))\n        {\n            return this;\n        }\n        const r = this.getInstance().referenceFactory().copy(this);\n        r._routerInfo = newRouterInfo;\n        return r;\n    }\n\n    changeCacheConnection(newCache)\n    {\n        if(newCache === this._cacheConnection)\n        {\n            return this;\n        }\n        const r = this.getInstance().referenceFactory().copy(this);\n        r._cacheConnection = newCache;\n        return r;\n    }\n\n    changePreferSecure(newPreferSecure)\n    {\n        if(newPreferSecure === this._preferSecure)\n        {\n            return this;\n        }\n        const r = this.getInstance().referenceFactory().copy(this);\n        r._preferSecure = newPreferSecure;\n        return r;\n    }\n\n    changeEndpointSelection(newType)\n    {\n        if(newType === this._endpointSelection)\n        {\n            return this;\n        }\n        const r = this.getInstance().referenceFactory().copy(this);\n        r._endpointSelection = newType;\n        return r;\n    }\n\n    changeLocatorCacheTimeout(newTimeout)\n    {\n        if(this._locatorCacheTimeout === newTimeout)\n        {\n            return this;\n        }\n        const r = this.getInstance().referenceFactory().copy(this);\n        r._locatorCacheTimeout = newTimeout;\n        return r;\n    }\n\n    changeTimeout(newTimeout)\n    {\n        if(this._overrideTimeout && this._timeout === newTimeout)\n        {\n            return this;\n        }\n        const r = this.getInstance().referenceFactory().copy(this);\n        r._timeout = newTimeout;\n        r._overrideTimeout = true;\n        r._endpoints = this._endpoints.map(endpoint => endpoint.changeTimeout(newTimeout));\n        return r;\n    }\n\n    changeConnectionId(id)\n    {\n        if(this._connectionId === id)\n        {\n            return this;\n        }\n        const r = this.getInstance().referenceFactory().copy(this);\n        r._connectionId = id;\n        r._endpoints = this._endpoints.map(endpoint => endpoint.changeConnectionId(id));\n        return r;\n    }\n\n    changeConnection(newConnection)\n    {\n        return new FixedReference(this.getInstance(),\n                                  this.getCommunicator(),\n                                  this.getIdentity(),\n                                  this.getFacet(),\n                                  this.getMode(),\n                                  this.getSecure(),\n                                  this.getProtocol(),\n                                  this.getEncoding(),\n                                  newConnection,\n                                  this.getInvocationTimeout(),\n                                  this.getContext());\n    }\n\n    isIndirect()\n    {\n        return this._endpoints.length === 0;\n    }\n\n    isWellKnown()\n    {\n        return this._endpoints.length === 0 && this._adapterId.length === 0;\n    }\n\n    streamWrite(s)\n    {\n        super.streamWrite(s);\n\n        s.writeSize(this._endpoints.length);\n        if(this._endpoints.length > 0)\n        {\n            Debug.assert(this._adapterId.length === 0);\n            this._endpoints.forEach(endpoint =>\n                {\n                    s.writeShort(endpoint.type());\n                    endpoint.streamWrite(s);\n                });\n        }\n        else\n        {\n            s.writeString(this._adapterId); // Adapter id.\n        }\n    }\n\n    toString()\n    {\n        //\n        // WARNING: Certain features, such as proxy validation in Glacier2,\n        // depend on the format of proxy strings. Changes to toString() and\n        // methods called to generate parts of the reference string could break\n        // these features. Please review for all features that depend on the\n        // format of proxyToString() before changing this and related code.\n        //\n        const s = [];\n        s.push(super.toString());\n        if(this._endpoints.length > 0)\n        {\n            this._endpoints.forEach(endpoint =>\n                {\n                    const endp = endpoint.toString();\n                    if(endp !== null && endp.length > 0)\n                    {\n                        s.push(':');\n                        s.push(endp);\n                    }\n                });\n        }\n        else if(this._adapterId.length > 0)\n        {\n            s.push(\" @ \");\n\n            //\n            // If the encoded adapter id string contains characters which\n            // the reference parser uses as separators, then we enclose\n            // the adapter id string in quotes.\n            //\n            const a = StringUtil.escapeString(this._adapterId, null, this._instance.toStringMode());\n            if(a.search(/[ :@]/) != -1)\n            {\n                s.push('\"');\n                s.push(a);\n                s.push('\"');\n            }\n            else\n            {\n                s.push(a);\n            }\n        }\n        return s.join(\"\");\n    }\n\n    toProperty(prefix)\n    {\n        const properties = new Map();\n\n        properties.set(prefix, this.toString());\n        properties.set(prefix + \".CollocationOptimized\", \"0\");\n        properties.set(prefix + \".ConnectionCached\", this._cacheConnection ? \"1\" : \"0\");\n        properties.set(prefix + \".PreferSecure\", this._preferSecure ? \"1\" : \"0\");\n        properties.set(prefix + \".EndpointSelection\",\n                       this._endpointSelection === EndpointSelectionType.Random ? \"Random\" : \"Ordered\");\n\n        properties.set(prefix + \".LocatorCacheTimeout\", String(this._locatorCacheTimeout));\n        properties.set(prefix + \".InvocationTimeout\", String(this.getInvocationTimeout()));\n\n        if(this._routerInfo !== null)\n        {\n            this._routerInfo.getRouter()._getReference().toProperty(prefix + \".Router\").forEach(\n                (value, key) => properties.set(key, value));\n        }\n\n        if(this._locatorInfo !== null)\n        {\n            this._locatorInfo.getLocator()._getReference().toProperty(prefix + \".Locator\").forEach(\n                (value, key) => properties.set(key, value));\n        }\n\n        return properties;\n    }\n\n    hashCode()\n    {\n        if(!this._hashInitialized)\n        {\n            super.hashCode(); // Initializes _hashValue.\n            this._hashValue = HashUtil.addString(this._hashValue, this._adapterId);\n        }\n        return this._hashValue;\n    }\n\n    equals(rhs)\n    {\n        if(this === rhs)\n        {\n            return true;\n        }\n        if(!(rhs instanceof RoutableReference))\n        {\n            return false;\n        }\n\n        if(!super.equals(rhs))\n        {\n            return false;\n        }\n\n        if(this._locatorInfo === null ? rhs._locatorInfo !== null : !this._locatorInfo.equals(rhs._locatorInfo))\n        {\n            return false;\n        }\n        if(this._routerInfo === null ? rhs._routerInfo !== null : !this._routerInfo.equals(rhs._routerInfo))\n        {\n            return false;\n        }\n        if(this._cacheConnection !== rhs._cacheConnection)\n        {\n            return false;\n        }\n        if(this._preferSecure !== rhs._preferSecure)\n        {\n            return false;\n        }\n        if(this._endpointSelection !== rhs._endpointSelection)\n        {\n            return false;\n        }\n        if(this._locatorCacheTimeout !== rhs._locatorCacheTimeout)\n        {\n            return false;\n        }\n        if(this._connectionId !== rhs._connectionId)\n        {\n            return false;\n        }\n        if(this._overrideTimeout !== rhs._overrideTimeout)\n        {\n            return false;\n        }\n        if(this._overrideTimeout && this._timeout !== rhs._timeout)\n        {\n            return false;\n        }\n        if(!ArrayUtil.equals(this._endpoints, rhs._endpoints, (e1, e2) => e1.equals(e2)))\n        {\n            return false;\n        }\n        if(this._adapterId !== rhs._adapterId)\n        {\n            return false;\n        }\n        return true;\n    }\n\n    getRequestHandler(proxy)\n    {\n        return this._instance.requestHandlerFactory().getRequestHandler(this, proxy);\n    }\n\n    getBatchRequestQueue()\n    {\n        return new BatchRequestQueue(this._instance, this._mode === RefMode.ModeBatchDatagram);\n    }\n\n    getConnection()\n    {\n        const p = new Ice.Promise(); // success callback receives (connection)\n\n        if(this._routerInfo !== null)\n        {\n            //\n            // If we route, we send everything to the router's client\n            // proxy endpoints.\n            //\n            this._routerInfo.getClientEndpoints().then(endpts =>\n                {\n                    if(endpts.length > 0)\n                    {\n                        this.applyOverrides(endpts);\n                        this.createConnection(endpts).then(p.resolve, p.reject);\n                    }\n                    else\n                    {\n                        this.getConnectionNoRouterInfo(p);\n                    }\n                }).catch(p.reject);\n        }\n        else\n        {\n            this.getConnectionNoRouterInfo(p);\n        }\n        return p;\n    }\n\n    getConnectionNoRouterInfo(p)\n    {\n        if(this._endpoints.length > 0)\n        {\n            this.createConnection(this._endpoints).then(p.resolve).catch(p.reject);\n            return;\n        }\n\n        if(this._locatorInfo !== null)\n        {\n            this._locatorInfo.getEndpoints(this, null, this._locatorCacheTimeout).then(\n                values =>\n                {\n                    const [endpoints, cached] = values;\n                    if(endpoints.length === 0)\n                    {\n                        p.reject(new Ice.NoEndpointException(this.toString()));\n                        return;\n                    }\n\n                    this.applyOverrides(endpoints);\n                    this.createConnection(endpoints).then(\n                        p.resolve,\n                        ex =>\n                        {\n                            if(ex instanceof Ice.NoEndpointException)\n                            {\n                                //\n                                // No need to retry if there's no endpoints.\n                                //\n                                p.reject(ex);\n                            }\n                            else\n                            {\n                                Debug.assert(this._locatorInfo !== null);\n                                this.getLocatorInfo().clearCache(this);\n                                if(cached)\n                                {\n                                    const traceLevels = this.getInstance().traceLevels();\n                                    if(traceLevels.retry >= 2)\n                                    {\n                                        this.getInstance().initializationData().logger.trace(\n                                            traceLevels.retryCat,\n                                            \"connection to cached endpoints failed\\n\" +\n                                            \"removing endpoints from cache and trying again\\n\" +\n                                            ex.toString());\n                                    }\n                                    this.getConnectionNoRouterInfo(p); // Retry.\n                                    return;\n                                }\n                                p.reject(ex);\n                            }\n                        });\n                }).catch(p.reject);\n        }\n        else\n        {\n            p.reject(new Ice.NoEndpointException(this.toString()));\n        }\n    }\n\n    clone()\n    {\n        const r = new RoutableReference(this.getInstance(),\n                                        this.getCommunicator(),\n                                        this.getIdentity(),\n                                        this.getFacet(),\n                                        this.getMode(),\n                                        this.getSecure(),\n                                        this.getProtocol(),\n                                        this.getEncoding(),\n                                        this._endpoints,\n                                        this._adapterId,\n                                        this._locatorInfo,\n                                        this._routerInfo,\n                                        this._cacheConnection,\n                                        this._preferSecure,\n                                        this._endpointSelection,\n                                        this._locatorCacheTimeout,\n                                        this._invocationTimeout);\n        this.copyMembers(r);\n        return r;\n    }\n\n    copyMembers(rhs)\n    {\n        //\n        // Copy the members that are not passed to the constructor.\n        //\n        super.copyMembers(rhs);\n        rhs._overrideTimeout = this._overrideTimeout;\n        rhs._timeout = this._timeout;\n        rhs._connectionId = this._connectionId;\n    }\n\n    applyOverrides(endpts)\n    {\n        //\n        // Apply the endpoint overrides to each endpoint.\n        //\n        for(let i = 0; i < endpts.length; ++i)\n        {\n            endpts[i] = endpts[i].changeConnectionId(this._connectionId);\n            if(this._overrideTimeout)\n            {\n                endpts[i] = endpts[i].changeTimeout(this._timeout);\n            }\n        }\n    }\n\n    filterEndpoints(allEndpoints)\n    {\n        //\n        // Filter out opaque endpoints or endpoints which can't connect.\n        //\n        let endpoints = allEndpoints.filter(e => !(e instanceof OpaqueEndpointI) && e.connectable());\n\n        //\n        // Filter out endpoints according to the mode of the reference.\n        //\n        switch(this.getMode())\n        {\n            case RefMode.ModeTwoway:\n            case RefMode.ModeOneway:\n            case RefMode.ModeBatchOneway:\n            {\n                //\n                // Filter out datagram endpoints.\n                //\n                endpoints = endpoints.filter(e => !e.datagram());\n                break;\n            }\n\n            case RefMode.ModeDatagram:\n            case RefMode.ModeBatchDatagram:\n            {\n                //\n                // Filter out non-datagram endpoints.\n                //\n                endpoints = endpoints.filter(e => e.datagram());\n                break;\n            }\n\n            default:\n            {\n                Debug.assert(false);\n                break;\n            }\n        }\n\n        //\n        // Sort the endpoints according to the endpoint selection type.\n        //\n        switch(this.getEndpointSelection())\n        {\n            case EndpointSelectionType.Random:\n            {\n                //\n                // Shuffle the endpoints.\n                //\n                ArrayUtil.shuffle(endpoints);\n                break;\n            }\n            case EndpointSelectionType.Ordered:\n            {\n                // Nothing to do.\n                break;\n            }\n            default:\n            {\n                Debug.assert(false);\n                break;\n            }\n        }\n\n        //\n        // If a secure connection is requested or secure overrides is\n        // set, remove all non-secure endpoints. Otherwise if preferSecure is set\n        // make secure endpoints prefered. By default make non-secure\n        // endpoints preferred over secure endpoints.\n        //\n        const overrides = this.getInstance().defaultsAndOverrides();\n        if(overrides.overrideSecure ? overrides.overrideSecureValue : this.getSecure())\n        {\n            endpoints = endpoints.filter(e => e.secure());\n        }\n        else\n        {\n            const preferSecure = this.getPreferSecure();\n            const compare = (e1, e2) =>\n            {\n                const ls = e1.secure();\n                const rs = e2.secure();\n                if((ls && rs) || (!ls && !rs))\n                {\n                    return 0;\n                }\n                else if(!ls && rs)\n                {\n                    return preferSecure ? 1 : -1;\n                }\n                else\n                {\n                    return preferSecure ? -1 : 1;\n                }\n            };\n            endpoints.sort(compare);\n        }\n        return endpoints;\n    }\n\n    createConnection(allEndpoints)\n    {\n        const endpoints = this.filterEndpoints(allEndpoints);\n        if(endpoints.length === 0)\n        {\n            return Ice.Promise.reject(new Ice.NoEndpointException(this.toString()));\n        }\n\n        //\n        // Finally, create the connection.\n        //\n        const promise = new Ice.Promise();\n        const factory = this.getInstance().outgoingConnectionFactory();\n        if(this.getCacheConnection() || endpoints.length == 1)\n        {\n            //\n            // Get an existing connection or create one if there's no\n            // existing connection to one of the given endpoints.\n            //\n            const cb = new CreateConnectionCallback(this, null, promise);\n            factory.create(endpoints, false, this.getEndpointSelection()).then(\n                connection => cb.setConnection(connection)).catch(ex => cb.setException(ex));\n        }\n        else\n        {\n            //\n            // Go through the list of endpoints and try to create the\n            // connection until it succeeds. This is different from just\n            // calling create() with the given endpoints since this might\n            // create a new connection even if there's an existing\n            // connection for one of the endpoints.\n            //\n            const cb = new CreateConnectionCallback(this, endpoints, promise);\n            factory.create([endpoints[0]], true, this.getEndpointSelection()).then(\n                connection => cb.setConnection(connection)).catch(ex => cb.setException(ex));\n        }\n        return promise;\n    }\n}\n\nIce.RoutableReference = RoutableReference;\nmodule.exports.Ice = Ice;\n\nclass CreateConnectionCallback\n{\n    constructor(r, endpoints, promise)\n    {\n        this.ref = r;\n        this.endpoints = endpoints;\n        this.promise = promise;\n        this.i = 0;\n        this.exception = null;\n    }\n\n    setConnection(connection)\n    {\n        //\n        // If we have a router, set the object adapter for this router\n        // (if any) to the new connection, so that callbacks from the\n        // router can be received over this new connection.\n        //\n        if(this.ref.getRouterInfo() !== null && this.ref.getRouterInfo().getAdapter() !== null)\n        {\n            connection.setAdapter(this.ref.getRouterInfo().getAdapter());\n        }\n        this.promise.resolve(connection);\n    }\n\n    setException(ex)\n    {\n        if(this.exception === null)\n        {\n            this.exception = ex;\n        }\n\n        if(this.endpoints === null || ++this.i === this.endpoints.length)\n        {\n            this.promise.reject(this.exception);\n            return;\n        }\n\n        this.ref.getInstance().outgoingConnectionFactory().create(\n            [this.endpoints[this.i]],\n            this.i != this.endpoints.length - 1,\n            this.ref.getEndpointSelection()).then(\n                connection => this.setConnection(connection)).catch(ex => this.setException(ex));\n    }\n}\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/Reference.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/ReferenceMode.js":
/*!***************************************************!*\
  !*** ./node_modules/ice/src/Ice/ReferenceMode.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nconst Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n\n//\n// Using a separate module for these constants so that ObjectPrx does\n// not need to include Reference.\n//\nIce.ReferenceMode =\n{\n    ModeTwoway: 0,\n    ModeOneway: 1,\n    ModeBatchOneway: 2,\n    ModeDatagram: 3,\n    ModeBatchDatagram: 4,\n    ModeLast: 4\n};\nmodule.exports.Ice = Ice;\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/ReferenceMode.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/RequestHandlerFactory.js":
/*!***********************************************************!*\
  !*** ./node_modules/ice/src/Ice/RequestHandlerFactory.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nconst Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n\n__webpack_require__(/*! ../Ice/ConnectRequestHandler */ \"./node_modules/ice/src/Ice/ConnectRequestHandler.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/Reference */ \"./node_modules/ice/src/Ice/Reference.js\");\n\nconst ConnectRequestHandler = Ice.ConnectRequestHandler;\nconst HashMap = Ice.HashMap;\n\nclass RequestHandlerFactory\n{\n    constructor(instance)\n    {\n        this._instance = instance;\n        this._handlers = new HashMap(HashMap.compareEquals);\n    }\n\n    getRequestHandler(ref, proxy)\n    {\n        let connect = false;\n        let handler;\n        if(ref.getCacheConnection())\n        {\n            handler = this._handlers.get(ref);\n            if(!handler)\n            {\n                handler = new ConnectRequestHandler(ref, proxy);\n                this._handlers.set(ref, handler);\n                connect = true;\n            }\n        }\n        else\n        {\n            connect = true;\n            handler = new ConnectRequestHandler(ref, proxy);\n        }\n\n        if(connect)\n        {\n            ref.getConnection().then(connection =>\n                                     {\n                                         handler.setConnection(connection);\n                                     },\n                                     ex =>\n                                     {\n                                         handler.setException(ex);\n                                     });\n        }\n        return proxy._setRequestHandler(handler.connect(proxy));\n    }\n\n    removeRequestHandler(ref, handler)\n    {\n        if(ref.getCacheConnection())\n        {\n            if(this._handlers.get(ref) === handler)\n            {\n                this._handlers.delete(ref);\n            }\n        }\n    }\n}\n\nIce.RequestHandlerFactory = RequestHandlerFactory;\nmodule.exports.Ice = Ice;\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/RequestHandlerFactory.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/RetryException.js":
/*!****************************************************!*\
  !*** ./node_modules/ice/src/Ice/RetryException.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nconst Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n\n__webpack_require__(/*! ../Ice/Debug */ \"./node_modules/ice/src/Ice/Debug.js\");\n__webpack_require__(/*! ../Ice/LocalException */ \"./node_modules/ice/src/Ice/LocalException.js\");\n\nclass RetryException extends Error\n{\n    constructor(ex)\n    {\n        super();\n        if(ex instanceof Ice.LocalException)\n        {\n            this._ex = ex;\n        }\n        else\n        {\n            Ice.Debug.assert(ex instanceof RetryException);\n            this._ex = ex._ex;\n        }\n    }\n\n    get inner()\n    {\n        return this._ex;\n    }\n}\n\nIce.RetryException = RetryException;\nmodule.exports.Ice = Ice;\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/RetryException.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/RetryQueue.js":
/*!************************************************!*\
  !*** ./node_modules/ice/src/Ice/RetryQueue.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nconst Ice = (__webpack_require__(/*! ../Ice/LocalException */ \"./node_modules/ice/src/Ice/LocalException.js\").Ice);\n\nclass RetryTask\n{\n    constructor(instance, queue, outAsync, interval)\n    {\n        this._instance = instance;\n        this._queue = queue;\n        this._outAsync = outAsync;\n    }\n\n    run()\n    {\n        this._outAsync.retry();\n        this._queue.remove(this);\n    }\n\n    destroy()\n    {\n        try\n        {\n            this._outAsync.abort(new Ice.CommunicatorDestroyedException());\n        }\n        catch(ex)\n        {\n            // Abort shouldn't throw if there's no callback, ignore.\n        }\n    }\n\n    asyncRequestCanceled(outAsync, ex)\n    {\n        if(this._queue.cancel(this))\n        {\n            if(this._instance.traceLevels().retry >= 1)\n            {\n                this._instance.initializationData().logger.trace(this._instance.traceLevels().retryCat,\n                                                                 \"operation retry canceled\\n\" + ex.toString());\n            }\n            this._outAsync.completedEx(ex);\n        }\n    }\n}\n\nclass RetryQueue\n{\n    constructor(instance)\n    {\n        this._instance = instance;\n        this._requests = [];\n    }\n\n    add(outAsync, interval)\n    {\n        if(this._instance === null)\n        {\n            throw new Ice.CommunicatorDestroyedException();\n        }\n        const task = new RetryTask(this._instance, this, outAsync);\n        outAsync.cancelable(task); // This will throw if the request is canceled\n        task.token = this._instance.timer().schedule(() => task.run(), interval);\n        this._requests.push(task);\n    }\n\n    destroy()\n    {\n        this._requests.forEach(request =>\n            {\n                this._instance.timer().cancel(request.token);\n                request.destroy();\n            });\n\n        this._requests = [];\n        this._instance = null;\n    }\n\n    remove(task)\n    {\n        const idx = this._requests.indexOf(task);\n        if(idx >= 0)\n        {\n            this._requests.splice(idx, 1);\n        }\n    }\n\n    cancel(task)\n    {\n        const idx = this._requests.indexOf(task);\n        if(idx >= 0)\n        {\n            this._requests.splice(idx, 1);\n            return this._instance.timer().cancel(task.token);\n        }\n        return false;\n    }\n}\nIce.RetryQueue = RetryQueue;\n\nmodule.exports.Ice = Ice;\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/RetryQueue.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/Router.js":
/*!********************************************!*\
  !*** ./node_modules/ice/src/Ice/Router.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n//\n// Ice version 3.7.10\n//\n// <auto-generated>\n//\n// Generated from file `Router.ice'\n//\n// Warning: do not edit this file.\n//\n// </auto-generated>\n//\n\n/* eslint-disable */\n/* jshint ignore: start */\n\n/* slice2js browser-bundle-skip */\nconst _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\n__webpack_require__(/*! ../Ice/Object */ \"./node_modules/ice/src/Ice/Object.js\");\n__webpack_require__(/*! ../Ice/Value */ \"./node_modules/ice/src/Ice/Value.js\");\n__webpack_require__(/*! ../Ice/ObjectPrx */ \"./node_modules/ice/src/Ice/ObjectPrx.js\");\n__webpack_require__(/*! ../Ice/Operation */ \"./node_modules/ice/src/Ice/Operation.js\");\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\n__webpack_require__(/*! ../Ice/BuiltinSequences */ \"./node_modules/ice/src/Ice/BuiltinSequences.js\");\nconst Ice = _ModuleRegistry.module(\"Ice\");\n\nconst Slice = Ice.Slice;\n/* slice2js browser-bundle-skip-end */\n\nconst iceC_Ice_Router_ids = [\n    \"::Ice::Object\",\n    \"::Ice::Router\"\n];\n\n/**\n * The Ice router interface. Routers can be set either globally with\n * {@link Communicator#setDefaultRouter}, or with <code>ice_router</code> on specific\n * proxies.\n *\n **/\nIce.Router = class extends Ice.Object\n{\n};\n\nIce.RouterPrx = class extends Ice.ObjectPrx\n{\n};\n\nSlice.defineOperations(Ice.Router, Ice.RouterPrx, iceC_Ice_Router_ids, 1,\n{\n    \"getClientProxy\": [, 2, 1, , [9], , [[1, , 1]], , , ],\n    \"getServerProxy\": [, 2, 1, , [9], , , , , ],\n    \"addProxies\": [, 2, 2, , [\"Ice.ObjectProxySeqHelper\"], [[\"Ice.ObjectProxySeqHelper\"]], , , , ]\n});\n\nconst iceC_Ice_RouterFinder_ids = [\n    \"::Ice::Object\",\n    \"::Ice::RouterFinder\"\n];\n\n/**\n * This inferface should be implemented by services implementing the\n * Ice::Router interface. It should be advertised through an Ice\n * object with the identity `Ice/RouterFinder'. This allows clients to\n * retrieve the router proxy with just the endpoint information of the\n * service.\n *\n **/\nIce.RouterFinder = class extends Ice.Object\n{\n};\n\nIce.RouterFinderPrx = class extends Ice.ObjectPrx\n{\n};\n\nSlice.defineOperations(Ice.RouterFinder, Ice.RouterFinderPrx, iceC_Ice_RouterFinder_ids, 1,\n{\n    \"getRouter\": [, , , , [\"Ice.RouterPrx\"], , , , , ]\n});\n/* slice2js browser-bundle-skip */\nexports.Ice = Ice;\n/* slice2js browser-bundle-skip-end */\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/Router.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/RouterInfo.js":
/*!************************************************!*\
  !*** ./node_modules/ice/src/Ice/RouterInfo.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nconst Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n\n__webpack_require__(/*! ../Ice/Debug */ \"./node_modules/ice/src/Ice/Debug.js\");\n__webpack_require__(/*! ../Ice/Exception */ \"./node_modules/ice/src/Ice/Exception.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/LocalException */ \"./node_modules/ice/src/Ice/LocalException.js\");\n__webpack_require__(/*! ../Ice/Promise */ \"./node_modules/ice/src/Ice/Promise.js\");\n\nconst Debug = Ice.Debug;\nconst HashMap = Ice.HashMap;\n\nclass RouterInfo\n{\n    constructor(router)\n    {\n        this._router = router;\n\n        Debug.assert(this._router !== null);\n\n        this._clientEndpoints = null;\n        this._adapter = null;\n        this._identities = new HashMap(HashMap.compareEquals); // Set<Identity> = Map<Identity, 1>\n        this._evictedIdentities = [];\n        this._hasRoutingTable = false;\n    }\n\n    destroy()\n    {\n        this._clientEndpoints = [];\n        this._adapter = null;\n        this._identities.clear();\n    }\n\n    equals(rhs)\n    {\n        if(this === rhs)\n        {\n            return true;\n        }\n\n        if(rhs instanceof RouterInfo)\n        {\n            return this._router.equals(rhs._router);\n        }\n\n        return false;\n    }\n\n    hashCode()\n    {\n        return this._router.hashCode();\n    }\n\n    getRouter()\n    {\n        //\n        // No mutex lock necessary, _router is immutable.\n        //\n        return this._router;\n    }\n\n    getClientEndpoints()\n    {\n        const promise = new Ice.Promise();\n        if(this._clientEndpoints !== null)\n        {\n            promise.resolve(this._clientEndpoints);\n        }\n        else\n        {\n            this._router.getClientProxy().then(result =>\n                           this.setClientEndpoints(result[0],\n                                                   result[1] !== undefined ? result[1] : true,\n                                                   promise)).catch(promise.reject);\n        }\n        return promise;\n    }\n\n    getServerEndpoints()\n    {\n        return this._router.getServerProxy().then(serverProxy => {\n            if(serverProxy === null)\n            {\n                throw new Ice.NoEndpointException();\n            }\n            serverProxy = serverProxy.ice_router(null); // The server proxy cannot be routed.\n            return serverProxy._getReference().getEndpoints();\n        });\n    }\n\n    addProxy(proxy)\n    {\n        Debug.assert(proxy !== null);\n        if(!this._hasRoutingTable)\n        {\n            return Ice.Promise.resolve(); // The router implementation doesn't maintain a routing table.\n        }\n        else if(this._identities.has(proxy.ice_getIdentity()))\n        {\n            //\n            // Only add the proxy to the router if it's not already in our local map.\n            //\n            return Ice.Promise.resolve();\n        }\n        else\n        {\n            return this._router.addProxies([proxy]).then(\n                evictedProxies =>\n                {\n                    this.addAndEvictProxies(proxy, evictedProxies);\n                });\n        }\n    }\n\n    setAdapter(adapter)\n    {\n        this._adapter = adapter;\n    }\n\n    getAdapter()\n    {\n        return this._adapter;\n    }\n\n    clearCache(ref)\n    {\n        this._identities.delete(ref.getIdentity());\n    }\n\n    setClientEndpoints(clientProxy, hasRoutingTable, promise)\n    {\n        if(this._clientEndpoints === null)\n        {\n            this._hasRoutingTable = hasRoutingTable;\n            if(clientProxy === null)\n            {\n                //\n                // If getClientProxy() return nil, use router endpoints.\n                //\n                this._clientEndpoints = this._router._getReference().getEndpoints();\n                promise.resolve(this._clientEndpoints);\n            }\n            else\n            {\n                clientProxy = clientProxy.ice_router(null); // The client proxy cannot be routed.\n\n                //\n                // In order to avoid creating a new connection to the\n                // router, we must use the same timeout as the already\n                // existing connection.\n                //\n                this._router.ice_getConnection().then(\n                    con =>\n                    {\n                        this._clientEndpoints = clientProxy.ice_timeout(con.timeout())._getReference().getEndpoints();\n                        promise.resolve(this._clientEndpoints);\n                    }).catch(promise.reject);\n            }\n        }\n        else\n        {\n            promise.resolve(this._clientEndpoints);\n        }\n    }\n\n    addAndEvictProxies(proxy, evictedProxies)\n    {\n        //\n        // Check if the proxy hasn't already been evicted by a\n        // concurrent addProxies call. If it's the case, don't\n        // add it to our local map.\n        //\n        const index = this._evictedIdentities.findIndex(e => e.equals(proxy.ice_getIdentity()));\n        if(index >= 0)\n        {\n            this._evictedIdentities.splice(index, 1);\n        }\n        else\n        {\n            //\n            // If we successfully added the proxy to the router,\n            // we add it to our local map.\n            //\n            this._identities.set(proxy.ice_getIdentity(), 1);\n        }\n\n        //\n        // We also must remove whatever proxies the router evicted.\n        //\n        evictedProxies.forEach(proxy =>\n            {\n                this._identities.delete(proxy.ice_getIdentity());\n            });\n    }\n}\n\nIce.RouterInfo = RouterInfo;\nmodule.exports.Ice = Ice;\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/RouterInfo.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/RouterManager.js":
/*!***************************************************!*\
  !*** ./node_modules/ice/src/Ice/RouterManager.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nconst Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/Router */ \"./node_modules/ice/src/Ice/Router.js\");\n__webpack_require__(/*! ../Ice/RouterInfo */ \"./node_modules/ice/src/Ice/RouterInfo.js\");\n\nconst HashMap = Ice.HashMap;\nconst RouterInfo = Ice.RouterInfo;\nconst RouterPrx = Ice.RouterPrx;\n\nclass RouterManager\n{\n    constructor()\n    {\n        this._table = new HashMap(HashMap.compareEquals); // Map<Ice.RouterPrx, RouterInfo>\n    }\n\n    destroy()\n    {\n        for(const router of this._table.values())\n        {\n            router.destroy();\n        }\n        this._table.clear();\n    }\n\n    //\n    // Returns router info for a given router. Automatically creates\n    // the router info if it doesn't exist yet.\n    //\n    find(rtr)\n    {\n        if(rtr === null)\n        {\n            return null;\n        }\n\n        //\n        // The router cannot be routed.\n        //\n        const router = RouterPrx.uncheckedCast(rtr.ice_router(null));\n\n        let info = this._table.get(router);\n        if(info === undefined)\n        {\n            info = new RouterInfo(router);\n            this._table.set(router, info);\n        }\n\n        return info;\n    }\n\n    erase(rtr)\n    {\n        let info = null;\n        if(rtr !== null)\n        {\n            // The router cannot be routed.\n            const router = RouterPrx.uncheckedCast(rtr.ice_router(null));\n\n            info = this._table.get(router);\n            this._table.delete(router);\n        }\n        return info;\n    }\n}\nIce.RouterManager = RouterManager;\nmodule.exports.Ice = Ice;\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/RouterManager.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/ServantManager.js":
/*!****************************************************!*\
  !*** ./node_modules/ice/src/Ice/ServantManager.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nconst Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n\n__webpack_require__(/*! ../Ice/Debug */ \"./node_modules/ice/src/Ice/Debug.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/IdentityUtil */ \"./node_modules/ice/src/Ice/IdentityUtil.js\");\n__webpack_require__(/*! ../Ice/LocalException */ \"./node_modules/ice/src/Ice/LocalException.js\");\n__webpack_require__(/*! ../Ice/StringUtil */ \"./node_modules/ice/src/Ice/StringUtil.js\");\n\nconst Debug = Ice.Debug;\nconst HashMap = Ice.HashMap;\nconst StringUtil = Ice.StringUtil;\n\n//\n// Only for use by Ice.ObjectAdatperI.\n//\nclass ServantManager\n{\n    constructor(instance, adapterName)\n    {\n        this._instance = instance;\n        this._adapterName = adapterName;\n        // Map<Ice.Identity, Map<String, Ice.Object> >\n        this._servantMapMap = new HashMap(HashMap.compareEquals);\n        // Map<String, Ice.Object>\n        this._defaultServantMap = new Map();\n        // Map<String, Ice.ServantLocator>\n        this._locatorMap = new Map();\n    }\n\n    addServant(servant, ident, facet)\n    {\n        Debug.assert(this._instance !== null); // Must not be called after destruction.\n\n        if(facet === null)\n        {\n            facet = \"\";\n        }\n\n        let m = this._servantMapMap.get(ident);\n        if(m === undefined)\n        {\n            m = new Map();\n            this._servantMapMap.set(ident, m);\n        }\n        else if(m.has(facet))\n        {\n            const ex = new Ice.AlreadyRegisteredException();\n            ex.id = Ice.identityToString(ident, this._instance.toStringMode());\n            ex.kindOfObject = \"servant\";\n            if(facet.length > 0)\n            {\n                ex.id += \" -f \" + StringUtil.escapeString(facet, \"\", this._instance.toStringMode());\n            }\n            throw ex;\n        }\n\n        m.set(facet, servant);\n    }\n\n    addDefaultServant(servant, category)\n    {\n        Debug.assert(this._instance !== null); // Must not be called after destruction\n\n        if(this._defaultServantMap.has(category))\n        {\n            const ex = new Ice.AlreadyRegisteredException();\n            ex.kindOfObject = \"default servant\";\n            ex.id = category;\n            throw ex;\n        }\n\n        this._defaultServantMap.set(category, servant);\n    }\n\n    removeServant(ident, facet)\n    {\n        Debug.assert(this._instance !== null); // Must not be called after destruction.\n\n        if(facet === null)\n        {\n            facet = \"\";\n        }\n\n        const m = this._servantMapMap.get(ident);\n        if(m === undefined || !m.has(facet))\n        {\n            const ex = new Ice.NotRegisteredException();\n            ex.id = Ice.identityToString(ident, this._instance.toStringMode());\n            ex.kindOfObject = \"servant\";\n            if(facet.length > 0)\n            {\n                ex.id += \" -f \" + StringUtil.escapeString(facet, \"\", this._instance.toStringMode());\n            }\n            throw ex;\n        }\n\n        const obj = m.get(facet);\n        m.delete(facet);\n\n        if(m.size === 0)\n        {\n            this._servantMapMap.delete(ident);\n        }\n\n        return obj;\n    }\n\n    removeDefaultServant(category)\n    {\n        Debug.assert(this._instance !== null); // Must not be called after destruction.\n\n        const obj = this._defaultServantMap.get(category);\n        if(obj === undefined)\n        {\n            const ex = new Ice.NotRegisteredException();\n            ex.kindOfObject = \"default servant\";\n            ex.id = category;\n            throw ex;\n        }\n\n        this._defaultServantMap.delete(category);\n        return obj;\n    }\n\n    removeAllFacets(ident)\n    {\n        Debug.assert(this._instance !== null); // Must not be called after destruction.\n\n        const m = this._servantMapMap.get(ident);\n        if(m === undefined)\n        {\n            const ex = new Ice.NotRegisteredException();\n            ex.id = Ice.identityToString(ident, this._instance.toStringMode());\n            ex.kindOfObject = \"servant\";\n            throw ex;\n        }\n\n        this._servantMapMap.delete(ident);\n\n        return m;\n    }\n\n    findServant(ident, facet)\n    {\n        if(facet === null)\n        {\n            facet = \"\";\n        }\n\n        const m = this._servantMapMap.get(ident);\n        let obj = null;\n        if(m === undefined)\n        {\n            obj = this._defaultServantMap.get(ident.category);\n            if(obj === undefined)\n            {\n                obj = this._defaultServantMap.get(\"\");\n            }\n        }\n        else\n        {\n            obj = m.get(facet);\n        }\n\n        return obj === undefined ? null : obj;\n    }\n\n    findDefaultServant(category)\n    {\n        Debug.assert(this._instance !== null); // Must not be called after destruction.\n\n        const ds = this._defaultServantMap.get(category);\n        return ds === undefined ? null : ds;\n    }\n\n    findAllFacets(ident)\n    {\n        Debug.assert(this._instance !== null); // Must not be called after destruction.\n\n        const m = this._servantMapMap.get(ident);\n        if(m !== undefined)\n        {\n            return new Map(m);\n        }\n\n        return new Map();\n    }\n\n    hasServant(ident)\n    {\n        const m = this._servantMapMap.get(ident);\n        if(m === undefined)\n        {\n            return false;\n        }\n        else\n        {\n            Debug.assert(m.size > 0);\n            return true;\n        }\n    }\n\n    addServantLocator(locator, category)\n    {\n        Debug.assert(this._instance !== null); // Must not be called after destruction.\n\n        if(this._locatorMap.has(category))\n        {\n            const ex = new Ice.AlreadyRegisteredException();\n            ex.id = StringUtil.escapeString(category, \"\", this._instance.toStringMode());\n            ex.kindOfObject = \"servant locator\";\n            throw ex;\n        }\n\n        this._locatorMap.set(category, locator);\n    }\n\n    removeServantLocator(category)\n    {\n        Debug.assert(this._instance !== null); // Must not be called after destruction.\n\n        const l = this._locatorMap.get(category);\n        if(l === undefined)\n        {\n            const ex = new Ice.NotRegisteredException();\n            ex.id = StringUtil.escapeString(category, \"\", this._instance.toStringMode());\n            ex.kindOfObject = \"servant locator\";\n            throw ex;\n        }\n        this._locatorMap.delete(category);\n        return l;\n    }\n\n    findServantLocator(category)\n    {\n        const l = this._locatorMap.get(category);\n        return l === undefined ? null : l;\n    }\n\n    //\n    // Only for use by Ice.ObjectAdapterI.\n    //\n    destroy()\n    {\n        Debug.assert(this._instance !== null); // Must not be called after destruction.\n        const logger = this._instance.initializationData().logger;\n        this._servantMapMap.clear();\n\n        this._defaultServantMap.clear();\n\n        const locatorMap = new Map(this._locatorMap);\n        this._locatorMap.clear();\n        this._instance = null;\n\n        for(const [key, locator] of locatorMap)\n        {\n            try\n            {\n                locator.deactivate(key);\n            }\n            catch(ex)\n            {\n                logger.error(\"exception during locator deactivation:\\nobject adapter: `\" +\n                             this._adapterName + \"'\\nlocator category: `\" + key + \"'\\n\" +\n                             ex.toString());\n            }\n        }\n    }\n}\n\nIce.ServantManager = ServantManager;\nmodule.exports.Ice = Ice;\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/ServantManager.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/SliceChecksumDict.js":
/*!*******************************************************!*\
  !*** ./node_modules/ice/src/Ice/SliceChecksumDict.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n//\n// Ice version 3.7.10\n//\n// <auto-generated>\n//\n// Generated from file `SliceChecksumDict.ice'\n//\n// Warning: do not edit this file.\n//\n// </auto-generated>\n//\n\n/* eslint-disable */\n/* jshint ignore: start */\n\n/* slice2js browser-bundle-skip */\nconst _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\nconst Ice = _ModuleRegistry.module(\"Ice\");\n\nconst Slice = Ice.Slice;\n/* slice2js browser-bundle-skip-end */\n\nSlice.defineDictionary(Ice, \"SliceChecksumDict\", \"SliceChecksumDictHelper\", \"Ice.StringHelper\", \"Ice.StringHelper\", false, undefined, undefined);\n/* slice2js browser-bundle-skip */\nexports.Ice = Ice;\n/* slice2js browser-bundle-skip-end */\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/SliceChecksumDict.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/SocketOperation.js":
/*!*****************************************************!*\
  !*** ./node_modules/ice/src/Ice/SocketOperation.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nconst Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\nIce.SocketOperation =\n{\n    None: 0,\n    Read: 1,\n    Write: 2,\n    Connect: 2 // Same as Write\n};\nmodule.exports.Ice = Ice;\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/SocketOperation.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/Stream.js":
/*!********************************************!*\
  !*** ./node_modules/ice/src/Ice/Stream.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nconst Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\nconst _ModuleRegistry = Ice._ModuleRegistry;\n\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/Buffer */ \"./node_modules/ice/src/Ice/Buffer.js\");\n__webpack_require__(/*! ../Ice/CompactIdRegistry */ \"./node_modules/ice/src/Ice/CompactIdRegistry.js\");\n__webpack_require__(/*! ../Ice/Debug */ \"./node_modules/ice/src/Ice/Debug.js\");\n__webpack_require__(/*! ../Ice/ExUtil */ \"./node_modules/ice/src/Ice/ExUtil.js\");\n__webpack_require__(/*! ../Ice/Exception */ \"./node_modules/ice/src/Ice/Exception.js\");\n__webpack_require__(/*! ../Ice/FormatType */ \"./node_modules/ice/src/Ice/FormatType.js\");\n__webpack_require__(/*! ../Ice/LocalException */ \"./node_modules/ice/src/Ice/LocalException.js\");\n__webpack_require__(/*! ../Ice/Object */ \"./node_modules/ice/src/Ice/Object.js\");\n__webpack_require__(/*! ../Ice/OptionalFormat */ \"./node_modules/ice/src/Ice/OptionalFormat.js\");\n__webpack_require__(/*! ../Ice/Protocol */ \"./node_modules/ice/src/Ice/Protocol.js\");\n__webpack_require__(/*! ../Ice/TraceUtil */ \"./node_modules/ice/src/Ice/TraceUtil.js\");\n__webpack_require__(/*! ../Ice/UnknownSlicedValue */ \"./node_modules/ice/src/Ice/UnknownSlicedValue.js\");\n__webpack_require__(/*! ../Ice/Value */ \"./node_modules/ice/src/Ice/Value.js\");\n__webpack_require__(/*! ../Ice/Version */ \"./node_modules/ice/src/Ice/Version.js\");\n\nconst ArrayUtil = Ice.ArrayUtil;\nconst Debug = Ice.Debug;\nconst ExUtil = Ice.ExUtil;\nconst FormatType = Ice.FormatType;\nconst OptionalFormat = Ice.OptionalFormat;\nconst Protocol = Ice.Protocol;\nconst SlicedData = Ice.SlicedData;\nconst TraceUtil = Ice.TraceUtil;\n\nconst SliceType =\n{\n    NoSlice: 0,\n    ValueSlice: 1,\n    ExceptionSlice: 2\n};\n\n//\n// Number.isNaN polyfill for compatibility with IE\n//\n// see: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN\n//\nNumber.isNaN = Number.isNaN || function(value)\n{\n    return typeof value === \"number\" && isNaN(value);\n};\n\n//\n// InputStream\n//\n\nclass IndirectPatchEntry\n{\n    constructor(index, cb)\n    {\n        this.index = index;\n        this.cb = cb;\n    }\n}\n\nclass EncapsDecoder\n{\n    constructor(stream, encaps, sliceValues, f)\n    {\n        this._stream = stream;\n        this._encaps = encaps;\n        this._sliceValues = sliceValues;\n        this._valueFactoryManager = f;\n        this._patchMap = null; // Lazy initialized, Map<int, Patcher[] >()\n        this._unmarshaledMap = new Map(); // Map<int, Ice.Value>()\n        this._typeIdMap = null; // Lazy initialized, Map<int, String>\n        this._typeIdIndex = 0;\n        this._valueList = null; // Lazy initialized. Ice.Value[]\n    }\n\n    readOptional()\n    {\n        return false;\n    }\n\n    readPendingValues()\n    {\n    }\n\n    readTypeId(isIndex)\n    {\n        if(this._typeIdMap === null) // Lazy initialization\n        {\n            this._typeIdMap = new Map(); // Map<int, String>();\n        }\n\n        let typeId;\n        if(isIndex)\n        {\n            typeId = this._typeIdMap.get(this._stream.readSize());\n            if(typeId === undefined)\n            {\n                throw new Ice.UnmarshalOutOfBoundsException();\n            }\n        }\n        else\n        {\n            typeId = this._stream.readString();\n            this._typeIdMap.set(++this._typeIdIndex, typeId);\n        }\n        return typeId;\n    }\n\n    newInstance(typeId)\n    {\n        //\n        // Try to find a factory registered for the specific type.\n        //\n        let userFactory = this._valueFactoryManager.find(typeId);\n        let v = null;\n\n        if(userFactory !== undefined)\n        {\n            v = userFactory(typeId);\n        }\n\n        //\n        // If that fails, invoke the default factory if one has been\n        // registered.\n        //\n        if(v === null || v === undefined)\n        {\n            userFactory = this._valueFactoryManager.find(\"\");\n            if(userFactory !== undefined)\n            {\n                v = userFactory(typeId);\n            }\n        }\n\n        //\n        // Last chance: try to instantiate the class dynamically.\n        //\n        if(v === null || v === undefined)\n        {\n            v = this._stream.createInstance(typeId);\n        }\n\n        return v;\n    }\n\n    addPatchEntry(index, cb)\n    {\n        Debug.assert(index > 0);\n\n        //\n        // Check if we have already unmarshaled the instance. If that's the case,\n        // just call the callback and we're done.\n        //\n        const obj = this._unmarshaledMap.get(index);\n        if(obj !== undefined && obj !== null)\n        {\n            cb(obj);\n            return;\n        }\n\n        if(this._patchMap === null) // Lazy initialization\n        {\n            this._patchMap = new Map(); // Map<Integer, Patcher[] >();\n        }\n\n        //\n        // Add a patch entry if the instance isn't unmarshaled yet,\n        // the callback will be called when the instance is\n        // unmarshaled.\n        //\n        let l = this._patchMap.get(index);\n        if(l === undefined)\n        {\n            //\n            // We have no outstanding instances to be patched for this\n            // index, so make a new entry in the patch map.\n            //\n            l = []; // ReadValueCallback[]\n            this._patchMap.set(index, l);\n        }\n\n        //\n        // Append a patch entry for this instance.\n        //\n        l.push(cb);\n    }\n\n    unmarshal(index, v)\n    {\n        //\n        // Add the instance to the map of unmarshaled instances, this must\n        // be done before reading the instances (for circular references).\n        //\n        this._unmarshaledMap.set(index, v);\n\n        //\n        // Read the instance.\n        //\n        v._iceRead(this._stream);\n\n        if(this._patchMap !== null)\n        {\n            //\n            // Patch all instances now that the instance is unmarshaled.\n            //\n            const l = this._patchMap.get(index);\n            if(l !== undefined)\n            {\n                Debug.assert(l.length > 0);\n\n                //\n                // Patch all pointers that refer to the instance.\n                //\n                for(let i = 0; i < l.length; ++i)\n                {\n                    l[i](v);\n                }\n\n                //\n                // Clear out the patch map for that index -- there is nothing left\n                // to patch for that index for the time being.\n                //\n                this._patchMap.delete(index);\n            }\n        }\n\n        if((this._patchMap === null || this._patchMap.size === 0) && this._valueList === null)\n        {\n            try\n            {\n                v.ice_postUnmarshal();\n            }\n            catch(ex)\n            {\n                this._stream.instance.initializationData().logger.warning(\"exception raised by ice_postUnmarshal:\\n\" +\n                    ex.toString());\n            }\n        }\n        else\n        {\n            if(this._valueList === null) // Lazy initialization\n            {\n                this._valueList = []; // Ice.Value[]\n            }\n            this._valueList.push(v);\n\n            if(this._patchMap === null || this._patchMap.size === 0)\n            {\n                //\n                // Iterate over the instance list and invoke ice_postUnmarshal on\n                // each instance. We must do this after all instances have been\n                // unmarshaled in order to ensure that any instance data members\n                // have been properly patched.\n                //\n                for(let i = 0; i < this._valueList.length; i++)\n                {\n                    try\n                    {\n                        this._valueList[i].ice_postUnmarshal();\n                    }\n                    catch(ex)\n                    {\n                        this._stream.instance.initializationData().logger.warning(\n                            \"exception raised by ice_postUnmarshal:\\n\" + ex.toString());\n                    }\n                }\n                this._valueList = [];\n            }\n        }\n    }\n}\n\nclass EncapsDecoder10 extends EncapsDecoder\n{\n    constructor(stream, encaps, sliceValues, f)\n    {\n        super(stream, encaps, sliceValues, f);\n        this._sliceType = SliceType.NoSlice;\n    }\n\n    readValue(cb)\n    {\n        Debug.assert(cb !== null);\n\n        //\n        // Instance references are encoded as a negative integer in 1.0.\n        //\n        let index = this._stream.readInt();\n        if(index > 0)\n        {\n            throw new Ice.MarshalException(\"invalid object id\");\n        }\n        index = -index;\n\n        if(index === 0)\n        {\n            cb(null);\n        }\n        else\n        {\n            this.addPatchEntry(index, cb);\n        }\n    }\n\n    throwException()\n    {\n        Debug.assert(this._sliceType === SliceType.NoSlice);\n\n        //\n        // User exceptions with the 1.0 encoding start with a boolean flag\n        // that indicates whether or not the exception has classes.\n        //\n        // This allows reading the pending instances even if some part of\n        // the exception was sliced.\n        //\n        const usesClasses = this._stream.readBool();\n\n        this._sliceType = SliceType.ExceptionSlice;\n        this._skipFirstSlice = false;\n\n        //\n        // Read the first slice header.\n        //\n        this.startSlice();\n        const mostDerivedId = this._typeId;\n        while(true)\n        {\n            const userEx = this._stream.createUserException(this._typeId);\n\n            //\n            // We found the exception.\n            //\n            if(userEx !== null)\n            {\n                userEx._read(this._stream);\n                if(usesClasses)\n                {\n                    this.readPendingValues();\n                }\n                throw userEx;\n\n                // Never reached.\n            }\n\n            //\n            // Slice off what we don't understand.\n            //\n            this.skipSlice();\n            try\n            {\n                this.startSlice();\n            }\n            catch(ex)\n            {\n                //\n                // An oversight in the 1.0 encoding means there is no marker to indicate\n                // the last slice of an exception. As a result, we just try to read the\n                // next type ID, which raises UnmarshalOutOfBoundsException when the\n                // input buffer underflows.\n                //\n                // Set the reason member to a more helpful message.\n                //\n                if(ex instanceof Ice.UnmarshalOutOfBoundsException)\n                {\n                    ex.reason = \"unknown exception type `\" + mostDerivedId + \"'\";\n                }\n                throw ex;\n            }\n        }\n    }\n\n    startInstance(sliceType)\n    {\n        Debug.assert(this._sliceType === sliceType);\n        this._skipFirstSlice = true;\n    }\n\n    endInstance(preserve)\n    {\n        //\n        // Read the Ice::Object slice.\n        //\n        if(this._sliceType === SliceType.ValueSlice)\n        {\n            this.startSlice();\n            const sz = this._stream.readSize(); // For compatibility with the old AFM.\n            if(sz !== 0)\n            {\n                throw new Ice.MarshalException(\"invalid Object slice\");\n            }\n            this.endSlice();\n        }\n\n        this._sliceType = SliceType.NoSlice;\n        return null;\n    }\n\n    startSlice()\n    {\n        //\n        // If first slice, don't read the header, it was already read in\n        // readInstance or throwException to find the factory.\n        //\n        if(this._skipFirstSlice)\n        {\n            this._skipFirstSlice = false;\n            return this._typeId;\n        }\n\n        //\n        // For instances, first read the type ID boolean which indicates\n        // whether or not the type ID is encoded as a string or as an\n        // index. For exceptions, the type ID is always encoded as a\n        // string.\n        //\n        if(this._sliceType === SliceType.ValueSlice) // For exceptions, the type ID is always encoded as a string\n        {\n            const isIndex = this._stream.readBool();\n            this._typeId = this.readTypeId(isIndex);\n        }\n        else\n        {\n            this._typeId = this._stream.readString();\n        }\n\n        this._sliceSize = this._stream.readInt();\n        if(this._sliceSize < 4)\n        {\n            throw new Ice.UnmarshalOutOfBoundsException();\n        }\n\n        return this._typeId;\n    }\n\n    endSlice()\n    {\n    }\n\n    skipSlice()\n    {\n        this._stream.traceSkipSlice(this._typeId, this._sliceType);\n        Debug.assert(this._sliceSize >= 4);\n        this._stream.skip(this._sliceSize - 4);\n    }\n\n    readPendingValues()\n    {\n        let num;\n        do\n        {\n            num = this._stream.readSize();\n            for(let k = num; k > 0; --k)\n            {\n                this.readInstance();\n            }\n        }\n        while(num > 0);\n\n        if(this._patchMap !== null && this._patchMap.size !== 0)\n        {\n            //\n            // If any entries remain in the patch map, the sender has sent an index for an instance, but failed\n            // to supply the instance.\n            //\n            throw new Ice.MarshalException(\"index for class received, but no instance\");\n        }\n    }\n\n    readInstance()\n    {\n        const index = this._stream.readInt();\n        let v = null;\n\n        if(index <= 0)\n        {\n            throw new Ice.MarshalException(\"invalid object id\");\n        }\n\n        this._sliceType = SliceType.ValueSlice;\n        this._skipFirstSlice = false;\n\n        //\n        // Read the first slice header.\n        //\n        this.startSlice();\n        const mostDerivedId = this._typeId;\n        while(true)\n        {\n            //\n            // For the 1.0 encoding, the type ID for the base Object class\n            // marks the last slice.\n            //\n            if(this._typeId == Ice.Value.ice_staticId())\n            {\n                throw new Ice.NoValueFactoryException(\"\", mostDerivedId);\n            }\n\n            v = this.newInstance(this._typeId);\n\n            //\n            // We found a factory, we get out of this loop.\n            //\n            if(v)\n            {\n                break;\n            }\n\n            //\n            // If slicing is disabled, stop unmarshaling.\n            //\n            if(!this._sliceValues)\n            {\n                throw new Ice.NoValueFactoryException(\"no value factory found and slicing is disabled\",\n                                                       this._typeId);\n            }\n\n            //\n            // Slice off what we don't understand.\n            //\n            this.skipSlice();\n            this.startSlice(); // Read next Slice header for next iteration.\n        }\n\n        //\n        // Unmarshal the instance and add it to the map of unmarshaled instances.\n        //\n        this.unmarshal(index, v);\n    }\n}\n\nclass EncapsDecoder11 extends EncapsDecoder\n{\n    constructor(stream, encaps, sliceValues, f, r)\n    {\n        super(stream, encaps, sliceValues, f);\n        this._compactIdResolver = r;\n        this._current = null;\n        this._valueIdIndex = 1;\n    }\n\n    readValue(cb)\n    {\n        const index = this._stream.readSize();\n        if(index < 0)\n        {\n            throw new Ice.MarshalException(\"invalid object id\");\n        }\n        else if(index === 0)\n        {\n            if(cb !== null)\n            {\n                cb(null);\n            }\n        }\n        else if(this._current !== null && (this._current.sliceFlags & Protocol.FLAG_HAS_INDIRECTION_TABLE) !== 0)\n        {\n            //\n            // When reading an instance within a slice and there's an\n            // indirect instance table, always read an indirect reference\n            // that points to an instance from the indirect instance table\n            // marshaled at the end of the Slice.\n            //\n            // Maintain a list of indirect references. Note that the\n            // indirect index starts at 1, so we decrement it by one to\n            // derive an index into the indirection table that we'll read\n            // at the end of the slice.\n            //\n            if(cb !== null)\n            {\n                if(this._current.indirectPatchList === null) // Lazy initialization\n                {\n                    this._current.indirectPatchList = []; // IndirectPatchEntry[]\n                }\n                this._current.indirectPatchList.push(new IndirectPatchEntry(index - 1, cb));\n            }\n        }\n        else\n        {\n            this.readInstance(index, cb);\n        }\n    }\n\n    throwException()\n    {\n        Debug.assert(this._current === null);\n\n        this.push(SliceType.ExceptionSlice);\n\n        //\n        // Read the first slice header.\n        //\n        this.startSlice();\n        const mostDerivedId = this._current.typeId;\n        while(true)\n        {\n\n            const userEx = this._stream.createUserException(this._current.typeId);\n\n            //\n            // We found the exception.\n            //\n            if(userEx !== null)\n            {\n                userEx._read(this._stream);\n                throw userEx;\n\n                // Never reached.\n            }\n\n            //\n            // Slice off what we don't understand.\n            //\n            this.skipSlice();\n\n            if((this._current.sliceFlags & Protocol.FLAG_IS_LAST_SLICE) !== 0)\n            {\n                if(mostDerivedId.indexOf(\"::\") === 0)\n                {\n                    throw new Ice.UnknownUserException(mostDerivedId.substr(2));\n                }\n                throw new Ice.UnknownUserException(mostDerivedId);\n            }\n\n            this.startSlice();\n        }\n    }\n\n    startInstance(sliceType)\n    {\n        Debug.assert(sliceType !== undefined);\n        Debug.assert(this._current.sliceType !== null && this._current.sliceType === sliceType);\n        this._current.skipFirstSlice = true;\n    }\n\n    endInstance(preserve)\n    {\n        let slicedData = null;\n        if(preserve)\n        {\n            slicedData = this.readSlicedData();\n        }\n        if(this._current.slices !== null)\n        {\n            this._current.slices.length = 0; // Clear the array.\n            this._current.indirectionTables.length = 0; // Clear the array.\n        }\n        this._current = this._current.previous;\n        return slicedData;\n    }\n\n    startSlice()\n    {\n        //\n        // If first slice, don't read the header, it was already read in\n        // readInstance or throwException to find the factory.\n        //\n        if(this._current.skipFirstSlice)\n        {\n            this._current.skipFirstSlice = false;\n            return this._current.typeId;\n        }\n\n        this._current.sliceFlags = this._stream.readByte();\n\n        //\n        // Read the type ID, for instance slices the type ID is encoded as a\n        // string or as an index, for exceptions it's always encoded as a\n        // string.\n        //\n        if(this._current.sliceType === SliceType.ValueSlice)\n        {\n            if((this._current.sliceFlags & Protocol.FLAG_HAS_TYPE_ID_COMPACT) ===\n                Protocol.FLAG_HAS_TYPE_ID_COMPACT) // Must be checked 1st!\n            {\n                this._current.typeId = \"\";\n                this._current.compactId = this._stream.readSize();\n            }\n            else if((this._current.sliceFlags & (Protocol.FLAG_HAS_TYPE_ID_INDEX |\n                        Protocol.FLAG_HAS_TYPE_ID_STRING)) !== 0)\n            {\n                this._current.typeId =\n                    this.readTypeId((this._current.sliceFlags & Protocol.FLAG_HAS_TYPE_ID_INDEX) !== 0);\n                this._current.compactId = -1;\n            }\n            else\n            {\n                //\n                // Only the most derived slice encodes the type ID for the compact format.\n                //\n                this._current.typeId = \"\";\n                this._current.compactId = -1;\n            }\n        }\n        else\n        {\n            this._current.typeId = this._stream.readString();\n            this._current.compactId = -1;\n        }\n\n        //\n        // Read the slice size if necessary.\n        //\n        if((this._current.sliceFlags & Protocol.FLAG_HAS_SLICE_SIZE) !== 0)\n        {\n            this._current.sliceSize = this._stream.readInt();\n            if(this._current.sliceSize < 4)\n            {\n                throw new Ice.UnmarshalOutOfBoundsException();\n            }\n        }\n        else\n        {\n            this._current.sliceSize = 0;\n        }\n\n        return this._current.typeId;\n    }\n\n    endSlice()\n    {\n        if((this._current.sliceFlags & Protocol.FLAG_HAS_OPTIONAL_MEMBERS) !== 0)\n        {\n            this._stream.skipOptionals();\n        }\n\n        //\n        // Read the indirection table if one is present and transform the\n        // indirect patch list into patch entries with direct references.\n        //\n        if((this._current.sliceFlags & Protocol.FLAG_HAS_INDIRECTION_TABLE) !== 0)\n        {\n            const indirectionTable = [];\n            //\n            // The table is written as a sequence<size> to conserve space.\n            //\n            const length = this._stream.readAndCheckSeqSize(1);\n            for(let i = 0; i < length; ++i)\n            {\n                indirectionTable[i] = this.readInstance(this._stream.readSize(), null);\n            }\n\n            //\n            // Sanity checks. If there are optional members, it's possible\n            // that not all instance references were read if they are from\n            // unknown optional data members.\n            //\n            if(indirectionTable.length === 0)\n            {\n                throw new Ice.MarshalException(\"empty indirection table\");\n            }\n            if((this._current.indirectPatchList === null || this._current.indirectPatchList.length === 0) &&\n               (this._current.sliceFlags & Protocol.FLAG_HAS_OPTIONAL_MEMBERS) === 0)\n            {\n                throw new Ice.MarshalException(\"no references to indirection table\");\n            }\n\n            //\n            // Convert indirect references into direct references.\n            //\n            if(this._current.indirectPatchList !== null)\n            {\n                this._current.indirectPatchList.forEach(e =>\n                    {\n                        Debug.assert(e.index >= 0);\n                        if(e.index >= indirectionTable.length)\n                        {\n                            throw new Ice.MarshalException(\"indirection out of range\");\n                        }\n                        this.addPatchEntry(indirectionTable[e.index], e.cb);\n                    });\n                this._current.indirectPatchList.length = 0;\n            }\n        }\n    }\n\n    skipSlice()\n    {\n        this._stream.traceSkipSlice(this._current.typeId, this._current.sliceType);\n\n        const start = this._stream.pos;\n\n        if((this._current.sliceFlags & Protocol.FLAG_HAS_SLICE_SIZE) !== 0)\n        {\n            Debug.assert(this._current.sliceSize >= 4);\n            this._stream.skip(this._current.sliceSize - 4);\n        }\n        else if(this._current.sliceType === SliceType.ValueSlice)\n        {\n            throw new Ice.NoValueFactoryException(\"no value factory found and compact format prevents slicing \" +\n                                                  \"(the sender should use the sliced format instead)\",\n                                                  this._current.typeId);\n        }\n        else if(this._current.typeId.indexOf(\"::\") === 0)\n        {\n            throw new Ice.UnknownUserException(this._current.typeId.substring(2));\n        }\n        else\n        {\n            throw new Ice.UnknownUserException(this._current.typeId);\n        }\n\n        //\n        // Preserve this slice.\n        //\n        const info = new Ice.SliceInfo();\n        info.typeId = this._current.typeId;\n        info.compactId = this._current.compactId;\n        info.hasOptionalMembers = (this._current.sliceFlags & Protocol.FLAG_HAS_OPTIONAL_MEMBERS) !== 0;\n        info.isLastSlice = (this._current.sliceFlags & Protocol.FLAG_IS_LAST_SLICE) !== 0;\n\n        const b = this._stream._buf;\n        const end = b.position;\n        let dataEnd = end;\n        if(info.hasOptionalMembers)\n        {\n            //\n            // Don't include the optional member end marker. It will be re-written by\n            // endSlice when the sliced data is re-written.\n            //\n            --dataEnd;\n        }\n\n        b.position = start;\n        info.bytes = b.getArray(dataEnd - start);\n        b.position = end;\n\n        if(this._current.slices === null) // Lazy initialization\n        {\n            this._current.slices = []; // Ice.SliceInfo[]\n            this._current.indirectionTables = []; // int[]\n        }\n\n        //\n        // Read the indirect instance table. We read the instances or their\n        // IDs if the instance is a reference to an already unmarshaled\n        // instance.\n        //\n\n        if((this._current.sliceFlags & Protocol.FLAG_HAS_INDIRECTION_TABLE) !== 0)\n        {\n            const length = this._stream.readAndCheckSeqSize(1);\n            const indirectionTable = [];\n            for(let i = 0; i < length; ++i)\n            {\n                indirectionTable[i] = this.readInstance(this._stream.readSize(), null);\n            }\n            this._current.indirectionTables.push(indirectionTable);\n        }\n        else\n        {\n            this._current.indirectionTables.push(null);\n        }\n\n        this._current.slices.push(info);\n    }\n\n    readOptional(readTag, expectedFormat)\n    {\n        if(this._current === null)\n        {\n            return this._stream.readOptImpl(readTag, expectedFormat);\n        }\n        else if((this._current.sliceFlags & Protocol.FLAG_HAS_OPTIONAL_MEMBERS) !== 0)\n        {\n            return this._stream.readOptImpl(readTag, expectedFormat);\n        }\n        return false;\n    }\n\n    readInstance(index, cb)\n    {\n        Debug.assert(index > 0);\n\n        let v = null;\n\n        if(index > 1)\n        {\n            if(cb !== null)\n            {\n                this.addPatchEntry(index, cb);\n            }\n            return index;\n        }\n\n        this.push(SliceType.ValueSlice);\n\n        //\n        // Get the instance ID before we start reading slices. If some\n        // slices are skipped, the indirect instance table is still read and\n        // might read other instances.\n        //\n        index = ++this._valueIdIndex;\n\n        //\n        // Read the first slice header.\n        //\n        this.startSlice();\n        const mostDerivedId = this._current.typeId;\n        while(true)\n        {\n            if(this._current.compactId >= 0)\n            {\n                //\n                // Translate a compact (numeric) type ID into a string type ID.\n                //\n                this._current.typeId = \"\";\n                if(this._compactIdResolver !== null)\n                {\n                    try\n                    {\n                        this._current.typeId = this._compactIdResolver.call(null, this._current.compactId);\n                    }\n                    catch(ex)\n                    {\n                        if(!(ex instanceof Ice.LocalException))\n                        {\n                            throw new Ice.MarshalException(\"exception in CompactIdResolver for ID \" +\n                                                           this._current.compactId, ex);\n                        }\n                        throw ex;\n                    }\n                }\n\n                if(this._current.typeId.length === 0)\n                {\n                    this._current.typeId = this._stream.resolveCompactId(this._current.compactId);\n                }\n            }\n\n            if(this._current.typeId.length > 0)\n            {\n                v = this.newInstance(this._current.typeId);\n            }\n\n            if(v !== null && v !== undefined)\n            {\n                //\n                // We have an instance, we get out of this loop.\n                //\n                break;\n            }\n\n            //\n            // If slicing is disabled, stop unmarshaling.\n            //\n            if(!this._sliceValues)\n            {\n                throw new Ice.NoValueFactoryException(\"no value factory found and slicing is disabled\",\n                                                       this._current.typeId);\n            }\n\n            //\n            // Slice off what we don't understand.\n            //\n            this.skipSlice();\n\n            //\n            // If this is the last slice, keep the instance as an opaque\n            // UnknownSlicedValue object.\n            //\n            if((this._current.sliceFlags & Protocol.FLAG_IS_LAST_SLICE) !== 0)\n            {\n                v = new Ice.UnknownSlicedValue(mostDerivedId);\n                break;\n            }\n\n            this.startSlice(); // Read next Slice header for next iteration.\n        }\n\n        //\n        // Unmarshal the instance.\n        //\n        this.unmarshal(index, v);\n\n        if(this._current === null && this._patchMap !== null && this._patchMap.size !== 0)\n        {\n            //\n            // If any entries remain in the patch map, the sender has sent an index for an instance, but failed\n            // to supply the instance.\n            //\n            throw new Ice.MarshalException(\"index for class received, but no instance\");\n        }\n\n        if(cb !== null)\n        {\n            cb(v);\n        }\n\n        return index;\n    }\n\n    readSlicedData()\n    {\n        if(this._current.slices === null) // No preserved slices.\n        {\n            return null;\n        }\n\n        //\n        // The _indirectionTables member holds the indirection table for each slice\n        // in _slices.\n        //\n        Debug.assert(this._current.slices.length === this._current.indirectionTables.length);\n        for(let i = 0; i < this._current.slices.length; ++i)\n        {\n            //\n            // We use the \"instances\" list in SliceInfo to hold references\n            // to the target instances. Note that the instances might not have\n            // been read yet in the case of a circular reference to an\n            // enclosing instance.\n            //\n            const table = this._current.indirectionTables[i];\n            const info = this._current.slices[i];\n            info.instances = [];\n            if(table)\n            {\n                for(let j = 0; j < table.length; ++j)\n                {\n                    this.addPatchEntry(table[j], sequencePatcher(info.instances, j, Ice.Value));\n                }\n            }\n        }\n        return new SlicedData(ArrayUtil.clone(this._current.slices));\n    }\n\n    push(sliceType)\n    {\n        if(this._current === null)\n        {\n            this._current = new EncapsDecoder11.InstanceData(null);\n        }\n        else\n        {\n            this._current = !this._current.next ? new EncapsDecoder11.InstanceData(this._current) : this._current.next;\n        }\n        this._current.sliceType = sliceType;\n        this._current.skipFirstSlice = false;\n    }\n}\n\nEncapsDecoder11.InstanceData = class\n{\n    constructor(previous)\n    {\n        if(previous !== null)\n        {\n            previous.next = this;\n        }\n        this.previous = previous;\n        this.next = null;\n\n        // Instance attributes\n        this.sliceType = null;\n        this.skipFirstSlice = false;\n        this.slices = null; // Preserved slices. Ice.SliceInfo[]\n        this.indirectionTables = null; // int[][]\n\n        // Slice attributes\n        this.sliceFlags = 0;\n        this.sliceSize = 0;\n        this.typeId = null;\n        this.compactId = 0;\n        this.indirectPatchList = null; // Lazy initialized, IndirectPatchEntry[]\n    }\n};\n\nconst sequencePatcher = function(seq, index, T)\n{\n    return v =>\n        {\n            if(v !== null && !(v instanceof T))\n            {\n                ExUtil.throwUOE(T.ice_staticId(), v);\n            }\n            seq[index] = v;\n        };\n};\n\nclass ReadEncaps\n{\n    constructor()\n    {\n        this.start = 0;\n        this.sz = 0;\n        this.encoding = null;\n        this.encoding_1_0 = false;\n        this.decoder = null;\n        this.next = null;\n    }\n\n    reset()\n    {\n        this.decoder = null;\n    }\n\n    setEncoding(encoding)\n    {\n        this.encoding = encoding;\n        this.encoding_1_0 = encoding.equals(Ice.Encoding_1_0);\n    }\n}\n\nclass InputStream\n{\n    constructor(arg1, arg2, arg3)\n    {\n        const args =\n        {\n            instance: null,\n            encoding: null,\n            bytes: null,\n            buffer: null\n        };\n        this._checkArgs([arg1, arg2, arg3], args);\n        this._initialize(args);\n    }\n\n    _checkArgs(arr, args)\n    {\n        //\n        // The constructor can accept a variety of argument combinations:\n        //\n        // (<empty>)\n        // (communicator)\n        // (instance)\n        // (encoding)\n        // (array)\n        // (buffer)\n        // (communicator, encoding)\n        // (instance, encoding)\n        // (communicator, array)\n        // (instance, array)\n        // (communicator, buffer)\n        // (instance, buffer)\n        // (communicator, encoding, array)\n        // (instance, encoding, array)\n        // (communicator, encoding, buffer)\n        // (instance, encoding, buffer)\n        // (encoding, array)\n        // (encoding, array)\n        // (encoding, buffer)\n        // (encoding, buffer)\n        //\n        arr.forEach(arg =>\n            {\n                if(arg !== null && arg !== undefined)\n                {\n                    if(arg.constructor === Ice.Communicator)\n                    {\n                        args.instance = arg.instance;\n                    }\n                    else if(arg.constructor === Ice.Instance)\n                    {\n                        args.instance = arg;\n                    }\n                    else if(arg.constructor === Ice.EncodingVersion)\n                    {\n                        args.encoding = arg;\n                    }\n                    else if(arg.constructor === Ice.Buffer)\n                    {\n                        args.buffer = arg;\n                    }\n                    else if(arg.constructor === ArrayBuffer)\n                    {\n                        args.bytes = arg;\n                    }\n                    else if(arg.constructor === Uint8Array)\n                    {\n                        args.bytes = arg.buffer;\n                    }\n                    else\n                    {\n                        throw new Ice.InitializationException(\"unknown argument to InputStream constructor\");\n                    }\n                }\n            });\n        if(args.buffer !== null && args.bytes !== null)\n        {\n            throw new Ice.InitializationException(\"invalid argument to InputStream constructor\");\n        }\n    }\n\n    _initialize(args)\n    {\n        this._instance = args.instance;\n        this._encoding = args.encoding;\n        this._encapsStack = null;\n        this._encapsCache = null;\n        this._closure = null;\n        this._sliceValues = true;\n        this._startSeq = -1;\n        this._sizePos = -1;\n        this._compactIdResolver = null;\n\n        if(this._instance !== null)\n        {\n            if(this._encoding === null)\n            {\n                this._encoding = this._instance.defaultsAndOverrides().defaultEncoding;\n            }\n            this._traceSlicing = this._instance.traceLevels().slicing > 0;\n            this._valueFactoryManager = this._instance.initializationData().valueFactoryManager;\n            this._logger = this._instance.initializationData().logger;\n        }\n        else\n        {\n            if(this._encoding === null)\n            {\n                this._encoding = Protocol.currentEncoding;\n            }\n            this._traceSlicing = false;\n            this._valueFactoryManager = null;\n            this._logger = null;\n        }\n\n        if(args.bytes !== null)\n        {\n            this._buf = new Ice.Buffer(args.bytes);\n        }\n        else if(args.buffer !== null)\n        {\n            this._buf = args.buffer;\n        }\n        else\n        {\n            this._buf = new Ice.Buffer();\n        }\n    }\n\n    //\n    // This function allows this object to be reused, rather than reallocated.\n    //\n    reset()\n    {\n        this._buf.reset();\n        this.clear();\n    }\n\n    clear()\n    {\n        if(this._encapsStack !== null)\n        {\n            Debug.assert(this._encapsStack.next === null);\n            this._encapsStack.next = this._encapsCache;\n            this._encapsCache = this._encapsStack;\n            this._encapsCache.reset();\n            this._encapsStack = null;\n        }\n\n        this._startSeq = -1;\n        this._sliceValues = true;\n    }\n\n    swap(other)\n    {\n        Debug.assert(this._instance === other._instance);\n\n        [other._buf, this._buf] = [this._buf, other._buf];\n        [other._encoding, this._encoding] = [this._encoding, other._encoding];\n        [other._traceSlicing, this._traceSlicing] = [this._traceSlicing, other._traceSlicing];\n        [other._closure, this._closure] = [this._closure, other.closure];\n        [other._sliceValues, this._sliceValues] = [this._sliceValues, other._sliceValues];\n\n        //\n        // Swap is never called for InputStreams that have encapsulations being read/write. However,\n        // encapsulations might still be set in case marshaling or unmarshaling failed. We just\n        // reset the encapsulations if there are still some set.\n        //\n        this.resetEncapsulation();\n        other.resetEncapsulation();\n\n        [other._startSeq, this._startSeq] = [this._startSeq, other._startSeq];\n        [other._minSeqSize, this._minSeqSize] = [this._minSeqSize, other._minSeqSize];\n        [other._sizePos, this._sizePos] = [this._sizePos, other._sizePos];\n        [other._valueFactoryManager, this._valueFactoryManager] = [this._valueFactoryManager, other._valueFactoryManager];\n        [other._logger, this._logger] = [this._logger, other._logger];\n        [other._compactIdResolver, this._compactIdResolver] = [this._compactIdResolver, other._compactIdResolver];\n    }\n\n    resetEncapsulation()\n    {\n        this._encapsStack = null;\n    }\n\n    resize(sz)\n    {\n        this._buf.resize(sz);\n        this._buf.position = sz;\n    }\n\n    startValue()\n    {\n        Debug.assert(this._encapsStack !== null && this._encapsStack.decoder !== null);\n        this._encapsStack.decoder.startInstance(SliceType.ValueSlice);\n    }\n\n    endValue(preserve)\n    {\n        Debug.assert(this._encapsStack !== null && this._encapsStack.decoder !== null);\n        return this._encapsStack.decoder.endInstance(preserve);\n    }\n\n    startException()\n    {\n        Debug.assert(this._encapsStack !== null && this._encapsStack.decoder !== null);\n        this._encapsStack.decoder.startInstance(SliceType.ExceptionSlice);\n    }\n\n    endException(preserve)\n    {\n        Debug.assert(this._encapsStack !== null && this._encapsStack.decoder !== null);\n        return this._encapsStack.decoder.endInstance(preserve);\n    }\n\n    startEncapsulation()\n    {\n        let curr = this._encapsCache;\n        if(curr !== null)\n        {\n            curr.reset();\n            this._encapsCache = this._encapsCache.next;\n        }\n        else\n        {\n            curr = new ReadEncaps();\n        }\n        curr.next = this._encapsStack;\n        this._encapsStack = curr;\n\n        this._encapsStack.start = this._buf.position;\n\n        //\n        // I don't use readSize() for encapsulations, because when creating an encapsulation,\n        // I must know in advance how many bytes the size information will require in the data\n        // stream. If I use an Int, it is always 4 bytes. For readSize(), it could be 1 or 5 bytes.\n        //\n        const sz = this.readInt();\n        if(sz < 6)\n        {\n            throw new Ice.UnmarshalOutOfBoundsException();\n        }\n        if(sz - 4 > this._buf.remaining)\n        {\n            throw new Ice.UnmarshalOutOfBoundsException();\n        }\n        this._encapsStack.sz = sz;\n\n        const encoding = new Ice.EncodingVersion();\n        encoding._read(this);\n        Protocol.checkSupportedEncoding(encoding); // Make sure the encoding is supported.\n        this._encapsStack.setEncoding(encoding);\n\n        return encoding;\n    }\n\n    endEncapsulation()\n    {\n        Debug.assert(this._encapsStack !== null);\n\n        if(!this._encapsStack.encoding_1_0)\n        {\n            this.skipOptionals();\n            if(this._buf.position !== this._encapsStack.start + this._encapsStack.sz)\n            {\n                throw new Ice.EncapsulationException();\n            }\n        }\n        else if(this._buf.position !== this._encapsStack.start + this._encapsStack.sz)\n        {\n            if(this._buf.position + 1 !== this._encapsStack.start + this._encapsStack.sz)\n            {\n                throw new Ice.EncapsulationException();\n            }\n\n            //\n            // Ice version < 3.3 had a bug where user exceptions with\n            // class members could be encoded with a trailing byte\n            // when dispatched with AMD. So we tolerate an extra byte\n            // in the encapsulation.\n            //\n\n            try\n            {\n                this._buf.get();\n            }\n            catch(ex)\n            {\n                throw new Ice.UnmarshalOutOfBoundsException();\n            }\n        }\n\n        const curr = this._encapsStack;\n        this._encapsStack = curr.next;\n        curr.next = this._encapsCache;\n        this._encapsCache = curr;\n        this._encapsCache.reset();\n    }\n\n    skipEmptyEncapsulation()\n    {\n        const sz = this.readInt();\n        if(sz < 6)\n        {\n            throw new Ice.EncapsulationException();\n        }\n        if(sz - 4 > this._buf.remaining)\n        {\n            throw new Ice.UnmarshalOutOfBoundsException();\n        }\n\n        const encoding = new Ice.EncodingVersion();\n        encoding._read(this);\n        Protocol.checkSupportedEncoding(encoding); // Make sure the encoding is supported.\n\n        if(encoding.equals(Ice.Encoding_1_0))\n        {\n            if(sz != 6)\n            {\n                throw new Ice.EncapsulationException();\n            }\n        }\n        else\n        {\n            // Skip the optional content of the encapsulation if we are expecting an\n            // empty encapsulation.\n            this._buf.position = this._buf.position + sz - 6;\n        }\n        return encoding;\n    }\n\n    readEncapsulation(encoding)\n    {\n        Debug.assert(encoding !== undefined);\n        const sz = this.readInt();\n        if(sz < 6)\n        {\n            throw new Ice.UnmarshalOutOfBoundsException();\n        }\n\n        if(sz - 4 > this._buf.remaining)\n        {\n            throw new Ice.UnmarshalOutOfBoundsException();\n        }\n\n        if(encoding !== null)\n        {\n            encoding._read(this);\n            this._buf.position = this._buf.position - 6;\n        }\n        else\n        {\n            this._buf.position = this._buf.position - 4;\n        }\n\n        try\n        {\n            return this._buf.getArray(sz);\n        }\n        catch(ex)\n        {\n            throw new Ice.UnmarshalOutOfBoundsException();\n        }\n    }\n\n    getEncoding()\n    {\n        return this._encapsStack !== null ? this._encapsStack.encoding : this._encoding;\n    }\n\n    getEncapsulationSize()\n    {\n        Debug.assert(this._encapsStack !== null);\n        return this._encapsStack.sz - 6;\n    }\n\n    skipEncapsulation()\n    {\n        const sz = this.readInt();\n        if(sz < 6)\n        {\n            throw new Ice.UnmarshalOutOfBoundsException();\n        }\n        const encoding = new Ice.EncodingVersion();\n        encoding._read(this);\n        try\n        {\n            this._buf.position = this._buf.position + sz - 6;\n        }\n        catch(ex)\n        {\n            throw new Ice.UnmarshalOutOfBoundsException();\n        }\n        return encoding;\n    }\n\n    startSlice() // Returns type ID of next slice\n    {\n        Debug.assert(this._encapsStack !== null && this._encapsStack.decoder !== null);\n        return this._encapsStack.decoder.startSlice();\n    }\n\n    endSlice()\n    {\n        Debug.assert(this._encapsStack !== null && this._encapsStack.decoder !== null);\n        this._encapsStack.decoder.endSlice();\n    }\n\n    skipSlice()\n    {\n        Debug.assert(this._encapsStack !== null && this._encapsStack.decoder !== null);\n        this._encapsStack.decoder.skipSlice();\n    }\n\n    readPendingValues()\n    {\n        if(this._encapsStack !== null && this._encapsStack.decoder !== null)\n        {\n            this._encapsStack.decoder.readPendingValues();\n        }\n        else if((this._encapsStack !== null && this._encapsStack.encoding_1_0) ||\n                (this._encapsStack === null && this._encoding.equals(Ice.Encoding_1_0)))\n        {\n            //\n            // If using the 1.0 encoding and no instances were read, we\n            // still read an empty sequence of pending instances if\n            // requested (i.e.: if this is called).\n            //\n            // This is required by the 1.0 encoding, even if no instances\n            // are written we do marshal an empty sequence if marshaled\n            // data types use classes.\n            //\n            this.skipSize();\n        }\n    }\n\n    readSize()\n    {\n        try\n        {\n            const b = this._buf.get();\n            if(b === 255)\n            {\n                const v = this._buf.getInt();\n                if(v < 0)\n                {\n                    throw new Ice.UnmarshalOutOfBoundsException();\n                }\n                return v;\n            }\n            return b;\n        }\n        catch(ex)\n        {\n            throw new Ice.UnmarshalOutOfBoundsException();\n        }\n    }\n\n    readAndCheckSeqSize(minSize)\n    {\n        const sz = this.readSize();\n\n        if(sz === 0)\n        {\n            return sz;\n        }\n\n        //\n        // The _startSeq variable points to the start of the sequence for which\n        // we expect to read at least _minSeqSize bytes from the stream.\n        //\n        // If not initialized or if we already read more data than _minSeqSize,\n        // we reset _startSeq and _minSeqSize for this sequence (possibly a\n        // top-level sequence or enclosed sequence it doesn't really matter).\n        //\n        // Otherwise, we are reading an enclosed sequence and we have to bump\n        // _minSeqSize by the minimum size that this sequence will  require on\n        // the stream.\n        //\n        // The goal of this check is to ensure that when we start unmarshaling\n        // a new sequence, we check the minimal size of this new sequence against\n        // the estimated remaining buffer size. This estimatation is based on\n        // the minimum size of the enclosing sequences, it's _minSeqSize.\n        //\n        if(this._startSeq === -1 || this._buf.position > (this._startSeq + this._minSeqSize))\n        {\n            this._startSeq = this._buf.position;\n            this._minSeqSize = sz * minSize;\n        }\n        else\n        {\n            this._minSeqSize += sz * minSize;\n        }\n\n        //\n        // If there isn't enough data to read on the stream for the sequence (and\n        // possibly enclosed sequences), something is wrong with the marshaled\n        // data: it's claiming having more data that what is possible to read.\n        //\n        if(this._startSeq + this._minSeqSize > this._buf.limit)\n        {\n            throw new Ice.UnmarshalOutOfBoundsException();\n        }\n\n        return sz;\n    }\n\n    readBlob(sz)\n    {\n        if(this._buf.remaining < sz)\n        {\n            throw new Ice.UnmarshalOutOfBoundsException();\n        }\n        try\n        {\n            return this._buf.getArray(sz);\n        }\n        catch(ex)\n        {\n            throw new Ice.UnmarshalOutOfBoundsException();\n        }\n    }\n\n    readOptional(tag, expectedFormat)\n    {\n        Debug.assert(this._encapsStack !== null);\n        if(this._encapsStack.decoder !== null)\n        {\n            return this._encapsStack.decoder.readOptional(tag, expectedFormat);\n        }\n        return this.readOptImpl(tag, expectedFormat);\n    }\n\n    readOptionalHelper(tag, format, read)\n    {\n        if(this.readOptional(tag, format))\n        {\n            return read.call(this);\n        }\n        else\n        {\n            return undefined;\n        }\n    }\n\n    readByte()\n    {\n        try\n        {\n            return this._buf.get();\n        }\n        catch(ex)\n        {\n            throw new Ice.UnmarshalOutOfBoundsException();\n        }\n    }\n\n    readByteSeq()\n    {\n        return this._buf.getArray(this.readAndCheckSeqSize(1));\n    }\n\n    readBool()\n    {\n        try\n        {\n            return this._buf.get() === 1;\n        }\n        catch(ex)\n        {\n            throw new Ice.UnmarshalOutOfBoundsException();\n        }\n    }\n\n    readShort()\n    {\n        try\n        {\n            return this._buf.getShort();\n        }\n        catch(ex)\n        {\n            throw new Ice.UnmarshalOutOfBoundsException();\n        }\n    }\n\n    readInt()\n    {\n        try\n        {\n            return this._buf.getInt();\n        }\n        catch(ex)\n        {\n            throw new Ice.UnmarshalOutOfBoundsException();\n        }\n    }\n\n    readLong()\n    {\n        try\n        {\n            return this._buf.getLong();\n        }\n        catch(ex)\n        {\n            throw new Ice.UnmarshalOutOfBoundsException();\n        }\n    }\n\n    readFloat()\n    {\n        try\n        {\n            return this._buf.getFloat();\n        }\n        catch(ex)\n        {\n            throw new Ice.UnmarshalOutOfBoundsException();\n        }\n    }\n\n    readDouble()\n    {\n        try\n        {\n            return this._buf.getDouble();\n        }\n        catch(ex)\n        {\n            throw new Ice.UnmarshalOutOfBoundsException();\n        }\n    }\n\n    readString()\n    {\n        const len = this.readSize();\n        if(len === 0)\n        {\n            return \"\";\n        }\n        //\n        // Check the buffer has enough bytes to read.\n        //\n        if(this._buf.remaining < len)\n        {\n            throw new Ice.UnmarshalOutOfBoundsException();\n        }\n\n        try\n        {\n            return this._buf.getString(len);\n        }\n        catch(ex)\n        {\n            throw new Ice.UnmarshalOutOfBoundsException();\n        }\n    }\n\n    readProxy(type)\n    {\n        return this._instance.proxyFactory().streamToProxy(this, type);\n    }\n\n    readOptionalProxy(tag, type)\n    {\n        if(this.readOptional(tag, OptionalFormat.FSize))\n        {\n            this.skip(4);\n            return this.readProxy(type);\n        }\n        else\n        {\n            return undefined;\n        }\n    }\n\n    readEnum(T)\n    {\n        let v;\n        if(this.getEncoding().equals(Ice.Encoding_1_0))\n        {\n            if(T.maxValue < 127)\n            {\n                v = this.readByte();\n            }\n            else if(T.maxValue < 32767)\n            {\n                v = this.readShort();\n            }\n            else\n            {\n                v = this.readInt();\n            }\n        }\n        else\n        {\n            v = this.readSize();\n        }\n\n        const e = T.valueOf(v);\n        if(e === undefined)\n        {\n            throw new Ice.MarshalException(\"enumerator value \" + v + \" is out of range\");\n        }\n        return e;\n    }\n\n    readOptionalEnum(tag, T)\n    {\n        if(this.readOptional(tag, OptionalFormat.Size))\n        {\n            return this.readEnum(T);\n        }\n        else\n        {\n            return undefined;\n        }\n    }\n\n    readValue(cb, T)\n    {\n        this.initEncaps();\n        this._encapsStack.decoder.readValue(\n            cb === null ? null : obj =>\n            {\n                if(obj !== null && !(obj instanceof T))\n                {\n                    ExUtil.throwUOE(T.ice_staticId(), obj);\n                }\n                cb(obj);\n            });\n    }\n\n    readOptionalValue(tag, cb, T)\n    {\n        if(this.readOptional(tag, OptionalFormat.Class))\n        {\n            this.readValue(cb, T);\n        }\n        else\n        {\n            cb(undefined);\n        }\n    }\n\n    throwException()\n    {\n        this.initEncaps();\n        this._encapsStack.decoder.throwException();\n    }\n\n    readOptImpl(readTag, expectedFormat)\n    {\n        if(this.isEncoding_1_0())\n        {\n            return false; // Optional members aren't supported with the 1.0 encoding.\n        }\n\n        while(true)\n        {\n            if(this._buf.position >= this._encapsStack.start + this._encapsStack.sz)\n            {\n                return false; // End of encapsulation also indicates end of optionals.\n            }\n\n            const v = this.readByte();\n\n            if(v === Protocol.OPTIONAL_END_MARKER)\n            {\n                this._buf.position -= 1; // Rewind.\n                return false;\n            }\n\n            const format = OptionalFormat.valueOf(v & 0x07); // First 3 bits.\n            let tag = v >> 3;\n            if(tag === 30)\n            {\n                tag = this.readSize();\n            }\n\n            if(tag > readTag)\n            {\n                const offset = tag < 30 ? 1 : (tag < 255 ? 2 : 6); // Rewind\n                this._buf.position -= offset;\n                return false; // No optional data members with the requested tag.\n            }\n            else if(tag < readTag)\n            {\n                this.skipOptional(format); // Skip optional data members\n            }\n            else\n            {\n                if(format !== expectedFormat)\n                {\n                    throw new Ice.MarshalException(\"invalid optional data member `\" + tag + \"': unexpected format\");\n                }\n                return true;\n            }\n        }\n    }\n\n    skipOptional(format)\n    {\n        switch(format)\n        {\n            case OptionalFormat.F1:\n            {\n                this.skip(1);\n                break;\n            }\n            case OptionalFormat.F2:\n            {\n                this.skip(2);\n                break;\n            }\n            case OptionalFormat.F4:\n            {\n                this.skip(4);\n                break;\n            }\n            case OptionalFormat.F8:\n            {\n                this.skip(8);\n                break;\n            }\n            case OptionalFormat.Size:\n            {\n                this.skipSize();\n                break;\n            }\n            case OptionalFormat.VSize:\n            {\n                this.skip(this.readSize());\n                break;\n            }\n            case OptionalFormat.FSize:\n            {\n                this.skip(this.readInt());\n                break;\n            }\n            case OptionalFormat.Class:\n            {\n                this.readValue(null, Ice.Value);\n                break;\n            }\n            default:\n            {\n                Debug.assert(false);\n                break;\n            }\n        }\n    }\n\n    skipOptionals()\n    {\n        //\n        // Skip remaining un-read optional members.\n        //\n        while(true)\n        {\n            if(this._buf.position >= this._encapsStack.start + this._encapsStack.sz)\n            {\n                return; // End of encapsulation also indicates end of optionals.\n            }\n\n            const b = this.readByte();\n            const v = b < 0 ? b + 256 : b;\n            if(v === Protocol.OPTIONAL_END_MARKER)\n            {\n                return;\n            }\n\n            const format = OptionalFormat.valueOf(v & 0x07); // Read first 3 bits.\n            if((v >> 3) === 30)\n            {\n                this.skipSize();\n            }\n            this.skipOptional(format);\n        }\n    }\n\n    skip(size)\n    {\n        if(size > this._buf.remaining)\n        {\n            throw new Ice.UnmarshalOutOfBoundsException();\n        }\n        this._buf.position += size;\n    }\n\n    skipSize()\n    {\n        const b = this.readByte();\n        if(b === 255)\n        {\n            this.skip(4);\n        }\n    }\n\n    isEmpty()\n    {\n        return this._buf.empty();\n    }\n\n    expand(n)\n    {\n        this._buf.expand(n);\n    }\n\n    createInstance(id)\n    {\n        let obj = null;\n        try\n        {\n            const typeId = id.length > 2 ? id.substr(2).replace(/::/g, \".\") : \"\";\n            const Class = _ModuleRegistry.type(typeId);\n            if(Class !== undefined)\n            {\n                obj = new Class();\n            }\n        }\n        catch(ex)\n        {\n            throw new Ice.NoValueFactoryException(\"no value factory\", id, ex);\n        }\n\n        return obj;\n    }\n\n    createUserException(id)\n    {\n        let userEx = null;\n        try\n        {\n            const typeId = id.length > 2 ? id.substr(2).replace(/::/g, \".\") : \"\";\n            const Class = _ModuleRegistry.type(typeId);\n            if(Class !== undefined)\n            {\n                userEx = new Class();\n            }\n        }\n        catch(ex)\n        {\n            throw new Ice.MarshalException(ex);\n        }\n        return userEx;\n    }\n\n    resolveCompactId(compactId)\n    {\n        const typeId = Ice.CompactIdRegistry.get(compactId);\n        return typeId === undefined ? \"\" : typeId;\n    }\n\n    isEncoding_1_0()\n    {\n        return this._encapsStack !== null ? this._encapsStack.encoding_1_0 : this._encoding.equals(Ice.Encoding_1_0);\n    }\n\n    initEncaps()\n    {\n        if(this._encapsStack === null) // Lazy initialization\n        {\n            this._encapsStack = this._encapsCache;\n            if(this._encapsStack !== null)\n            {\n                this._encapsCache = this._encapsCache.next;\n            }\n            else\n            {\n                this._encapsStack = new ReadEncaps();\n            }\n            this._encapsStack.setEncoding(this._encoding);\n            this._encapsStack.sz = this._buf.limit;\n        }\n\n        if(this._encapsStack.decoder === null) // Lazy initialization.\n        {\n            if(this._encapsStack.encoding_1_0)\n            {\n                this._encapsStack.decoder = new EncapsDecoder10(this, this._encapsStack, this._sliceValues,\n                                                                this._valueFactoryManager);\n            }\n            else\n            {\n                this._encapsStack.decoder = new EncapsDecoder11(this, this._encapsStack, this._sliceValues,\n                                                                this._valueFactoryManager, this._compactIdResolver);\n            }\n        }\n    }\n\n    traceSkipSlice(typeId, sliceType)\n    {\n        if(this._traceSlicing && this._logger !== null)\n        {\n            TraceUtil.traceSlicing(sliceType === SliceType.ExceptionSlice ? \"exception\" : \"object\", typeId, \"Slicing\",\n                                   this._logger);\n        }\n    }\n\n    //\n    // Sets the value factory manager to use when marshaling value instances. If the stream\n    // was initialized with a communicator, the communicator's value factory manager will\n    // be used by default.\n    //\n    get valueFactoryManager()\n    {\n        return this._valueFactoryManager;\n    }\n\n    set valueFactoryManager(value)\n    {\n        this._valueFactoryManager = value !== undefined ? value : null;\n    }\n\n    //\n    // Sets the logger to use when logging trace messages. If the stream\n    // was initialized with a communicator, the communicator's logger will\n    // be used by default.\n    //\n    get logger()\n    {\n        return this._logger;\n    }\n\n    set logger(value)\n    {\n        this._logger = value !== undefined ? value : null;\n    }\n\n    //\n    // Sets the compact ID resolver to use when unmarshaling value and exception\n    // instances. If the stream was initialized with a communicator, the communicator's\n    // resolver will be used by default.\n    //\n    get compactIdResolver()\n    {\n        return this._compactIdResolver;\n    }\n\n    set compactIdResolver(value)\n    {\n        this._compactIdResolver = value !== undefined ? value : null;\n    }\n\n    //\n    // Determines the behavior of the stream when extracting instances of Slice classes.\n    // A instance is \"sliced\" when a factory cannot be found for a Slice type ID.\n    // The stream's default behavior is to slice instances.\n    //\n    // If slicing is disabled and the stream encounters a Slice type ID\n    // during decoding for which no value factory is installed, it raises\n    // NoValueFactoryException.\n    //\n    get sliceValues()\n    {\n        return this._sliceValues;\n    }\n\n    set sliceValues(value)\n    {\n        this._sliceValues = value;\n    }\n\n    //\n    // Determines whether the stream logs messages about slicing instances of Slice values.\n    //\n    get traceSlicing()\n    {\n        return this._traceSlicing;\n    }\n\n    set traceSlicing(value)\n    {\n        this._traceSlicing = value;\n    }\n\n    get pos()\n    {\n        return this._buf.position;\n    }\n\n    set pos(value)\n    {\n        this._buf.position = value;\n    }\n\n    get size()\n    {\n        return this._buf.limit;\n    }\n\n    get instance()\n    {\n        return this._instance;\n    }\n\n    get closure()\n    {\n        return this._type;\n    }\n\n    set closure(value)\n    {\n        this._type = value;\n    }\n\n    get buffer()\n    {\n        return this._buf;\n    }\n}\n\n//\n// OutputStream\n//\n\nclass EncapsEncoder\n{\n    constructor(stream, encaps)\n    {\n        this._stream = stream;\n        this._encaps = encaps;\n        this._marshaledMap = new Map(); // Map<Ice.Value, int>;\n        this._typeIdMap = null; // Lazy initialized. Map<String, int>\n        this._typeIdIndex = 0;\n    }\n\n    writeOptional()\n    {\n        return false;\n    }\n\n    writePendingValues()\n    {\n        return undefined;\n    }\n\n    registerTypeId(typeId)\n    {\n        if(this._typeIdMap === null) // Lazy initialization\n        {\n            this._typeIdMap = new Map(); // Map<String, int>\n        }\n\n        const p = this._typeIdMap.get(typeId);\n        if(p !== undefined)\n        {\n            return p;\n        }\n        else\n        {\n            this._typeIdMap.set(typeId, ++this._typeIdIndex);\n            return -1;\n        }\n    }\n}\n\nclass EncapsEncoder10 extends EncapsEncoder\n{\n    constructor(stream, encaps)\n    {\n        super(stream, encaps);\n        this._sliceType = SliceType.NoSlice;\n        this._writeSlice = 0; // Position of the slice data members\n        this._valueIdIndex = 0;\n        this._toBeMarshaledMap = new Map(); // Map<Ice.Value, Integer>();\n    }\n\n    writeValue(v)\n    {\n        Debug.assert(v !== undefined);\n        //\n        // Object references are encoded as a negative integer in 1.0.\n        //\n        if(v !== null && v !== undefined)\n        {\n            this._stream.writeInt(-this.registerValue(v));\n        }\n        else\n        {\n            this._stream.writeInt(0);\n        }\n    }\n\n    writeException(v)\n    {\n        Debug.assert(v !== null && v !== undefined);\n        //\n        // User exception with the 1.0 encoding start with a boolean\n        // flag that indicates whether or not the exception uses\n        // classes.\n        //\n        // This allows reading the pending instances even if some part of\n        // the exception was sliced.\n        //\n        const usesClasses = v._usesClasses();\n        this._stream.writeBool(usesClasses);\n        v._write(this._stream);\n        if(usesClasses)\n        {\n            this.writePendingValues();\n        }\n    }\n\n    startInstance(sliceType)\n    {\n        this._sliceType = sliceType;\n    }\n\n    endInstance()\n    {\n        if(this._sliceType === SliceType.ValueSlice)\n        {\n            //\n            // Write the Object slice.\n            //\n            this.startSlice(Ice.Value.ice_staticId(), -1, true);\n            this._stream.writeSize(0); // For compatibility with the old AFM.\n            this.endSlice();\n        }\n        this._sliceType = SliceType.NoSlice;\n    }\n\n    startSlice(typeId)\n    {\n        //\n        // For instance slices, encode a boolean to indicate how the type ID\n        // is encoded and the type ID either as a string or index. For\n        // exception slices, always encode the type ID as a string.\n        //\n        if(this._sliceType === SliceType.ValueSlice)\n        {\n            const index = this.registerTypeId(typeId);\n            if(index < 0)\n            {\n                this._stream.writeBool(false);\n                this._stream.writeString(typeId);\n            }\n            else\n            {\n                this._stream.writeBool(true);\n                this._stream.writeSize(index);\n            }\n        }\n        else\n        {\n            this._stream.writeString(typeId);\n        }\n\n        this._stream.writeInt(0); // Placeholder for the slice length.\n\n        this._writeSlice = this._stream.pos;\n    }\n\n    endSlice()\n    {\n        //\n        // Write the slice length.\n        //\n        const sz = this._stream.pos - this._writeSlice + 4;\n        this._stream.rewriteInt(sz, this._writeSlice - 4);\n    }\n\n    writePendingValues()\n    {\n        const writeCB = (value, key) =>\n            {\n                //\n                // Ask the instance to marshal itself. Any new class\n                // instances that are triggered by the classes marshaled\n                // are added to toBeMarshaledMap.\n                //\n                this._stream.writeInt(value);\n                try\n                {\n                    key.ice_preMarshal();\n                }\n                catch(ex)\n                {\n                    this._stream.instance.initializationData().logger.warning(\n                        \"exception raised by ice_preMarshal:\\n\" + ex.toString());\n                }\n                key._iceWrite(this._stream);\n            };\n\n        while(this._toBeMarshaledMap.size > 0)\n        {\n            //\n            // Consider the to be marshalled instances as marshalled now,\n            // this is necessary to avoid adding again the \"to be\n            // marshalled instances\" into _toBeMarshaledMap while writing\n            // instances.\n            //\n            this._toBeMarshaledMap.forEach((value, key) => this._marshaledMap.set(key, value));\n\n            const savedMap = this._toBeMarshaledMap;\n            this._toBeMarshaledMap = new Map(); // Map<Ice.Value, int>();\n            this._stream.writeSize(savedMap.size);\n            savedMap.forEach(writeCB);\n        }\n        this._stream.writeSize(0); // Zero marker indicates end of sequence of sequences of instances.\n    }\n\n    registerValue(v)\n    {\n        Debug.assert(v !== null);\n\n        //\n        // Look for this instance in the to-be-marshaled map.\n        //\n        let p = this._toBeMarshaledMap.get(v);\n        if(p !== undefined)\n        {\n            return p;\n        }\n\n        //\n        // Didn't find it, try the marshaled map next.\n        //\n        p = this._marshaledMap.get(v);\n        if(p !== undefined)\n        {\n            return p;\n        }\n\n        //\n        // We haven't seen this instance previously, create a new\n        // index, and insert it into the to-be-marshaled map.\n        //\n        this._toBeMarshaledMap.set(v, ++this._valueIdIndex);\n        return this._valueIdIndex;\n    }\n}\n\nclass EncapsEncoder11 extends EncapsEncoder\n{\n    constructor(stream, encaps)\n    {\n        super(stream, encaps);\n        this._current = null;\n        this._valueIdIndex = 1;\n    }\n\n    writeValue(v)\n    {\n        Debug.assert(v !== undefined);\n        if(v === null || v === undefined)\n        {\n            this._stream.writeSize(0);\n        }\n        else if(this._current !== null && this._encaps.format === FormatType.SlicedFormat)\n        {\n            if(this._current.indirectionTable === null) // Lazy initialization\n            {\n                this._current.indirectionTable = []; // Ice.Value[]\n                this._current.indirectionMap = new Map(); // Map<Ice.Value, int>\n            }\n\n            //\n            // If writing an instance within a slice and using the sliced\n            // format, write an index from the instance indirection\n            // table. The indirect instance table is encoded at the end of\n            // each slice and is always read (even if the Slice is\n            // unknown).\n            //\n            const index = this._current.indirectionMap.get(v);\n            if(index === undefined)\n            {\n                this._current.indirectionTable.push(v);\n                const idx = this._current.indirectionTable.length; // Position + 1 (0 is reserved for nil)\n                this._current.indirectionMap.set(v, idx);\n                this._stream.writeSize(idx);\n            }\n            else\n            {\n                this._stream.writeSize(index);\n            }\n        }\n        else\n        {\n            this.writeInstance(v); // Write the instance or a reference if already marshaled.\n        }\n    }\n\n    writePendingValues()\n    {\n        return undefined;\n    }\n\n    writeException(v)\n    {\n        Debug.assert(v !== null && v !== undefined);\n        v._write(this._stream);\n    }\n\n    startInstance(sliceType, data)\n    {\n        if(this._current === null)\n        {\n            this._current = new EncapsEncoder11.InstanceData(null);\n        }\n        else\n        {\n            this._current =\n                (this._current.next === null) ? new EncapsEncoder11.InstanceData(this._current) : this._current.next;\n        }\n        this._current.sliceType = sliceType;\n        this._current.firstSlice = true;\n\n        if(data !== null && data !== undefined)\n        {\n            this.writeSlicedData(data);\n        }\n    }\n\n    endInstance()\n    {\n        this._current = this._current.previous;\n    }\n\n    startSlice(typeId, compactId, last)\n    {\n        Debug.assert((this._current.indirectionTable === null || this._current.indirectionTable.length === 0) &&\n                     (this._current.indirectionMap === null || this._current.indirectionMap.size === 0));\n\n        this._current.sliceFlagsPos = this._stream.pos;\n\n        this._current.sliceFlags = 0;\n        if(this._encaps.format === FormatType.SlicedFormat)\n        {\n            // Encode the slice size if using the sliced format.\n            this._current.sliceFlags |= Protocol.FLAG_HAS_SLICE_SIZE;\n        }\n        if(last)\n        {\n            this._current.sliceFlags |= Protocol.FLAG_IS_LAST_SLICE; // This is the last slice.\n        }\n\n        this._stream.writeByte(0); // Placeholder for the slice flags\n\n        //\n        // For instance slices, encode the flag and the type ID either as a\n        // string or index. For exception slices, always encode the type\n        // ID a string.\n        //\n        if(this._current.sliceType === SliceType.ValueSlice)\n        {\n            //\n            // Encode the type ID (only in the first slice for the compact\n            // encoding).\n            //\n            if(this._encaps.format === FormatType.SlicedFormat || this._current.firstSlice)\n            {\n                if(compactId >= 0)\n                {\n                    this._current.sliceFlags |= Protocol.FLAG_HAS_TYPE_ID_COMPACT;\n                    this._stream.writeSize(compactId);\n                }\n                else\n                {\n                    const index = this.registerTypeId(typeId);\n                    if(index < 0)\n                    {\n                        this._current.sliceFlags |= Protocol.FLAG_HAS_TYPE_ID_STRING;\n                        this._stream.writeString(typeId);\n                    }\n                    else\n                    {\n                        this._current.sliceFlags |= Protocol.FLAG_HAS_TYPE_ID_INDEX;\n                        this._stream.writeSize(index);\n                    }\n                }\n            }\n        }\n        else\n        {\n            this._stream.writeString(typeId);\n        }\n\n        if((this._current.sliceFlags & Protocol.FLAG_HAS_SLICE_SIZE) !== 0)\n        {\n            this._stream.writeInt(0); // Placeholder for the slice length.\n        }\n\n        this._current.writeSlice = this._stream.pos;\n        this._current.firstSlice = false;\n    }\n\n    endSlice()\n    {\n        //\n        // Write the optional member end marker if some optional members\n        // were encoded. Note that the optional members are encoded before\n        // the indirection table and are included in the slice size.\n        //\n        if((this._current.sliceFlags & Protocol.FLAG_HAS_OPTIONAL_MEMBERS) !== 0)\n        {\n            this._stream.writeByte(Protocol.OPTIONAL_END_MARKER);\n        }\n\n        //\n        // Write the slice length if necessary.\n        //\n        if((this._current.sliceFlags & Protocol.FLAG_HAS_SLICE_SIZE) !== 0)\n        {\n            const sz = this._stream.pos - this._current.writeSlice + 4;\n            this._stream.rewriteInt(sz, this._current.writeSlice - 4);\n        }\n\n        //\n        // Only write the indirection table if it contains entries.\n        //\n        if(this._current.indirectionTable !== null && this._current.indirectionTable.length !== 0)\n        {\n            Debug.assert(this._encaps.format === FormatType.SlicedFormat);\n            this._current.sliceFlags |= Protocol.FLAG_HAS_INDIRECTION_TABLE;\n\n            //\n            // Write the indirection instance table.\n            //\n            this._stream.writeSize(this._current.indirectionTable.length);\n            this._current.indirectionTable.forEach(o => this.writeInstance(o));\n            this._current.indirectionTable.length = 0; // Faster way to clean array in JavaScript\n            this._current.indirectionMap.clear();\n        }\n\n        //\n        // Finally, update the slice flags.\n        //\n        this._stream.rewriteByte(this._current.sliceFlags, this._current.sliceFlagsPos);\n    }\n\n    writeOptional(tag, format)\n    {\n        if(this._current === null)\n        {\n            return this._stream.writeOptImpl(tag, format);\n        }\n\n        if(this._stream.writeOptImpl(tag, format))\n        {\n            this._current.sliceFlags |= Protocol.FLAG_HAS_OPTIONAL_MEMBERS;\n            return true;\n        }\n\n        return false;\n    }\n\n    writeSlicedData(slicedData)\n    {\n        Debug.assert(slicedData !== null && slicedData !== undefined);\n\n        //\n        // We only remarshal preserved slices if we are using the sliced\n        // format. Otherwise, we ignore the preserved slices, which\n        // essentially \"slices\" the instance into the most-derived type\n        // known by the sender.\n        //\n        if(this._encaps.format !== FormatType.SlicedFormat)\n        {\n            return;\n        }\n\n        slicedData.slices.forEach(info =>\n            {\n                this.startSlice(info.typeId, info.compactId, info.isLastSlice);\n\n                //\n                // Write the bytes associated with this slice.\n                //\n                this._stream.writeBlob(info.bytes);\n\n                if(info.hasOptionalMembers)\n                {\n                    this._current.sliceFlags |= Protocol.FLAG_HAS_OPTIONAL_MEMBERS;\n                }\n\n                //\n                // Make sure to also re-write the instance indirection table.\n                //\n                if(info.instances !== null && info.instances.length > 0)\n                {\n                    if(this._current.indirectionTable === null) // Lazy initialization\n                    {\n                        this._current.indirectionTable = []; // Ice.Value[]\n                        this._current.indirectionMap = new Map(); // Map<Ice.Value, int>\n                    }\n\n                    info.instances.forEach(instance => this._current.indirectionTable.push(instance));\n                }\n\n                this.endSlice();\n            });\n    }\n\n    writeInstance(v)\n    {\n        Debug.assert(v !== null && v !== undefined);\n\n        //\n        // If the instance was already marshaled, just write it's ID.\n        //\n        const p = this._marshaledMap.get(v);\n        if(p !== undefined)\n        {\n            this._stream.writeSize(p);\n            return;\n        }\n\n        //\n        // We haven't seen this instance previously, create a new ID,\n        // insert it into the marshaled map, and write the instance.\n        //\n        this._marshaledMap.set(v, ++this._valueIdIndex);\n\n        try\n        {\n            v.ice_preMarshal();\n        }\n        catch(ex)\n        {\n            this._stream.instance.initializationData().logger.warning(\"exception raised by ice_preMarshal:\\n\" +\n                                                                      ex.toString());\n        }\n\n        this._stream.writeSize(1); // Object instance marker.\n        v._iceWrite(this._stream);\n    }\n}\n\nEncapsEncoder11.InstanceData = class\n{\n    constructor(previous)\n    {\n        Debug.assert(previous !== undefined);\n        if(previous !== null)\n        {\n            previous.next = this;\n        }\n        this.previous = previous;\n        this.next = null;\n\n        // Instance attributes\n        this.sliceType = null;\n        this.firstSlice = false;\n\n        // Slice attributes\n        this.sliceFlags = 0;\n        this.writeSlice = 0; // Position of the slice data members\n        this.sliceFlagsPos = 0; // Position of the slice flags\n        this.indirectionTable = null; // Ice.Value[]\n        this.indirectionMap = null; // Map<Ice.Value, int>\n    }\n};\n\nclass WriteEncaps\n{\n    constructor()\n    {\n        this.start = 0;\n        this.format = FormatType.DefaultFormat;\n        this.encoding = null;\n        this.encoding_1_0 = false;\n        this.encoder = null;\n        this.next = null;\n    }\n\n    reset()\n    {\n        this.encoder = null;\n    }\n\n    setEncoding(encoding)\n    {\n        this.encoding = encoding;\n        this.encoding_1_0 = encoding.equals(Ice.Encoding_1_0);\n    }\n}\n\nclass OutputStream\n{\n    constructor(arg1, arg2)\n    {\n        this._instance = null;\n        this._encoding = null;\n\n        if(arg1 !== undefined && arg1 !== null)\n        {\n            if(arg1.constructor == Ice.Communicator)\n            {\n                this._instance = arg1.instance;\n            }\n            else if(arg1.constructor == Ice.Instance)\n            {\n                this._instance = arg1;\n            }\n            else if(arg1.constructor == Ice.EncodingVersion)\n            {\n                this._encoding = arg1;\n            }\n            else\n            {\n                throw new Ice.InitializationException(\"unknown argument to OutputStream constructor\");\n            }\n        }\n\n        if(arg2 !== undefined && arg2 !== null)\n        {\n            if(arg2.constructor == Ice.EncodingVersion)\n            {\n                this._encoding = arg2;\n            }\n            else\n            {\n                throw new Ice.InitializationException(\"unknown argument to OutputStream constructor\");\n            }\n        }\n\n        this._buf = new Ice.Buffer();\n\n        this._closure = null;\n\n        this._encapsStack = null;\n        this._encapsCache = null;\n\n        if(this._instance !== null)\n        {\n            if(this._encoding === null)\n            {\n                this._encoding = this._instance.defaultsAndOverrides().defaultEncoding;\n            }\n            this._format = this._instance.defaultsAndOverrides().defaultFormat;\n        }\n        else\n        {\n            if(this._encoding === null)\n            {\n                this._encoding = Protocol.currentEncoding;\n            }\n            this._format = FormatType.CompactFormat;\n        }\n    }\n\n    //\n    // This function allows this object to be reused, rather than reallocated.\n    //\n    reset()\n    {\n        this._buf.reset();\n        this.clear();\n    }\n\n    clear()\n    {\n        if(this._encapsStack !== null)\n        {\n            Debug.assert(this._encapsStack.next);\n            this._encapsStack.next = this._encapsCache;\n            this._encapsCache = this._encapsStack;\n            this._encapsCache.reset();\n            this._encapsStack = null;\n        }\n    }\n\n    finished()\n    {\n        return this.prepareWrite().getArray(this.size);\n    }\n\n    swap(other)\n    {\n        Debug.assert(this._instance === other._instance);\n\n        [other._buf, this._buf] = [this._buf, other._buf];\n        [other._encoding, this._encoding] = [this._encoding, other._encoding];\n        [other._closure, this._closure] = [this._closure, other._closure];\n\n        //\n        // Swap is never called for streams that have encapsulations being written. However,\n        // encapsulations might still be set in case marshaling failed. We just\n        // reset the encapsulations if there are still some set.\n        //\n        this.resetEncapsulation();\n        other.resetEncapsulation();\n    }\n\n    resetEncapsulation()\n    {\n        this._encapsStack = null;\n    }\n\n    resize(sz)\n    {\n        this._buf.resize(sz);\n        this._buf.position = sz;\n    }\n\n    prepareWrite()\n    {\n        this._buf.position = 0;\n        return this._buf;\n    }\n\n    startValue(data)\n    {\n        Debug.assert(this._encapsStack !== null && this._encapsStack.encoder !== null);\n        this._encapsStack.encoder.startInstance(SliceType.ValueSlice, data);\n    }\n\n    endValue()\n    {\n        Debug.assert(this._encapsStack !== null && this._encapsStack.encoder !== null);\n        this._encapsStack.encoder.endInstance();\n    }\n\n    startException(data)\n    {\n        Debug.assert(this._encapsStack !== null && this._encapsStack.encoder !== null);\n        this._encapsStack.encoder.startInstance(SliceType.ExceptionSlice, data);\n    }\n\n    endException()\n    {\n        Debug.assert(this._encapsStack !== null && this._encapsStack.encoder !== null);\n        this._encapsStack.encoder.endInstance();\n    }\n\n    startEncapsulation(encoding, format)\n    {\n        //\n        // If no encoding version is specified, use the current write\n        // encapsulation encoding version if there's a current write\n        // encapsulation, otherwise, use the stream encoding version.\n        //\n\n        if(encoding === undefined)\n        {\n            if(this._encapsStack !== null)\n            {\n                encoding = this._encapsStack.encoding;\n                format = this._encapsStack.format;\n            }\n            else\n            {\n                encoding = this._encoding;\n                format = FormatType.DefaultFormat;\n            }\n        }\n\n        Protocol.checkSupportedEncoding(encoding);\n\n        let curr = this._encapsCache;\n        if(curr !== null)\n        {\n            curr.reset();\n            this._encapsCache = this._encapsCache.next;\n        }\n        else\n        {\n            curr = new WriteEncaps();\n        }\n        curr.next = this._encapsStack;\n        this._encapsStack = curr;\n\n        this._encapsStack.format = format;\n        this._encapsStack.setEncoding(encoding);\n        this._encapsStack.start = this._buf.limit;\n\n        this.writeInt(0); // Placeholder for the encapsulation length.\n        this._encapsStack.encoding._write(this);\n    }\n\n    endEncapsulation()\n    {\n        Debug.assert(this._encapsStack);\n\n        // Size includes size and version.\n        const start = this._encapsStack.start;\n        const sz = this._buf.limit - start;\n        this._buf.putIntAt(start, sz);\n\n        const curr = this._encapsStack;\n        this._encapsStack = curr.next;\n        curr.next = this._encapsCache;\n        this._encapsCache = curr;\n        this._encapsCache.reset();\n    }\n\n    writeEmptyEncapsulation(encoding)\n    {\n        Protocol.checkSupportedEncoding(encoding);\n        this.writeInt(6); // Size\n        encoding._write(this);\n    }\n\n    writeEncapsulation(v)\n    {\n        if(v.length < 6)\n        {\n            throw new Ice.EncapsulationException();\n        }\n        this.expand(v.length);\n        this._buf.putArray(v);\n    }\n\n    getEncoding()\n    {\n        return this._encapsStack !== null ? this._encapsStack.encoding : this._encoding;\n    }\n\n    startSlice(typeId, compactId, last)\n    {\n        Debug.assert(this._encapsStack !== null && this._encapsStack.encoder !== null);\n        this._encapsStack.encoder.startSlice(typeId, compactId, last);\n    }\n\n    endSlice()\n    {\n        Debug.assert(this._encapsStack !== null && this._encapsStack.encoder !== null);\n        this._encapsStack.encoder.endSlice();\n    }\n\n    writePendingValues()\n    {\n        if(this._encapsStack !== null && this._encapsStack.encoder !== null)\n        {\n            this._encapsStack.encoder.writePendingValues();\n        }\n        else if((this._encapsStack !== null && this._encapsStack.encoding_1_0) ||\n                (this._encapsStack === null && this._encoding.equals(Ice.Encoding_1_0)))\n        {\n            //\n            // If using the 1.0 encoding and no instances were written, we\n            // still write an empty sequence for pending instances if\n            // requested (i.e.: if this is called).\n            //\n            // This is required by the 1.0 encoding, even if no instances\n            // are written we do marshal an empty sequence if marshaled\n            // data types use classes.\n            //\n            this.writeSize(0);\n        }\n    }\n\n    writeSize(v)\n    {\n        if(v > 254)\n        {\n            this.expand(5);\n            this._buf.put(255);\n            this._buf.putInt(v);\n        }\n        else\n        {\n            this.expand(1);\n            this._buf.put(v);\n        }\n    }\n\n    startSize()\n    {\n        const pos = this._buf.position;\n        this.writeInt(0); // Placeholder for 32-bit size\n        return pos;\n    }\n\n    endSize(pos)\n    {\n        Debug.assert(pos >= 0);\n        this.rewriteInt(this._buf.position - pos - 4, pos);\n    }\n\n    writeBlob(v)\n    {\n        if(v === null || v === undefined)\n        {\n            return;\n        }\n        this.expand(v.length);\n        this._buf.putArray(v);\n    }\n\n    // Read/write format and tag for optionals\n    writeOptional(tag, format)\n    {\n        Debug.assert(this._encapsStack !== null);\n        if(this._encapsStack.encoder !== null)\n        {\n            return this._encapsStack.encoder.writeOptional(tag, format);\n        }\n        return this.writeOptImpl(tag, format);\n    }\n\n    writeOptionalHelper(tag, format, write, v)\n    {\n        if(v !== undefined)\n        {\n            if(this.writeOptional(tag, format))\n            {\n                write.call(this, v);\n            }\n        }\n    }\n\n    writeByte(v)\n    {\n        this.expand(1);\n        this._buf.put(v);\n    }\n\n    rewriteByte(v, dest)\n    {\n        this._buf.putAt(dest, v);\n    }\n\n    writeByteSeq(v)\n    {\n        if(v === null || v === undefined || v.length === 0)\n        {\n            this.writeSize(0);\n        }\n        else\n        {\n            this.writeSize(v.length);\n            this.expand(v.length);\n            this._buf.putArray(v);\n        }\n    }\n\n    writeBool(v)\n    {\n        this.expand(1);\n        this._buf.put(v ? 1 : 0);\n    }\n\n    rewriteBool(v, dest)\n    {\n        this._buf.putAt(dest, v ? 1 : 0);\n    }\n\n    writeShort(v)\n    {\n        this.expand(2);\n        this._buf.putShort(v);\n    }\n\n    writeInt(v)\n    {\n        this.expand(4);\n        this._buf.putInt(v);\n    }\n\n    rewriteInt(v, dest)\n    {\n        this._buf.putIntAt(dest, v);\n    }\n\n    writeLong(v)\n    {\n        this.expand(8);\n        this._buf.putLong(v);\n    }\n\n    writeFloat(v)\n    {\n        this.expand(4);\n        this._buf.putFloat(v);\n    }\n\n    writeDouble(v)\n    {\n        this.expand(8);\n        this._buf.putDouble(v);\n    }\n\n    writeString(v)\n    {\n        if(v === null || v === undefined || v.length === 0)\n        {\n            this.writeSize(0);\n        }\n        else\n        {\n            this._buf.writeString(this, v);\n        }\n    }\n\n    writeProxy(v)\n    {\n        if(v === null || v === undefined)\n        {\n            const ident = new Ice.Identity();\n            ident._write(this);\n        }\n        else\n        {\n            v._write(this);\n        }\n    }\n\n    writeOptionalProxy(tag, v)\n    {\n        if(v !== undefined)\n        {\n            if(this.writeOptional(tag, OptionalFormat.FSize))\n            {\n                const pos = this.startSize();\n                this.writeProxy(v);\n                this.endSize(pos);\n            }\n        }\n    }\n\n    writeEnum(v)\n    {\n        if(this.isEncoding_1_0())\n        {\n            if(v.maxValue < 127)\n            {\n                this.writeByte(v.value);\n            }\n            else if(v.maxValue < 32767)\n            {\n                this.writeShort(v.value);\n            }\n            else\n            {\n                this.writeInt(v.value);\n            }\n        }\n        else\n        {\n            this.writeSize(v.value);\n        }\n    }\n\n    writeValue(v)\n    {\n        this.initEncaps();\n        this._encapsStack.encoder.writeValue(v);\n    }\n\n    writeOptionalValue(tag, v)\n    {\n        if(v !== undefined)\n        {\n            if(this.writeOptional(tag, OptionalFormat.Class))\n            {\n                this.writeValue(v);\n            }\n        }\n    }\n\n    writeException(e)\n    {\n        this.initEncaps();\n        this._encapsStack.encoder.writeException(e);\n    }\n\n    //\n    // Keep for compatibility with 3.7.0 remove with next major version\n    //\n    writeUserException(e)\n    {\n        this.WriteException(e);\n    }\n\n    writeOptImpl(tag, format)\n    {\n        if(this.isEncoding_1_0())\n        {\n            return false; // Optional members aren't supported with the 1.0 encoding.\n        }\n\n        let v = format.value;\n        if(tag < 30)\n        {\n            v |= tag << 3;\n            this.writeByte(v);\n        }\n        else\n        {\n            v |= 0x0F0; // tag = 30\n            this.writeByte(v);\n            this.writeSize(tag);\n        }\n        return true;\n    }\n\n    isEmpty()\n    {\n        return this._buf.empty();\n    }\n\n    expand(n)\n    {\n        this._buf.expand(n);\n    }\n\n    isEncoding_1_0()\n    {\n        return this._encapsStack ? this._encapsStack.encoding_1_0 : this._encoding.equals(Ice.Encoding_1_0);\n    }\n\n    initEncaps()\n    {\n        if(!this._encapsStack) // Lazy initialization\n        {\n            this._encapsStack = this._encapsCache;\n            if(this._encapsStack)\n            {\n                this._encapsCache = this._encapsCache.next;\n            }\n            else\n            {\n                this._encapsStack = new WriteEncaps();\n            }\n            this._encapsStack.setEncoding(this._encoding);\n        }\n\n        if(this._encapsStack.format === FormatType.DefaultFormat)\n        {\n            this._encapsStack.format = this._instance.defaultsAndOverrides().defaultFormat;\n        }\n\n        if(!this._encapsStack.encoder) // Lazy initialization.\n        {\n            if(this._encapsStack.encoding_1_0)\n            {\n                this._encapsStack.encoder = new EncapsEncoder10(this, this._encapsStack);\n            }\n            else\n            {\n                this._encapsStack.encoder = new EncapsEncoder11(this, this._encapsStack);\n            }\n        }\n    }\n\n    //\n    // Sets the encoding format for class and exception instances.\n    //\n    get format()\n    {\n        return this._format;\n    }\n\n    set format(value)\n    {\n        this._format = value;\n    }\n\n    get pos()\n    {\n        return this._buf.position;\n    }\n\n    set pos(value)\n    {\n        this._buf.position = value;\n    }\n\n    get size()\n    {\n        return this._buf.limit;\n    }\n\n    get instance()\n    {\n        return this._instance;\n    }\n\n    get closure()\n    {\n        return this._closure;\n    }\n\n    set closure(value)\n    {\n        this._closure = value;\n    }\n\n    get buffer()\n    {\n        return this._buf;\n    }\n}\n\nconst defineBuiltinHelper = function(write, read, sz, format, min, max)\n{\n    const helper = class\n    {\n        static write(os, v)\n        {\n            return write.call(os, v);\n        }\n\n        static read(is)\n        {\n            return read.call(is);\n        }\n\n        static writeOptional(os, tag, v)\n        {\n            os.writeOptionalHelper(tag, format, write, v);\n        }\n\n        static readOptional(is, tag)\n        {\n            return is.readOptionalHelper(tag, format, read);\n        }\n\n        static get minWireSize()\n        {\n            return sz;\n        }\n    };\n\n    if(min !== undefined && max !== undefined)\n    {\n        helper.validate = function(v)\n        {\n            return v >= min && v <= max;\n        };\n    }\n\n    return helper;\n};\n\nconst istr = InputStream.prototype;\nconst ostr = OutputStream.prototype;\n\n//\n// Constants to use in number type range checks.\n//\nconst MIN_UINT8_VALUE = 0x0;\nconst MAX_UINT8_VALUE = 0xFF;\n\nconst MIN_INT16_VALUE = -0x8000;\nconst MAX_INT16_VALUE = 0x7FFF;\n\nconst MIN_UINT32_VALUE = 0x0;\nconst MAX_UINT32_VALUE = 0xFFFFFFFF;\n\nconst MIN_INT32_VALUE = -0x80000000;\nconst MAX_INT32_VALUE = 0x7FFFFFFF;\n\nconst MIN_FLOAT32_VALUE = -3.4028234664e+38;\nconst MAX_FLOAT32_VALUE = 3.4028234664e+38;\n\nIce.ByteHelper = defineBuiltinHelper(ostr.writeByte, istr.readByte, 1, Ice.OptionalFormat.F1,\n                                     MIN_UINT8_VALUE, MAX_UINT8_VALUE);\n\nIce.ShortHelper = defineBuiltinHelper(ostr.writeShort, istr.readShort, 2, Ice.OptionalFormat.F2,\n                                      MIN_INT16_VALUE, MAX_INT16_VALUE);\n\nIce.IntHelper = defineBuiltinHelper(ostr.writeInt, istr.readInt, 4, Ice.OptionalFormat.F4,\n                                    MIN_INT32_VALUE, MAX_INT32_VALUE);\n\nIce.FloatHelper = defineBuiltinHelper(ostr.writeFloat, istr.readFloat, 4, Ice.OptionalFormat.F4,\n                                      MIN_FLOAT32_VALUE, MAX_FLOAT32_VALUE);\nIce.FloatHelper.validate = function(v)\n{\n    return Number.isNaN(v) || v == Number.POSITIVE_INFINITY || v == Number.NEGATIVE_INFINITY ||\n        (v >= MIN_FLOAT32_VALUE && v <= MAX_FLOAT32_VALUE);\n};\n\nIce.DoubleHelper = defineBuiltinHelper(ostr.writeDouble, istr.readDouble, 8, Ice.OptionalFormat.F8,\n                                       -Number.MAX_VALUE, Number.MAX_VALUE);\nIce.DoubleHelper.validate = function(v)\n{\n    return Number.isNaN(v) || v == Number.POSITIVE_INFINITY || v == Number.NEGATIVE_INFINITY ||\n        (v >= -Number.MAX_VALUE && v <= Number.MAX_VALUE);\n};\n\nIce.BoolHelper = defineBuiltinHelper(ostr.writeBool, istr.readBool, 1, Ice.OptionalFormat.F1);\nIce.LongHelper = defineBuiltinHelper(ostr.writeLong, istr.readLong, 8, Ice.OptionalFormat.F8);\nIce.LongHelper.validate = function(v)\n{\n    //\n    // For a long to be valid both words must be within the range of UINT32\n    //\n    return v.low >= MIN_UINT32_VALUE && v.low <= MAX_UINT32_VALUE &&\n           v.high >= MIN_UINT32_VALUE && v.high <= MAX_UINT32_VALUE;\n};\n\nIce.StringHelper = defineBuiltinHelper(ostr.writeString, istr.readString, 1, Ice.OptionalFormat.VSize);\n\nIce.ObjectHelper = class\n{\n    static write(os, v)\n    {\n        os.writeValue(v);\n    }\n\n    static read(is)\n    {\n        let o;\n        is.readValue(v =>\n                     {\n                         o = v;\n                     }, Ice.Value);\n        return o;\n    }\n\n    static writeOptional(os, tag, v)\n    {\n        os.writeOptionalValue(tag, Ice.OptionalFormat.Class, ostr.writeValue, v);\n    }\n\n    static readOptional(is, tag)\n    {\n        let o;\n        is.readOptionalValue(tag, v =>\n                             {\n                                 o = v;\n                             }, Ice.Value);\n        return o;\n    }\n\n    static get minWireSize()\n    {\n        return 1;\n    }\n};\n\nIce.InputStream = InputStream;\nIce.OutputStream = OutputStream;\nmodule.exports.Ice = Ice;\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/Stream.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/StreamHelpers.js":
/*!***************************************************!*\
  !*** ./node_modules/ice/src/Ice/StreamHelpers.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nconst Ice = (__webpack_require__(/*! ../Ice/OptionalFormat */ \"./node_modules/ice/src/Ice/OptionalFormat.js\").Ice);\n\nconst defineProperty = Object.defineProperty;\nconst OptionalFormat = Ice.OptionalFormat;\n\nconst StreamHelpers = {};\n\nStreamHelpers.FSizeOptHelper = function()\n{\n    this.writeOptional = function(os, tag, v)\n    {\n        if(v !== undefined && os.writeOptional(tag, OptionalFormat.FSize))\n        {\n            const pos = os.startSize();\n            this.write(os, v);\n            os.endSize(pos);\n        }\n    };\n\n    this.readOptional = function(is, tag)\n    {\n        let v;\n        if(is.readOptional(tag, OptionalFormat.FSize))\n        {\n            is.skip(4);\n            v = this.read(is);\n        }\n        return v;\n    };\n};\n\nStreamHelpers.VSizeOptHelper = function()\n{\n    this.writeOptional = function(os, tag, v)\n    {\n        if(v !== undefined && os.writeOptional(tag, OptionalFormat.VSize))\n        {\n            os.writeSize(this.minWireSize);\n            this.write(os, v);\n        }\n    };\n\n    this.readOptional = function(is, tag)\n    {\n        let v;\n        if(is.readOptional(tag, OptionalFormat.VSize))\n        {\n            is.skipSize();\n            v = this.read(is);\n        }\n        return v;\n    };\n};\n\nStreamHelpers.VSizeContainerOptHelper = function(elementSize)\n{\n    this.writeOptional = function(os, tag, v)\n    {\n        if(v !== undefined && os.writeOptional(tag, OptionalFormat.VSize))\n        {\n            const sz = this.size(v);\n            os.writeSize(sz > 254 ? sz * elementSize + 5 : sz * elementSize + 1);\n            this.write(os, v);\n        }\n    };\n\n    this.readOptional = function(is, tag)\n    {\n        let v;\n        if(is.readOptional(tag, OptionalFormat.VSize))\n        {\n            is.skipSize();\n            v = this.read(is);\n        }\n        return v;\n    };\n};\n\nStreamHelpers.VSizeContainer1OptHelper = function()\n{\n    this.writeOptional = function(os, tag, v)\n    {\n        if(v !== undefined && os.writeOptional(tag, OptionalFormat.VSize))\n        {\n            this.write(os, v);\n        }\n    };\n\n    this.readOptional = function(is, tag)\n    {\n        let v;\n        if(is.readOptional(tag, OptionalFormat.VSize))\n        {\n            v = this.read(is);\n        }\n        return v;\n    };\n};\n\n//\n// Sequence helper to write sequences\n//\nclass SequenceHelper\n{\n    write(os, v)\n    {\n        if(v === null || v === undefined || v.length === 0)\n        {\n            os.writeSize(0);\n        }\n        else\n        {\n            const helper = this.elementHelper;\n            os.writeSize(v.length);\n            for(let i = 0; i < v.length; ++i)\n            {\n                helper.write(os, v[i]);\n            }\n        }\n    }\n\n    read(is)\n    {\n        const helper = this.elementHelper; // Cache the element helper.\n        const sz = is.readAndCheckSeqSize(helper.minWireSize);\n        const v = [];\n        v.length = sz;\n        for(let i = 0; i < sz; ++i)\n        {\n            v[i] = helper.read(is);\n        }\n        return v;\n    }\n\n    size(v)\n    {\n        return (v === null || v === undefined) ? 0 : v.length;\n    }\n\n    get minWireSize()\n    {\n        return 1;\n    }\n}\n\n// Speacialization optimized for ByteSeq\nconst byteSeqHelper = new SequenceHelper();\nbyteSeqHelper.write = (os, v) => os.writeByteSeq(v);\nbyteSeqHelper.read = is => is.readByteSeq();\n\ndefineProperty(byteSeqHelper, \"elementHelper\", {get: () => Ice.ByteHelper});\nStreamHelpers.VSizeContainer1OptHelper.call(byteSeqHelper);\n\n// Read method for value sequences\nconst valueSequenceHelperRead = function(is)\n{\n    const sz = is.readAndCheckSeqSize(1);\n    const v = [];\n    v.length = sz;\n    const elementType = this.elementType;\n    const readValueAtIndex = function(idx)\n    {\n        is.readValue(obj =>\n                     {\n                         v[idx] = obj;\n                     }, elementType);\n    };\n\n    for(let i = 0; i < sz; ++i)\n    {\n        readValueAtIndex(i);\n    }\n    return v;\n};\n\nStreamHelpers.generateSeqHelper = function(elementHelper, fixed, elementType)\n{\n    if(elementHelper === Ice.ByteHelper)\n    {\n        return byteSeqHelper;\n    }\n\n    const helper = new SequenceHelper();\n    if(fixed)\n    {\n        if(elementHelper.minWireSize === 1)\n        {\n            StreamHelpers.VSizeContainer1OptHelper.call(helper);\n        }\n        else\n        {\n            StreamHelpers.VSizeContainerOptHelper.call(helper, elementHelper.minWireSize);\n        }\n    }\n    else\n    {\n        StreamHelpers.FSizeOptHelper.call(helper);\n    }\n\n    defineProperty(helper, \"elementHelper\", {get: () => elementHelper});\n\n    if(elementHelper == Ice.ObjectHelper)\n    {\n        defineProperty(helper, \"elementType\", {get: () => elementType});\n        helper.read = valueSequenceHelperRead;\n    }\n\n    return helper;\n};\n\n//\n// Dictionary helper to write dictionaries\n//\nclass DictionaryHelper\n{\n    write(os, v)\n    {\n        if(v === null || v == undefined || v.size === 0)\n        {\n            os.writeSize(0);\n        }\n        else\n        {\n            const keyHelper = this.keyHelper;\n            const valueHelper = this.valueHelper;\n            os.writeSize(v.size);\n            for(const [key, value] of v)\n            {\n                keyHelper.write(os, key);\n                valueHelper.write(os, value);\n            }\n        }\n    }\n\n    read(is)\n    {\n        const mapType = this.mapType;\n        const v = new mapType();\n        const sz = is.readSize();\n        const keyHelper = this.keyHelper;\n        const valueHelper = this.valueHelper;\n        for(let i = 0; i < sz; ++i)\n        {\n            v.set(keyHelper.read(is), valueHelper.read(is));\n        }\n        return v;\n    }\n\n    size(v)\n    {\n        return (v === null || v === undefined) ? 0 : v.size;\n    }\n\n    get minWireSize()\n    {\n        return 1;\n    }\n}\n\n// Read method for dictionaries of values\nconst valueDictionaryHelperRead = function(is)\n{\n    const sz = is.readSize();\n    const mapType = this.mapType;\n    const v = new mapType();\n    const valueType = this.valueType;\n\n    const readValueForKey = function(key)\n    {\n        is.readValue(obj => v.set(key, obj), valueType);\n    };\n\n    const keyHelper = this.keyHelper;\n    for(let i = 0; i < sz; ++i)\n    {\n        readValueForKey(keyHelper.read(is));\n    }\n    return v;\n};\n\nStreamHelpers.generateDictHelper = function(keyHelper, valueHelper, fixed, valueType, mapType)\n{\n    const helper = new DictionaryHelper();\n    if(fixed)\n    {\n        StreamHelpers.VSizeContainerOptHelper.call(helper, keyHelper.minWireSize + valueHelper.minWireSize);\n    }\n    else\n    {\n        StreamHelpers.FSizeOptHelper.call(helper);\n    }\n\n    defineProperty(helper,\n                   \"mapType\",\n                   {\n                       get: () => mapType\n                   });\n\n    defineProperty(helper, \"keyHelper\",\n                   {\n                       get: () => keyHelper\n                   });\n\n    defineProperty(helper, \"valueHelper\",\n                   {\n                       get: () => valueHelper\n                   });\n\n    if(valueHelper == Ice.ObjectHelper)\n    {\n        defineProperty(helper, \"valueType\",\n                       {\n                           get: () => valueType\n                       });\n\n        helper.read = valueDictionaryHelperRead;\n    }\n\n    return helper;\n};\n\nIce.StreamHelpers = StreamHelpers;\nmodule.exports.Ice = Ice;\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/StreamHelpers.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/StringUtil.js":
/*!************************************************!*\
  !*** ./node_modules/ice/src/Ice/StringUtil.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nconst Ice = (__webpack_require__(/*! ../Ice/Debug */ \"./node_modules/ice/src/Ice/Debug.js\").Ice);\nconst Debug = Ice.Debug;\n\nIce.StringUtil = class\n{\n    //\n    // Return the index of the first character in str to\n    // appear in match, starting from start. Returns -1 if none is\n    // found.\n    //\n    static findFirstOf(str, match, start)\n    {\n        start = start === undefined ? 0 : start;\n        for(let i = start; i < str.length; i++)\n        {\n            const ch = str.charAt(i);\n            if(match.indexOf(ch) != -1)\n            {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    //\n    // Return the index of the first character in str which does\n    // not appear in match, starting from start. Returns -1 if none is\n    // found.\n    //\n    static findFirstNotOf(str, match, start)\n    {\n        start = start === undefined ? 0 : start;\n        for(let i = start; i < str.length; i++)\n        {\n            const ch = str.charAt(i);\n            if(match.indexOf(ch) == -1)\n            {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    //\n    // Add escape sequences (such as \"\\n\", or \"\\123\") to s\n    //\n    static escapeString(s, special, toStringMode)\n    {\n        special = special === undefined ? null : special;\n        if(special !== null)\n        {\n            for(let i = 0; i < special.length; ++i)\n            {\n                if(special.charCodeAt(i) < 32 || special.charCodeAt(i) > 126)\n                {\n                    throw new RangeError(\"special characters must be in ASCII range 32-126\");\n                }\n            }\n        }\n\n        const result = [];\n\n        if(toStringMode === Ice.ToStringMode.Compat)\n        {\n            // Encode UTF-8 bytes\n            const bytes = unescape(encodeURIComponent(s));\n            for(let i = 0; i < bytes.length; ++i)\n            {\n                const c = bytes.charCodeAt(i);\n                encodeChar(c, result, special, toStringMode);\n            }\n        }\n        else\n        {\n            for(let i = 0; i < s.length; ++i)\n            {\n                const c = s.charCodeAt(i);\n                if(toStringMode === Ice.ToStringMode.Unicode || c < 0xD800 || c > 0xDFFF)\n                {\n                    encodeChar(c, result, special, toStringMode);\n                }\n                else\n                {\n                    Debug.assert(toStringMode === Ice.ToStringMode.ASCII && c >= 0xD800 && c <= 0xDFFF);\n                    if(i + 1 === s.length)\n                    {\n                        throw new RangeError(\"High surrogate without low surrogate\");\n                    }\n                    else\n                    {\n                        const codePoint = s.codePointAt(i);\n                        Debug.assert(codePoint > 0xFFFF);\n                        i++;\n\n                        // append \\Unnnnnnnn\n                        result.push(\"\\\\U\");\n                        const hex = codePoint.toString(16);\n                        for(let j = hex.length; j < 8; j++)\n                        {\n                            result.push('0');\n                        }\n                        result.push(hex);\n                    }\n                }\n            }\n        }\n        return result.join(\"\");\n    }\n\n    //\n    // Remove escape sequences added by escapeString. Throws Error\n    // for an invalid input string.\n    //\n    static unescapeString(s, start, end, special)\n    {\n        start = start === undefined ? 0 : start;\n        end = end === undefined ? s.length : end;\n        special = special === undefined ? null : special;\n\n        Debug.assert(start >= 0 && start <= end && end <= s.length);\n\n        if(special !== null)\n        {\n            for(let i = 0; i < special.length; ++i)\n            {\n                if(special.charCodeAt(i) < 32 || special.charCodeAt(i) > 126)\n                {\n                    throw new RangeError(\"special characters must be in ASCII range 32-126\");\n                }\n            }\n        }\n\n        // Optimization for strings without escapes\n        let p = s.indexOf('\\\\', start);\n        if(p == -1 || p >= end)\n        {\n            p = start;\n            while(p < end)\n            {\n                checkChar(s, p++);\n            }\n            return s.substring(start, end);\n        }\n        else\n        {\n            const arr = [];\n            while(start < end)\n            {\n                start = decodeChar(s, start, end, special, arr);\n            }\n            return arr.join(\"\");\n        }\n    }\n\n    //\n    // Split string helper; returns null for unmatched quotes\n    //\n    static splitString(str, delim)\n    {\n        const v = [];\n        let s = \"\";\n        let pos = 0;\n        let quoteChar = null;\n        while(pos < str.length)\n        {\n            if(quoteChar === null && (str.charAt(pos) === '\"' || str.charAt(pos) === '\\''))\n            {\n                quoteChar = str.charAt(pos++);\n                continue; // Skip the quote.\n            }\n            else if(quoteChar === null && str.charAt(pos) === '\\\\' && pos + 1 < str.length &&\n                    (str.charAt(pos + 1) === '\"' || str.charAt(pos + 1) === '\\''))\n            {\n                ++pos; // Skip the backslash\n            }\n            else if(quoteChar !== null && str.charAt(pos) === '\\\\' && pos + 1 < str.length &&\n                    str.charAt(pos + 1) === quoteChar)\n            {\n                ++pos; // Skip the backslash\n            }\n            else if(quoteChar !== null && str.charAt(pos) === quoteChar)\n            {\n                ++pos;\n                quoteChar = null;\n                continue; // Skip the quote.\n            }\n            else if(delim.indexOf(str.charAt(pos)) !== -1)\n            {\n                if(quoteChar === null)\n                {\n                    ++pos;\n                    if(s.length > 0)\n                    {\n                        v.push(s);\n                        s = \"\";\n                    }\n                    continue;\n                }\n            }\n\n            if(pos < str.length)\n            {\n                s += str.charAt(pos++);\n            }\n        }\n\n        if(s.length > 0)\n        {\n            v.push(s);\n        }\n        if(quoteChar !== null)\n        {\n            return null; // Unmatched quote.\n        }\n\n        return v;\n    }\n\n    //\n    // If a single or double quotation mark is found at the start position,\n    // then the position of the matching closing quote is returned. If no\n    // quotation mark is found at the start position, then 0 is returned.\n    // If no matching closing quote is found, then -1 is returned.\n    //\n    static checkQuote(s, start)\n    {\n        start = start === undefined ? 0 : start;\n\n        const quoteChar = s.charAt(start);\n        if(quoteChar == '\"' || quoteChar == '\\'')\n        {\n            start++;\n            let pos;\n            while(start < s.length && (pos = s.indexOf(quoteChar, start)) != -1)\n            {\n                if(s.charAt(pos - 1) != '\\\\')\n                {\n                    return pos;\n                }\n                start = pos + 1;\n            }\n            return -1; // Unmatched quote\n        }\n        return 0; // Not quoted\n    }\n\n    static hashCode(s)\n    {\n        let hash = 0;\n        for(let i = 0; i < s.length; i++)\n        {\n            hash = 31 * hash + s.charCodeAt(i);\n        }\n        return hash;\n    }\n\n    static toInt(s)\n    {\n        const n = parseInt(s, 10);\n        if(isNaN(n))\n        {\n            throw new RangeError(\"conversion of `\" + s + \"' to int failed\");\n        }\n        return n;\n    }\n};\nmodule.exports.Ice = Ice;\n\nfunction encodeChar(c, sb, special, toStringMode)\n{\n    switch(c)\n    {\n        case 92: // '\\\\'\n        {\n            sb.push(\"\\\\\\\\\");\n            break;\n        }\n        case 39: // '\\''\n        {\n            sb.push(\"\\\\'\");\n            break;\n        }\n        case 34: // '\"'\n        {\n            sb.push(\"\\\\\\\"\");\n            break;\n        }\n        case 7: // '\\a'\n        {\n            if(toStringMode == Ice.ToStringMode.Compat)\n            {\n                // Octal escape for compatibility with 3.6 and earlier\n                sb.push(\"\\\\007\");\n            }\n            else\n            {\n                sb.push(\"\\\\a\");\n            }\n            break;\n        }\n        case 8: // '\\b'\n        {\n            sb.push(\"\\\\b\");\n            break;\n        }\n        case 12: // '\\f'\n        {\n            sb.push(\"\\\\f\");\n            break;\n        }\n        case 10: // '\\n'\n        {\n            sb.push(\"\\\\n\");\n            break;\n        }\n        case 13: // '\\r'\n        {\n            sb.push(\"\\\\r\");\n            break;\n        }\n        case 9: // '\\t'\n        {\n            sb.push(\"\\\\t\");\n            break;\n        }\n        case 11: // '\\v'\n        {\n            if(toStringMode == Ice.ToStringMode.Compat)\n            {\n                // Octal escape for compatibility with 3.6 and earlier\n                sb.push(\"\\\\013\");\n            }\n            else\n            {\n                sb.push(\"\\\\v\");\n            }\n            break;\n        }\n        default:\n        {\n            const s = String.fromCharCode(c);\n\n            if(special !== null && special.indexOf(s) !== -1)\n            {\n                sb.push('\\\\');\n                sb.push(s);\n            }\n            else if(c < 32 || c > 126)\n            {\n                if(toStringMode === Ice.ToStringMode.Compat)\n                {\n                    //\n                    // When ToStringMode=Compat, c is a UTF-8 byte\n                    //\n                    Debug.assert(c < 256);\n                    sb.push('\\\\');\n                    const octal = c.toString(8);\n                    //\n                    // Add leading zeroes so that we avoid problems during\n                    // decoding. For example, consider the encoded string\n                    // \\0013 (i.e., a character with value 1 followed by\n                    // the character '3'). If the leading zeroes were omitted,\n                    // the result would be incorrectly interpreted by the\n                    // decoder as a single character with value 11.\n                    //\n                    for(let j = octal.length; j < 3; j++)\n                    {\n                        sb.push('0');\n                    }\n                    sb.push(octal);\n                }\n                else if(c < 32 || c == 127 || toStringMode === Ice.ToStringMode.ASCII)\n                {\n                    // append \\\\unnnn\n                    sb.push(\"\\\\u\");\n                    const hex = c.toString(16);\n                    for(let j = hex.length; j < 4; j++)\n                    {\n                        sb.push('0');\n                    }\n                    sb.push(hex);\n                }\n                else\n                {\n                    // keep as is\n                    sb.push(s);\n                }\n            }\n            else\n            {\n                // printable ASCII character\n                sb.push(s);\n            }\n            break;\n        }\n    }\n}\n\nfunction checkChar(s, pos)\n{\n    const c = s.charCodeAt(pos);\n    if(c < 32 || c === 127)\n    {\n        let msg;\n        if(pos > 0)\n        {\n            msg = \"character after `\" + s.substring(0, pos) + \"'\";\n        }\n        else\n        {\n            msg = \"first character\";\n        }\n        msg += \" has invalid ordinal value\" + c;\n        throw new RangeError(msg);\n    }\n    return s.charAt(pos);\n}\n//\n// Decode the character or escape sequence starting at start and appends it to result;\n// returns the index of the first character following the decoded character\n// or escape sequence.\n//\nfunction decodeChar(s, start, end, special, result)\n{\n    Debug.assert(start >= 0);\n    Debug.assert(start < end);\n    Debug.assert(end <= s.length);\n\n    if(s.charAt(start) != '\\\\')\n    {\n        result.push(checkChar(s, start++));\n    }\n    else if(start + 1 === end)\n    {\n        ++start;\n        result.push(\"\\\\\"); // trailing backslash\n    }\n    else\n    {\n        let c = s.charAt(++start);\n\n        switch(c)\n        {\n            case '\\\\':\n            case '\\'':\n            case '\"':\n            case '?':\n            {\n                ++start;\n                result.push(c);\n                break;\n            }\n            case 'a':\n            {\n                ++start;\n                result.append(\"\\u0007\");\n                break;\n            }\n            case 'b':\n            {\n                ++start;\n                result.push(\"\\b\");\n                break;\n            }\n            case 'f':\n            {\n                ++start;\n                result.push(\"\\f\");\n                break;\n            }\n            case 'n':\n            {\n                ++start;\n                result.push(\"\\n\");\n                break;\n            }\n            case 'r':\n            {\n                ++start;\n                result.push(\"\\r\");\n                break;\n            }\n            case 't':\n            {\n                ++start;\n                result.push(\"\\t\");\n                break;\n            }\n            case 'v':\n            {\n                ++start;\n                result.push(\"\\v\");\n                break;\n            }\n            case 'u':\n            case 'U':\n            {\n                let codePoint = 0;\n                const inBMP = (c === 'u');\n                let size = inBMP ? 4 : 8;\n                ++start;\n                while(size > 0 && start < end)\n                {\n                    let charVal = s.charCodeAt(start++);\n                    if(charVal >= 0x30 && charVal <= 0x39)\n                    {\n                        charVal -= 0x30;\n                    }\n                    else if(charVal >= 0x61 && charVal <= 0x66)\n                    {\n                        charVal += 10 - 0x61;\n                    }\n                    else if(charVal >= 0x41 && charVal <= 0x46)\n                    {\n                        charVal += 10 - 0x41;\n                    }\n                    else\n                    {\n                        break; // while\n                    }\n                    codePoint = codePoint * 16 + charVal;\n                    --size;\n                }\n                if(size > 0)\n                {\n                    throw new RangeError(\"Invalid universal character name: too few hex digits\");\n                }\n                if(codePoint >= 0xD800 && codePoint <= 0xDFFF)\n                {\n                    throw new RangeError(\"A universal character name cannot designate a surrogate\");\n                }\n                if(inBMP || codePoint <= 0xFFFF)\n                {\n                    result.push(String.fromCharCode(codePoint));\n                }\n                else\n                {\n                    result.push(String.fromCodePoint(codePoint));\n                }\n                break;\n            }\n            case '0':\n            case '1':\n            case '2':\n            case '3':\n            case '4':\n            case '5':\n            case '6':\n            case '7':\n            case 'x':\n            {\n                // UTF-8 byte sequence encoded with octal or hex escapes\n\n                const arr = [];\n                let more = true;\n                while(more)\n                {\n                    let val = 0;\n                    if(c === 'x')\n                    {\n                        let size = 2;\n                        ++start;\n                        while(size > 0 && start < end)\n                        {\n                            let charVal = s.charCodeAt(start++);\n                            if(charVal >= 0x30 && charVal <= 0x39)\n                            {\n                                charVal -= 0x30;\n                            }\n                            else if(charVal >= 0x61 && charVal <= 0x66)\n                            {\n                                charVal += 10 - 0x61;\n                            }\n                            else if(charVal >= 0x41 && charVal <= 0x46)\n                            {\n                                charVal += 10 - 0x41;\n                            }\n                            else\n                            {\n                                break; // while\n                            }\n                            val = val * 16 + charVal;\n                            --size;\n                        }\n                        if(size === 2)\n                        {\n                            throw new RangeError(\"Invalid \\\\x escape sequence: no hex digit\");\n                        }\n                    }\n                    else\n                    {\n                        for(let j = 0; j < 3 && start < end; ++j)\n                        {\n                            const charVal = s.charCodeAt(start++) - '0'.charCodeAt(0);\n                            if(charVal < 0 || charVal > 7)\n                            {\n                                --start; // move back\n                                Debug.assert(j !== 0); // must be at least one digit\n                                break; // for\n                            }\n                            val = val * 8 + charVal;\n                        }\n                        if(val > 255)\n                        {\n                            throw new RangeError(\"octal value \\\\\" + val.toString(8) + \" (\" + val + \") is out of range\");\n                        }\n                    }\n\n                    arr.push(String.fromCharCode(val));\n\n                    more = false;\n                    if((start + 1 < end) && s.charAt(start) === '\\\\')\n                    {\n                        c = s.charAt(start + 1);\n                        const charVal = s.charCodeAt(start + 1);\n                        if(c === 'x' || (charVal >= 0x30 && charVal <= 0x39))\n                        {\n                            start++;\n                            more = true;\n                        }\n                    }\n                }\n\n                // Decode UTF-8 arr into string\n                result.push(decodeURIComponent(escape(arr.join(\"\"))));\n                break;\n            }\n            default:\n            {\n                if(special === null || special.length === 0 || special.indexOf(c) === -1)\n                {\n                    result.push(\"\\\\\"); // not in special, so we keep the backslash\n                }\n                result.push(checkChar(s, start++));\n                break;\n            }\n        }\n    }\n\n    return start;\n}\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/StringUtil.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/Struct.js":
/*!********************************************!*\
  !*** ./node_modules/ice/src/Ice/Struct.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nconst Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\n\nconst ArrayUtil = Ice.ArrayUtil;\n\n//\n// Use generic equality test from ArrayUtil.\n//\nconst eq = ArrayUtil.eq;\n\nfunction equals(other)\n{\n    if(this === other)\n    {\n        return true;\n    }\n\n    if(other === null || other === undefined)\n    {\n        return false;\n    }\n\n    if(this.prototype !== other.prototype)\n    {\n        return false;\n    }\n\n    for(const key in this)\n    {\n        const e1 = this[key];\n        const e2 = other[key];\n        if(typeof e1 == \"function\")\n        {\n            continue; // Don't need to compare functions\n        }\n        else if(!eq(e1, e2))\n        {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction clone()\n{\n    const other = new this.constructor();\n    for(const key in this)\n    {\n        const e = this[key];\n        if(e === undefined || e === null)\n        {\n            other[key] = e;\n        }\n        else if(typeof e == \"function\")\n        {\n            continue;\n        }\n        else if(typeof e.clone == \"function\")\n        {\n            other[key] = e.clone();\n        }\n        else if(e instanceof Array)\n        {\n            other[key] = ArrayUtil.clone(e);\n        }\n        else\n        {\n            other[key] = e;\n        }\n    }\n    return other;\n}\n\nfunction memberHashCode(h, e)\n{\n    if(typeof e.hashCode == \"function\")\n    {\n        return Ice.HashUtil.addHashable(h, e);\n    }\n    else if(e instanceof Array)\n    {\n        return Ice.HashUtil.addArray(h, e, memberHashCode);\n    }\n    else\n    {\n        const t = typeof e;\n        if(e instanceof String || t == \"string\")\n        {\n            return Ice.HashUtil.addString(h, e);\n        }\n        else if(e instanceof Number || t == \"number\")\n        {\n            return Ice.HashUtil.addNumber(h, e);\n        }\n        else if(e instanceof Boolean || t == \"boolean\")\n        {\n            return Ice.HashUtil.addBoolean(h, e);\n        }\n    }\n}\n\nfunction hashCode()\n{\n    let h = 5381;\n    for(const key in this)\n    {\n        const e = this[key];\n        if(e === undefined || e === null || typeof e == \"function\")\n        {\n            continue;\n        }\n        h = memberHashCode(h, e);\n    }\n    return h;\n}\n\nIce.Slice.defineStruct = function(obj, legalKeyType, variableLength)\n{\n    obj.prototype.clone = clone;\n\n    obj.prototype.equals = equals;\n\n    //\n    // Only generate hashCode if this structure type is a legal dictionary key type.\n    //\n    if(legalKeyType)\n    {\n        obj.prototype.hashCode = hashCode;\n    }\n\n    if(obj.prototype._write && obj.prototype._read)\n    {\n        obj.write = function(os, v)\n        {\n            if(!v)\n            {\n                if(!obj.prototype._nullMarshalValue)\n                {\n                    obj.prototype._nullMarshalValue = new this();\n                }\n                v = obj.prototype._nullMarshalValue;\n            }\n            v._write(os);\n        };\n\n        obj.read = function(is, v)\n        {\n            if(!v || !(v instanceof this))\n            {\n                v = new this();\n            }\n            v._read(is);\n            return v;\n        };\n\n        if(variableLength)\n        {\n            Ice.StreamHelpers.FSizeOptHelper.call(obj);\n        }\n        else\n        {\n            Ice.StreamHelpers.VSizeOptHelper.call(obj);\n        }\n    }\n    return obj;\n};\nmodule.exports.Ice = Ice;\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/Struct.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/TcpEndpointFactory.js":
/*!********************************************************!*\
  !*** ./node_modules/ice/src/Ice/TcpEndpointFactory.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nconst Ice = (__webpack_require__(/*! ../Ice/TcpEndpointI */ \"./node_modules/ice/src/Ice/TcpEndpointI.js\").Ice);\nconst TcpEndpointI = Ice.TcpEndpointI;\n\nclass TcpEndpointFactory\n{\n    constructor(instance)\n    {\n        this._instance = instance;\n    }\n\n    type()\n    {\n        return this._instance.type();\n    }\n\n    protocol()\n    {\n        return this._instance.protocol();\n    }\n\n    create(args, oaEndpoint)\n    {\n        const e = new TcpEndpointI(this._instance);\n        e.initWithOptions(args, oaEndpoint);\n        return e;\n    }\n\n    read(s)\n    {\n        const e = new TcpEndpointI(this._instance);\n        e.initWithStream(s);\n        return e;\n    }\n\n    destroy()\n    {\n        this._instance = null;\n    }\n\n    clone(instance)\n    {\n        return new TcpEndpointFactory(instance);\n    }\n}\n\nIce.TcpEndpointFactory = TcpEndpointFactory;\nmodule.exports.Ice = Ice;\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/TcpEndpointFactory.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/TcpEndpointI.js":
/*!**************************************************!*\
  !*** ./node_modules/ice/src/Ice/TcpEndpointI.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nconst Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n\n__webpack_require__(/*! ../Ice/Debug */ \"./node_modules/ice/src/Ice/Debug.js\");\n__webpack_require__(/*! ../Ice/EndpointInfo */ \"./node_modules/ice/src/Ice/EndpointInfo.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/IPEndpointI */ \"./node_modules/ice/src/Ice/IPEndpointI.js\");\n__webpack_require__(/*! ../Ice/LocalException */ \"./node_modules/ice/src/Ice/LocalException.js\");\n__webpack_require__(/*! ../Ice/StringUtil */ \"./node_modules/ice/src/Ice/StringUtil.js\");\n__webpack_require__(/*! ../Ice/TcpTransceiver */ \"./node_modules/ice/src/Ice/TcpTransceiver.js\");\n\nconst IceSSL = (__webpack_require__(/*! ../Ice/EndpointInfo */ \"./node_modules/ice/src/Ice/EndpointInfo.js\").IceSSL);\n\nconst Debug = Ice.Debug;\nconst HashUtil = Ice.HashUtil;\nconst StringUtil = Ice.StringUtil;\n\nconst TcpTransceiver = typeof Ice.TcpTransceiver !== \"undefined\" ? Ice.TcpTransceiver : null;\n\nclass TcpEndpointI extends Ice.IPEndpointI\n{\n    constructor(instance, ho, po, sif, ti, conId, co)\n    {\n        super(instance, ho, po, sif, conId);\n        this._timeout = ti === undefined ? (instance ? instance.defaultTimeout() : undefined) : ti;\n        this._compress = co === undefined ? false : co;\n    }\n\n    //\n    // Return the endpoint information.\n    //\n    getInfo()\n    {\n        const info = new Ice.TCPEndpointInfo();\n        this.fillEndpointInfo(info);\n        return this.secure() ? new IceSSL.EndpointInfo(info, info.timeout, info.compress) : info;\n    }\n\n    //\n    // Return the timeout for the endpoint in milliseconds. 0 means\n    // non-blocking, -1 means no timeout.\n    //\n    timeout()\n    {\n        return this._timeout;\n    }\n\n    //\n    // Return a new endpoint with a different timeout value, provided\n    // that timeouts are supported by the endpoint. Otherwise the same\n    // endpoint is returned.\n    //\n    changeTimeout(timeout)\n    {\n        if(timeout === this._timeout)\n        {\n            return this;\n        }\n        else\n        {\n            return new TcpEndpointI(this._instance, this._host, this._port, this._sourceAddr, timeout,\n                                    this._connectionId, this._compress);\n        }\n    }\n\n    //\n    // Return a new endpoint with a different connection id.\n    //\n    changeConnectionId(connectionId)\n    {\n        if(connectionId === this._connectionId)\n        {\n            return this;\n        }\n        else\n        {\n            return new TcpEndpointI(this._instance, this._host, this._port, this._sourceAddr, this._timeout,\n                                    connectionId, this._compress);\n        }\n    }\n\n    //\n    // Return true if the endpoints support bzip2 compress, or false\n    // otherwise.\n    //\n    compress()\n    {\n        return this._compress;\n    }\n\n    //\n    // Return a new endpoint with a different compression value,\n    // provided that compression is supported by the\n    // endpoint. Otherwise the same endpoint is returned.\n    //\n    changeCompress(compress)\n    {\n        if(compress === this._compress)\n        {\n            return this;\n        }\n        else\n        {\n            return new TcpEndpointI(this._instance, this._host, this._port, this._sourceAddr, this._timeout,\n                                    this._connectionId, compress);\n        }\n    }\n\n    //\n    // Return true if the endpoint is datagram-based.\n    //\n    datagram()\n    {\n        return false;\n    }\n\n    connectable()\n    {\n        //\n        // TCP endpoints are not connectable when running in a browser, SSL\n        // isn't currently supported.\n        //\n        return typeof process !== 'undefined' && !this.secure();\n    }\n\n    connect()\n    {\n        Debug.assert(!this.secure());\n        return TcpTransceiver.createOutgoing(this._instance, this.getAddress(), this._sourceAddr);\n    }\n\n    //\n    // Convert the endpoint to its string form\n    //\n    options()\n    {\n        //\n        // WARNING: Certain features, such as proxy validation in Glacier2,\n        // depend on the format of proxy strings. Changes to toString() and\n        // methods called to generate parts of the reference string could break\n        // these features. Please review for all features that depend on the\n        // format of proxyToString() before changing this and related code.\n        //\n        let s = super.options();\n        if(this._timeout == -1)\n        {\n            s += \" -t infinite\";\n        }\n        else\n        {\n            s += \" -t \" + this._timeout;\n        }\n\n        if(this._compress)\n        {\n            s += \" -z\";\n        }\n        return s;\n    }\n\n    compareTo(p)\n    {\n        if(this === p)\n        {\n            return 0;\n        }\n\n        if(p === null)\n        {\n            return 1;\n        }\n\n        if(!(p instanceof TcpEndpointI))\n        {\n            return this.type() < p.type() ? -1 : 1;\n        }\n\n        if(this._timeout < p._timeout)\n        {\n            return -1;\n        }\n        else if(p._timeout < this._timeout)\n        {\n            return 1;\n        }\n\n        if(!this._compress && p._compress)\n        {\n            return -1;\n        }\n        else if(!p._compress && this._compress)\n        {\n            return 1;\n        }\n\n        return super.compareTo(p);\n    }\n\n    streamWriteImpl(s)\n    {\n        super.streamWriteImpl(s);\n        s.writeInt(this._timeout);\n        s.writeBool(this._compress);\n    }\n\n    hashInit(h)\n    {\n        h = super.hashInit(h);\n        h = HashUtil.addNumber(h, this._timeout);\n        h = HashUtil.addBoolean(h, this._compress);\n        return h;\n    }\n\n    fillEndpointInfo(info)\n    {\n        super.fillEndpointInfo(info);\n        info.timeout = this._timeout;\n        info.compress = this._compress;\n    }\n\n    initWithStream(s)\n    {\n        super.initWithStream(s);\n        this._timeout = s.readInt();\n        this._compress = s.readBool();\n    }\n\n    checkOption(option, argument, endpoint)\n    {\n        if(super.checkOption(option, argument, endpoint))\n        {\n            return true;\n        }\n\n        if(option === \"-t\")\n        {\n            if(argument === null)\n            {\n                throw new Ice.EndpointParseException(\"no argument provided for -t option in endpoint \" + endpoint);\n            }\n\n            if(argument == \"infinite\")\n            {\n                this._timeout = -1;\n            }\n            else\n            {\n                let invalid = false;\n                try\n                {\n                    this._timeout = StringUtil.toInt(argument);\n                }\n                catch(ex)\n                {\n                    invalid = true;\n                }\n                if(invalid || this._timeout < 1)\n                {\n                    throw new Ice.EndpointParseException(\"invalid timeout value `\" + argument + \"' in endpoint \" +\n                                                         endpoint);\n                }\n            }\n        }\n        else if(option === \"-z\")\n        {\n            if(argument !== null)\n            {\n                throw new Ice.EndpointParseException(\"unexpected argument `\" + argument +\n                                                     \"' provided for -z option in \" + endpoint);\n            }\n\n            this._compress = true;\n        }\n        else\n        {\n            return false;\n        }\n        return true;\n    }\n\n    createEndpoint(host, port, conId)\n    {\n        return new TcpEndpointI(this._instance, host, port, this._sourceAddr, this._timeout, conId, this._compress);\n    }\n}\n\nIce.TcpEndpointI = TcpEndpointI;\nmodule.exports.Ice = Ice;\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/TcpEndpointI.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/TcpTransceiver.js":
/*!****************************************************!*\
  !*** ./node_modules/ice/src/Ice/TcpTransceiver.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nconst Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n\n__webpack_require__(/*! ../Ice/Connection */ \"./node_modules/ice/src/Ice/Connection.js\");\n__webpack_require__(/*! ../Ice/Debug */ \"./node_modules/ice/src/Ice/Debug.js\");\n__webpack_require__(/*! ../Ice/Exception */ \"./node_modules/ice/src/Ice/Exception.js\");\n__webpack_require__(/*! ../Ice/SocketOperation */ \"./node_modules/ice/src/Ice/SocketOperation.js\");\n__webpack_require__(/*! ../Ice/Timer */ \"./node_modules/ice/src/Ice/Timer.js\");\n\nlet TcpTransceiver = {};\n\nif (typeof process !== 'undefined')\n{\n    const net = __webpack_require__(/*! net */ \"?c885\");\n\n    const Debug = Ice.Debug;\n    const SocketOperation = Ice.SocketOperation;\n    const Timer = Ice.Timer;\n\n    const StateNeedConnect = 0;\n    const StateConnectPending = 1;\n    const StateProxyConnectRequest = 2;\n    const StateProxyConnectRequestPending = 3;\n    const StateConnected = 4;\n\n    //\n    // TODO: WORKAROUND: We can directly use Buffer.from once we drop\n    // support for Node 4.x\n    //\n    let createBuffer = null;\n    if(Buffer.from)\n    {\n        createBuffer = Buffer.from;\n    }\n    else\n    {\n        /* eslint-disable no-buffer-constructor */\n        createBuffer = data => new Buffer(data);\n        /* eslint-enable no-buffer-constructor */\n    }\n\n    TcpTransceiver = class\n    {\n        constructor(instance)\n        {\n            this._logger = instance.logger();\n            this._readBuffers = [];\n            this._readPosition = 0;\n            this._maxSendPacketSize = instance.properties().getPropertyAsIntWithDefault(\"Ice.TCP.SndSize\", 512 * 1024);\n        }\n\n        setCallbacks(connectedCallback, bytesAvailableCallback, bytesWrittenCallback)\n        {\n            this._connectedCallback = connectedCallback;\n            this._bytesAvailableCallback = bytesAvailableCallback;\n            this._bytesWrittenCallback = bytesWrittenCallback;\n        }\n\n        //\n        // Returns SocketOperation.None when initialization is complete.\n        //\n        initialize(readBuffer, writeBuffer)\n        {\n            try\n            {\n                if(this._exception)\n                {\n                    throw this._exception;\n                }\n\n                if(this._state === StateNeedConnect)\n                {\n                    this._state = StateConnectPending;\n                    this._fd = net.createConnection(\n                        {\n                            port: this._addr.port,\n                            host: this._addr.host,\n                            localAddress: this._sourceAddr\n                        });\n\n                    this._fd.on(\"connect\", () => this.socketConnected());\n                    this._fd.on(\"data\", buf => this.socketBytesAvailable(buf));\n\n                    //\n                    // The error callback can be triggered from the socket\n                    // write(). We don't want it to dispached right away\n                    // from within the write() so we delay the call with\n                    // setImmediate. We do the same for close as a\n                    // precaution. See also issue #6226.\n                    //\n                    this._fd.on(\"close\", err => Timer.setImmediate(() => this.socketClosed(err)));\n                    this._fd.on(\"error\", err => Timer.setImmediate(() => this.socketError(err)));\n\n                    return SocketOperation.Connect; // Waiting for connect to complete.\n                }\n                else if(this._state === StateConnectPending)\n                {\n                    //\n                    // Socket is connected.\n                    //\n                    this._desc = fdToString(this._fd, this._proxy, this._addr);\n                    this._state = StateConnected;\n                }\n                else if(this._state === StateProxyConnectRequest)\n                {\n                    //\n                    // Write completed.\n                    //\n                    this._proxy.endWriteConnectRequest(writeBuffer);\n                    this._state = StateProxyConnectRequestPending; // Wait for proxy response\n                    return SocketOperation.Read;\n                }\n                else if(this._state === StateProxyConnectRequestPending)\n                {\n                    //\n                    // Read completed.\n                    //\n                    this._proxy.endReadConnectRequestResponse(readBuffer);\n                    this._state = StateConnected;\n                }\n            }\n            catch(err)\n            {\n                if(!this._exception)\n                {\n                    this._exception = translateError(this._state, err);\n                }\n                throw this._exception;\n            }\n\n            Debug.assert(this._state === StateConnected);\n            return SocketOperation.None;\n        }\n\n        register()\n        {\n            this._registered = true;\n            this._fd.resume();\n            if(this._exception)\n            {\n                this._bytesAvailableCallback();\n            }\n        }\n\n        unregister()\n        {\n            if(this._fd === null)\n            {\n                Debug.assert(this._exception); // Socket creation failed.\n                return;\n            }\n            this._registered = false;\n            this._fd.pause();\n        }\n\n        close()\n        {\n            if(this._fd === null)\n            {\n                Debug.assert(this._exception); // Socket creation failed.\n                return;\n            }\n\n            try\n            {\n                this._fd.destroy();\n            }\n            catch(ex)\n            {\n                throw translateError(this._state, ex);\n            }\n            finally\n            {\n                this._fd = null;\n            }\n        }\n\n        //\n        // Returns true if all of the data was flushed to the kernel buffer.\n        //\n        write(byteBuffer)\n        {\n            if(this._exception)\n            {\n                throw this._exception;\n            }\n\n            let packetSize = byteBuffer.remaining;\n            Debug.assert(packetSize > 0);\n\n            if(this._maxSendPacketSize > 0 && packetSize > this._maxSendPacketSize)\n            {\n                packetSize = this._maxSendPacketSize;\n            }\n\n            while(packetSize > 0)\n            {\n                const slice = byteBuffer.b.slice(byteBuffer.position, byteBuffer.position + packetSize);\n\n                let sync = true;\n                sync = this._fd.write(createBuffer(slice), null, () =>\n                    {\n                        if(!sync)\n                        {\n                            this._bytesWrittenCallback();\n                        }\n                    });\n\n                byteBuffer.position += packetSize;\n                if(!sync)\n                {\n                    return false; // Wait for callback to be called before sending more data.\n                }\n\n                if(this._maxSendPacketSize > 0 && byteBuffer.remaining > this._maxSendPacketSize)\n                {\n                    packetSize = this._maxSendPacketSize;\n                }\n                else\n                {\n                    packetSize = byteBuffer.remaining;\n                }\n            }\n            return true;\n        }\n\n        read(byteBuffer, moreData)\n        {\n            if(this._exception)\n            {\n                throw this._exception;\n            }\n\n            moreData.value = false;\n\n            if(this._readBuffers.length === 0)\n            {\n                return false; // No data available.\n            }\n\n            let avail = this._readBuffers[0].length - this._readPosition;\n            Debug.assert(avail > 0);\n\n            while(byteBuffer.remaining > 0)\n            {\n                if(avail > byteBuffer.remaining)\n                {\n                    avail = byteBuffer.remaining;\n                }\n\n                this._readBuffers[0].copy(createBuffer(byteBuffer.b), byteBuffer.position, this._readPosition,\n                                        this._readPosition + avail);\n\n                byteBuffer.position += avail;\n                this._readPosition += avail;\n                if(this._readPosition === this._readBuffers[0].length)\n                {\n                    //\n                    // We've exhausted the current read buffer.\n                    //\n                    this._readPosition = 0;\n                    this._readBuffers.shift();\n                    if(this._readBuffers.length === 0)\n                    {\n                        break; // No more data - we're done.\n                    }\n                    else\n                    {\n                        avail = this._readBuffers[0].length;\n                    }\n                }\n            }\n            moreData.value = this._readBuffers.length > 0;\n\n            return byteBuffer.remaining === 0;\n        }\n\n        type()\n        {\n            return \"tcp\";\n        }\n\n        getInfo()\n        {\n            Debug.assert(this._fd !== null);\n            const info = new Ice.TCPConnectionInfo();\n            info.localAddress = this._fd.localAddress;\n            info.localPort = this._fd.localPort;\n            info.remoteAddress = this._fd.remoteAddress;\n            info.remotePort = this._fd.remotePort;\n            info.rcvSize = -1;\n            info.sndSize = this._maxSendPacketSize;\n            return info;\n        }\n\n        checkSendSize(stream)\n        {\n        }\n\n        setBufferSize(rcvSize, sndSize)\n        {\n            this._maxSendPacketSize = sndSize;\n        }\n\n        toString()\n        {\n            return this._desc;\n        }\n\n        socketConnected()\n        {\n            Debug.assert(this._connectedCallback !== null);\n            this._connectedCallback();\n        }\n\n        socketBytesAvailable(buf)\n        {\n            Debug.assert(this._bytesAvailableCallback !== null);\n\n            //\n            // TODO: Should we set a limit on how much data we can read?\n            // We can call _fd.pause() to temporarily stop reading.\n            //\n            if(buf.length > 0)\n            {\n                this._readBuffers.push(buf);\n                this._bytesAvailableCallback();\n            }\n        }\n\n        socketClosed(err)\n        {\n            //\n            // Don't call the closed callback if an error occurred; the error callback\n            // will be called.\n            //\n            if(!err)\n            {\n                this.socketError(null);\n            }\n        }\n\n        socketError(err)\n        {\n            this._exception = translateError(this._state, err);\n            if(this._state < StateConnected)\n            {\n                this._connectedCallback();\n            }\n            else if(this._registered)\n            {\n                this._bytesAvailableCallback();\n            }\n        }\n\n        static createOutgoing(instance, addr, sourceAddr)\n        {\n            const transceiver = new TcpTransceiver(instance);\n\n            transceiver._fd = null;\n            transceiver._addr = addr;\n            transceiver._sourceAddr = sourceAddr;\n            transceiver._desc = \"local address = <not connected>\\nremote address = \" + addr.host + \":\" + addr.port;\n            transceiver._state = StateNeedConnect;\n            transceiver._registered = false;\n            transceiver._exception = null;\n\n            return transceiver;\n        }\n\n        static createIncoming(instance, fd)\n        {\n            const transceiver = new TcpTransceiver(instance);\n\n            transceiver._fd = fd;\n            transceiver._addr = null;\n            transceiver._sourceAddr = null;\n            transceiver._desc = fdToString(fd);\n            transceiver._state = StateConnected;\n            transceiver._registered = false;\n            transceiver._exception = null;\n\n            return transceiver;\n        }\n    }\n\n    function fdToString(fd, targetAddr)\n    {\n        if(fd === null)\n        {\n            return \"<closed>\";\n        }\n\n        return addressesToString(fd.localAddress, fd.localPort, fd.remoteAddress, fd.remotePort, targetAddr);\n    }\n\n    function translateError(state, err)\n    {\n        if(!err)\n        {\n            return new Ice.ConnectionLostException();\n        }\n        else if(state < StateConnected)\n        {\n            if(connectionRefused(err.code))\n            {\n                return new Ice.ConnectionRefusedException(err.code, err);\n            }\n            else if(connectionFailed(err.code))\n            {\n                return new Ice.ConnectFailedException(err.code, err);\n            }\n        }\n        else if(connectionLost(err.code))\n        {\n            return new Ice.ConnectionLostException(err.code, err);\n        }\n        return new Ice.SocketException(err.code, err);\n    }\n\n    function addressesToString(localHost, localPort, remoteHost, remotePort, targetAddr)\n    {\n        remoteHost = remoteHost === undefined ? null : remoteHost;\n        targetAddr = targetAddr === undefined ? null : targetAddr;\n\n        const s = [];\n        s.push(\"local address = \");\n        s.push(localHost + \":\" + localPort);\n\n        if(remoteHost === null && targetAddr !== null)\n        {\n            remoteHost = targetAddr.host;\n            remotePort = targetAddr.port;\n        }\n\n        if(remoteHost === null)\n        {\n            s.push(\"\\nremote address = <not connected>\");\n        }\n        else\n        {\n            s.push(\"\\nremote address = \");\n            s.push(remoteHost + \":\" + remotePort);\n        }\n\n        return s.join(\"\");\n    }\n\n    const ECONNABORTED = \"ECONNABORTED\";\n    const ECONNREFUSED = \"ECONNREFUSED\";\n    const ECONNRESET = \"ECONNRESET\";\n    const EHOSTUNREACH = \"EHOSTUNREACH\";\n    const ENETUNREACH = \"ENETUNREACH\";\n    const ENOTCONN = \"ENOTCONN\";\n    const EPIPE = \"EPIPE\";\n    const ESHUTDOWN = \"ESHUTDOWN\";\n    const ETIMEDOUT = \"ETIMEDOUT\";\n\n    function connectionRefused(err)\n    {\n        return err == ECONNREFUSED;\n    }\n\n    function connectionFailed(err)\n    {\n        return err == ECONNREFUSED || err == ETIMEDOUT ||\n            err == ENETUNREACH || err == EHOSTUNREACH ||\n            err == ECONNRESET || err == ESHUTDOWN ||\n            err == ECONNABORTED;\n    }\n\n    function connectionLost(err)\n    {\n        return err == ECONNRESET || err == ENOTCONN ||\n            err == ESHUTDOWN || err == ECONNABORTED ||\n            err == EPIPE;\n    }\n}\nelse\n{\n    TcpTransceiver = class {};\n}\n\nIce.TcpTransceiver = TcpTransceiver;\nmodule.exports.Ice = Ice;\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/TcpTransceiver.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/Timer.js":
/*!*******************************************!*\
  !*** ./node_modules/ice/src/Ice/Timer.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nconst Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n\n__webpack_require__(/*! ../Ice/LocalException */ \"./node_modules/ice/src/Ice/LocalException.js\");\n__webpack_require__(/*! ../Ice/TimerUtil */ \"./node_modules/ice/src/Ice/TimerUtil.js\");\n\nconst CommunicatorDestroyedException = Ice.CommunicatorDestroyedException;\n\nclass Timer\n{\n    constructor(logger)\n    {\n        this._logger = logger;\n        this._destroyed = false;\n        this._tokenId = 0;\n        this._tokens = new Map();\n    }\n\n    destroy()\n    {\n        this._tokens.forEach((value, key) => this.cancel(key));\n        this._destroyed = true;\n        this._tokens.clear();\n    }\n\n    schedule(callback, delay)\n    {\n        if(this._destroyed)\n        {\n            throw new CommunicatorDestroyedException();\n        }\n        const token = this._tokenId++;\n        const id = Timer.setTimeout(() => this.handleTimeout(token), delay);\n        this._tokens.set(token, {callback: callback, id: id, isInterval: false});\n        return token;\n    }\n\n    scheduleRepeated(callback, period)\n    {\n        if(this._destroyed)\n        {\n            throw new CommunicatorDestroyedException();\n        }\n        const token = this._tokenId++;\n        const id = Timer.setInterval(() => this.handleInterval(token), period);\n        this._tokens.set(token, {callback: callback, id: id, isInterval: true});\n        return token;\n    }\n\n    cancel(id)\n    {\n        if(this._destroyed)\n        {\n            return false;\n        }\n\n        const token = this._tokens.get(id);\n        if(token === undefined)\n        {\n            return false;\n        }\n\n        this._tokens.delete(id);\n        if(token.isInterval)\n        {\n            Timer.clearInterval(token.id);\n        }\n        else\n        {\n            Timer.clearTimeout(token.id);\n        }\n\n        return true;\n    }\n\n    handleTimeout(id)\n    {\n        if(this._destroyed)\n        {\n            return;\n        }\n\n        const token = this._tokens.get(id);\n        if(token !== undefined)\n        {\n            this._tokens.delete(id);\n            try\n            {\n                token.callback();\n            }\n            catch(ex)\n            {\n                this._logger.warning(\"uncaught exception while executing timer:\\n\" + ex);\n            }\n        }\n    }\n\n    handleInterval(id)\n    {\n        if(this._destroyed)\n        {\n            return;\n        }\n\n        const token = this._tokens.get(id);\n        if(token !== undefined)\n        {\n            try\n            {\n                token.callback();\n            }\n            catch(ex)\n            {\n                this._logger.warning(\"uncaught exception while executing timer:\\n\" + ex);\n            }\n        }\n    }\n}\n\nTimer.setTimeout = Ice.Timer.setTimeout;\nTimer.clearTimeout = Ice.Timer.clearTimeout;\nTimer.setInterval = Ice.Timer.setInterval;\nTimer.clearInterval = Ice.Timer.clearInterval;\nTimer.setImmediate = Ice.Timer.setImmediate;\n\nIce.Timer = Timer;\nmodule.exports.Ice = Ice;\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/Timer.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/TimerUtil.js":
/*!***********************************************!*\
  !*** ./node_modules/ice/src/Ice/TimerUtil.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nconst Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n\nlet Timer = {};\n\nif (typeof process != 'undefined')\n{\n    Timer = class\n    {\n    }\n\n    Timer.setTimeout = setTimeout;\n    Timer.clearTimeout = clearTimeout;\n    Timer.setInterval = setInterval;\n    Timer.clearInterval = clearInterval;\n    Timer.setImmediate = setImmediate;\n    Ice.Timer = Timer;\n}\nelse\n{\n    function isIE()\n    {\n        return (navigator.userAgent.indexOf(\"MSIE\") !== -1 || navigator.userAgent.match(/Trident.*rv:11\\./));\n    }\n\n    function isEdge()\n    {\n        return (/Edge/).test(navigator.userAgent);\n    }\n\n    function isWorker()\n    {\n        return typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope;\n    }\n\n    const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;\n    let _nextId = 0;\n    const nextId = function()\n    {\n        if(_nextId == MAX_SAFE_INTEGER)\n        {\n            _nextId = 0;\n        }\n        return _nextId++;\n    };\n    const _timers = new Map();\n\n    //\n    // Create a timer object that uses the default browser methods.\n    //\n    function createTimerObject()\n    {\n        const Timer = class\n        {\n            static setTimeout(cb, ms)\n            {\n                return setTimeout(cb, ms);\n            }\n\n            static clearTimeout(id)\n            {\n                return clearTimeout(id);\n            }\n\n            static setInterval(cb, ms)\n            {\n                return setInterval(cb, ms);\n            }\n\n            static clearInterval(id)\n            {\n                return clearInterval(id);\n            }\n        };\n\n        //\n        // For Browsers that support setImmediate prefer that,\n        // otherwise implement it using MessageChannel\n        //\n        if(isEdge() || isIE())\n        {\n            Timer.setImmediate = function(cb)\n            {\n                setImmediate(cb);\n            };\n        }\n        else\n        {\n            //\n            // Should be only call for workers\n            //\n            const channel = new MessageChannel();\n            channel.port1.onmessage = event =>\n            {\n                const id = event.data;\n                const cb = _timers.get(id);\n                if(cb !== undefined)\n                {\n                    cb.call();\n                    _timers.delete(id);\n                }\n            };\n\n            Timer.setImmediate = function(cb)\n            {\n                const id = nextId();\n                _timers.set(id, cb);\n                channel.port2.postMessage(id);\n            };\n        }\n\n        return Timer;\n    }\n\n    const _SetTimeoutType = 0;\n    const _SetIntervalType = 1;\n    const _SetImmediateType = 2;\n    const _ClearTimeoutType = 3;\n    const _ClearIntervalType = 4;\n\n    let worker;\n\n    class Timer\n    {\n        static setTimeout(cb, ms)\n        {\n            const id = nextId();\n            _timers.set(id, cb);\n            worker.postMessage({type: _SetTimeoutType, id: id, ms: ms});\n            return id;\n        }\n\n        static clearTimeout(id)\n        {\n            _timers.delete(id);\n            worker.postMessage({type: _ClearTimeoutType, id: id});\n        }\n\n        static setInterval(cb, ms)\n        {\n            const id = nextId();\n            _timers.set(id, cb);\n            worker.postMessage({type: _SetIntervalType, id: id, ms: ms});\n            return id;\n        }\n\n        static clearInterval(id)\n        {\n            _timers.delete(id);\n            worker.postMessage({type: _ClearIntervalType, id: id});\n        }\n\n        static setImmediate(cb)\n        {\n            const id = nextId();\n            _timers.set(id, cb);\n            worker.postMessage({type: _SetImmediateType, id: id});\n            return id;\n        }\n\n        static onmessage(e)\n        {\n            const cb = _timers.get(e.data.id);\n            if(cb !== undefined)\n            {\n                cb.call();\n                if(e.data.type !== _SetIntervalType)\n                {\n                    _timers.delete(e.data.id);\n                }\n            }\n        }\n    }\n\n    const workerCode = function()\n    {\n        return \"(\" +\n        function()\n        {\n            //\n            // jshint worker: true\n            //\n            const _wSetTimeoutType = 0;\n            const _wSetIntervalType = 1;\n            const _wSetImmediateType = 2;\n            const _wClearTimeoutType = 3;\n            const _wClearIntervalType = 4;\n\n            const timers = {};\n\n            self.onmessage = e =>\n            {\n                if(e.data.type == _wSetTimeoutType)\n                {\n                    timers[e.data.id] = setTimeout(() => self.postMessage(e.data), e.data.ms);\n                }\n                else if(e.data.type == _wSetIntervalType)\n                {\n                    timers[e.data.id] = setInterval(() => self.postMessage(e.data), e.data.ms);\n                }\n                else if(e.data.type == _wSetImmediateType)\n                {\n                    self.postMessage(e.data);\n                }\n                else if(e.data.type == _wClearTimeoutType)\n                {\n                    clearTimeout(timers[e.data.id]);\n                    delete timers[e.data.id];\n                }\n                else if(e.data.type == _wClearIntervalType)\n                {\n                    clearInterval(timers[e.data.id]);\n                    delete timers[e.data.id];\n                }\n            };\n\n            //\n            // jshint worker: false\n            //\n        }.toString() + \"());\";\n    };\n\n    if(isIE())\n    {\n        //\n        // With IE always use the setInterval/setTimeout browser functions directly\n        //\n        Ice.Timer = createTimerObject();\n    }\n    else if(isWorker())\n    {\n        //\n        // If we are running in a worker don't spawn a separate worker for the timer\n        //\n        Ice.Timer = createTimerObject();\n    }\n    else if(worker === undefined)\n    {\n        const url = URL.createObjectURL(new Blob([workerCode()], {type: 'text/javascript'}));\n        worker = new Worker(url);\n        worker.onmessage = Timer.onmessage;\n        Ice.Timer = Timer;\n    }\n}\n\nmodule.exports.Ice = Ice;\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/TimerUtil.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/ToStringMode.js":
/*!**************************************************!*\
  !*** ./node_modules/ice/src/Ice/ToStringMode.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nconst Ice = (__webpack_require__(/*! ../Ice/EnumBase */ \"./node_modules/ice/src/Ice/EnumBase.js\").Ice);\nIce.ToStringMode = Ice.Slice.defineEnum(\n    [\n        ['Unicode', 0],\n        ['ASCII', 1],\n        ['Compat', 2]\n    ]);\nmodule.exports.Ice = Ice;\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/ToStringMode.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/TraceLevels.js":
/*!*************************************************!*\
  !*** ./node_modules/ice/src/Ice/TraceLevels.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nconst Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n\nIce.TraceLevels = function(properties)\n{\n    const networkCat = \"Network\";\n    const protocolCat = \"Protocol\";\n    const retryCat = \"Retry\";\n    const locationCat = \"Locator\";\n    const slicingCat = \"Slicing\";\n\n    const keyBase = \"Ice.Trace.\";\n\n    const network = properties.getPropertyAsInt(keyBase + networkCat);\n    const protocol = properties.getPropertyAsInt(keyBase + protocolCat);\n    const retry = properties.getPropertyAsInt(keyBase + retryCat);\n    const location = properties.getPropertyAsInt(keyBase + locationCat);\n    const slicing = properties.getPropertyAsInt(keyBase + slicingCat);\n\n    properties.getPropertyAsInt(keyBase + \"ThreadPool\"); // Avoid an \"unused property\" warning.\n\n    return class\n    {\n        static get network()\n        {\n            return network;\n        }\n\n        static get networkCat()\n        {\n            return networkCat;\n        }\n\n        static get protocol()\n        {\n            return protocol;\n        }\n\n        static get protocolCat()\n        {\n            return protocolCat;\n        }\n\n        static get retry()\n        {\n            return retry;\n        }\n\n        static get retryCat()\n        {\n            return retryCat;\n        }\n\n        static get location()\n        {\n            return location;\n        }\n\n        static get locationCat()\n        {\n            return locationCat;\n        }\n\n        static get slicing()\n        {\n            return slicing;\n        }\n\n        static get slicingCat()\n        {\n            return slicingCat;\n        }\n    };\n};\nmodule.exports.Ice = Ice;\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/TraceLevels.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/TraceUtil.js":
/*!***********************************************!*\
  !*** ./node_modules/ice/src/Ice/TraceUtil.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nconst Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n\n__webpack_require__(/*! ../Ice/Current */ \"./node_modules/ice/src/Ice/Current.js\");\n__webpack_require__(/*! ../Ice/Debug */ \"./node_modules/ice/src/Ice/Debug.js\");\n__webpack_require__(/*! ../Ice/Identity */ \"./node_modules/ice/src/Ice/Identity.js\");\n__webpack_require__(/*! ../Ice/Protocol */ \"./node_modules/ice/src/Ice/Protocol.js\");\n__webpack_require__(/*! ../Ice/StringUtil */ \"./node_modules/ice/src/Ice/StringUtil.js\");\n\n//\n// Local aliases.\n//\nconst Debug = Ice.Debug;\nconst Identity = Ice.Identity;\nconst OperationMode = Ice.OperationMode;\nconst Protocol = Ice.Protocol;\nconst StringUtil = Ice.StringUtil;\n\nconst slicingIds = new Map();\n\nfunction printIdentityFacetOperation(s, stream)\n{\n    let toStringMode = Ice.ToStringMode.Unicode;\n    if(stream.instance !== null)\n    {\n        toStringMode = stream.instance.toStringMode();\n    }\n\n    const identity = new Identity();\n    identity._read(stream);\n    s.push(\"\\nidentity = \" + Ice.identityToString(identity, toStringMode));\n\n    const facet = Ice.StringSeqHelper.read(stream);\n    s.push(\"\\nfacet = \");\n    if(facet.length > 0)\n    {\n        s.push(StringUtil.escapeString(facet[0], \"\", toStringMode));\n    }\n\n    const operation = stream.readString();\n    s.push(\"\\noperation = \" + operation);\n}\n\nfunction printRequest(s, stream)\n{\n    const requestId = stream.readInt();\n    s.push(\"\\nrequest id = \" + requestId);\n    if(requestId === 0)\n    {\n        s.push(\" (oneway)\");\n    }\n\n    printRequestHeader(s, stream);\n}\n\nfunction printBatchRequest(s, stream)\n{\n    const batchRequestNum = stream.readInt();\n    s.push(\"\\nnumber of requests = \" + batchRequestNum);\n\n    for(let i = 0; i < batchRequestNum; ++i)\n    {\n        s.push(\"\\nrequest #\" + i + ':');\n        printRequestHeader(s, stream);\n    }\n}\n\nfunction printReply(s, stream)\n{\n    const requestId = stream.readInt();\n    s.push(\"\\nrequest id = \" + requestId);\n\n    const replyStatus = stream.readByte();\n    s.push(\"\\nreply status = \" + replyStatus + ' ');\n\n    switch(replyStatus)\n    {\n    case Protocol.replyOK:\n    {\n        s.push(\"(ok)\");\n        break;\n    }\n\n    case Protocol.replyUserException:\n    {\n        s.push(\"(user exception)\");\n        break;\n    }\n\n    case Protocol.replyObjectNotExist:\n    case Protocol.replyFacetNotExist:\n    case Protocol.replyOperationNotExist:\n    {\n        switch(replyStatus)\n        {\n        case Protocol.replyObjectNotExist:\n        {\n            s.push(\"(object not exist)\");\n            break;\n        }\n\n        case Protocol.replyFacetNotExist:\n        {\n            s.push(\"(facet not exist)\");\n            break;\n        }\n\n        case Protocol.replyOperationNotExist:\n        {\n            s.push(\"(operation not exist)\");\n            break;\n        }\n\n        default:\n        {\n            Debug.assert(false);\n            break;\n        }\n        }\n\n        printIdentityFacetOperation(s, stream);\n        break;\n    }\n\n    case Protocol.replyUnknownException:\n    case Protocol.replyUnknownLocalException:\n    case Protocol.replyUnknownUserException:\n    {\n        switch(replyStatus)\n        {\n        case Protocol.replyUnknownException:\n        {\n            s.push(\"(unknown exception)\");\n            break;\n        }\n\n        case Protocol.replyUnknownLocalException:\n        {\n            s.push(\"(unknown local exception)\");\n            break;\n        }\n\n        case Protocol.replyUnknownUserException:\n        {\n            s.push(\"(unknown user exception)\");\n            break;\n        }\n\n        default:\n        {\n            Debug.assert(false);\n            break;\n        }\n        }\n\n        const unknown = stream.readString();\n        s.push(\"\\nunknown = \" + unknown);\n        break;\n    }\n\n    default:\n    {\n        s.push(\"(unknown)\");\n        break;\n    }\n    }\n\n    if(replyStatus === Protocol.replyOK || replyStatus === Protocol.replyUserException)\n    {\n        const ver = stream.skipEncapsulation();\n        if(!ver.equals(Ice.Encoding_1_0))\n        {\n            s.push(\"\\nencoding = \");\n            s.push(Ice.encodingVersionToString(ver));\n        }\n    }\n}\n\nfunction printRequestHeader(s, stream)\n{\n    printIdentityFacetOperation(s, stream);\n\n    const mode = stream.readByte();\n    s.push(\"\\nmode = \" + mode + ' ');\n    switch(OperationMode.valueOf(mode))\n    {\n        case OperationMode.Normal:\n        {\n            s.push(\"(normal)\");\n            break;\n        }\n\n        case OperationMode.Nonmutating:\n        {\n            s.push(\"(nonmutating)\");\n            break;\n        }\n\n        case OperationMode.Idempotent:\n        {\n            s.push(\"(idempotent)\");\n            break;\n        }\n\n        default:\n        {\n            s.push(\"(unknown)\");\n            break;\n        }\n    }\n\n    let sz = stream.readSize();\n    s.push(\"\\ncontext = \");\n    while(sz-- > 0)\n    {\n        const key = stream.readString();\n        const value = stream.readString();\n        s.push(key + '/' + value);\n        if(sz > 0)\n        {\n            s.push(\", \");\n        }\n    }\n\n    const ver = stream.skipEncapsulation();\n    if(!ver.equals(Ice.Encoding_1_0))\n    {\n        s.push(\"\\nencoding = \");\n        s.push(Ice.encodingVersionToString(ver));\n    }\n}\n\nfunction printHeader(s, stream)\n{\n    stream.readByte(); // Don't bother printing the magic number\n    stream.readByte();\n    stream.readByte();\n    stream.readByte();\n\n//        const pMajor = stream.readByte();\n//        const pMinor = stream.readByte();\n//        s.push(\"\\nprotocol version = \" + pMajor + \".\" + pMinor);\n    stream.readByte(); // major\n    stream.readByte(); // minor\n\n//        const eMajor = stream.readByte();\n//        const eMinor = stream.readByte();\n//        s.push(\"\\nencoding version = \" + eMajor + \".\" + eMinor);\n    stream.readByte(); // major\n    stream.readByte(); // minor\n\n    const type = stream.readByte();\n\n    s.push(\"\\nmessage type = \" + type + \" (\" + getMessageTypeAsString(type) + ')');\n    const compress = stream.readByte();\n    s.push(\"\\ncompression status = \" + compress + ' ');\n    switch(compress)\n    {\n        case 0:\n        {\n            s.push(\"(not compressed; do not compress response, if any)\");\n            break;\n        }\n\n        case 1:\n        {\n            s.push(\"(not compressed; compress response, if any)\");\n            break;\n        }\n\n        case 2:\n        {\n            s.push(\"(compressed; compress response, if any)\");\n            break;\n        }\n\n        default:\n        {\n            s.push(\"(unknown)\");\n            break;\n        }\n    }\n\n    const size = stream.readInt();\n    s.push(\"\\nmessage size = \" + size);\n    return type;\n}\n\nfunction printMessage(s, stream)\n{\n    const type = printHeader(s, stream);\n\n    switch(type)\n    {\n    case Protocol.closeConnectionMsg:\n    case Protocol.validateConnectionMsg:\n    {\n        // We're done.\n        break;\n    }\n\n    case Protocol.requestMsg:\n    {\n        printRequest(s, stream);\n        break;\n    }\n\n    case Protocol.requestBatchMsg:\n    {\n        printBatchRequest(s, stream);\n        break;\n    }\n\n    case Protocol.replyMsg:\n    {\n        printReply(s, stream);\n        break;\n    }\n\n    default:\n    {\n        break;\n    }\n    }\n\n    return type;\n}\n\nfunction getMessageTypeAsString(type)\n{\n    switch(type)\n    {\n    case Protocol.requestMsg:\n        return \"request\";\n    case Protocol.requestBatchMsg:\n        return \"batch request\";\n    case Protocol.replyMsg:\n        return \"reply\";\n    case Protocol.closeConnectionMsg:\n        return \"close connection\";\n    case Protocol.validateConnectionMsg:\n        return \"validate connection\";\n    default:\n        return \"unknown\";\n    }\n}\n\nclass TraceUtil\n{\n    static traceSlicing(kind, typeId, slicingCat, logger)\n    {\n        if(!slicingIds.has(typeId))\n        {\n            logger.trace(slicingCat, `unknown ${kind} type \\`${typeId}'`);\n            slicingIds.set(typeId, 1);\n        }\n    }\n\n    static traceSend(stream, logger, traceLevels)\n    {\n        if(traceLevels.protocol >= 1)\n        {\n            const p = stream.pos;\n            const is = new Ice.InputStream(stream.instance, stream.getEncoding(), stream.buffer);\n            is.pos = 0;\n\n            const s = [];\n            const type = printMessage(s, is);\n\n            logger.trace(traceLevels.protocolCat, \"sending \" + getMessageTypeAsString(type) + \" \" + s.join(\"\"));\n\n            stream.pos = p;\n        }\n    }\n\n    static traceRecv(stream, logger, traceLevels)\n    {\n        if(traceLevels.protocol >= 1)\n        {\n            const p = stream.pos;\n            stream.pos = 0;\n\n            const s = [];\n            const type = printMessage(s, stream);\n\n            logger.trace(traceLevels.protocolCat, \"received \" + getMessageTypeAsString(type) + \" \" + s.join(\"\"));\n\n            stream.pos = p;\n        }\n    }\n\n    static traceOut(heading, stream, logger, traceLevels)\n    {\n        if(traceLevels.protocol >= 1)\n        {\n            const p = stream.pos;\n            const is = new Ice.InputStream(stream.instance, stream.getEncoding(), stream.buffer);\n            is.pos = 0;\n\n            const s = [];\n            s.push(heading);\n            printMessage(s, is);\n\n            logger.trace(traceLevels.protocolCat, s.join(\"\"));\n            stream.pos = p;\n        }\n    }\n\n    static traceIn(heading, stream, logger, traceLevels)\n    {\n        if(traceLevels.protocol >= 1)\n        {\n            const p = stream.pos;\n            stream.pos = 0;\n\n            const s = [];\n            s.push(heading);\n            printMessage(s, stream);\n\n            logger.trace(traceLevels.protocolCat, s.join(\"\"));\n            stream.pos = p;\n        }\n    }\n\n    static dumpStream(stream)\n    {\n        const pos = stream.pos;\n        stream.pos = 0;\n\n        const data = stream.readBlob(stream.size());\n        TraceUtil.dumpOctets(data);\n\n        stream.pos = pos;\n    }\n\n    static dumpOctets(data)\n    {\n        const inc = 8;\n        const buf = [];\n\n        for(let i = 0; i < data.length; i += inc)\n        {\n            for(let j = i; j - i < inc; j++)\n            {\n                if(j < data.length)\n                {\n                    let n = data[j];\n                    if(n < 0)\n                    {\n                        n += 256;\n                    }\n                    let s;\n                    if(n < 10)\n                    {\n                        s = \"  \" + n;\n                    }\n                    else if(n < 100)\n                    {\n                        s = \" \" + n;\n                    }\n                    else\n                    {\n                        s = String(n);\n                    }\n                    buf.push(s + \" \");\n                }\n                else\n                {\n                    buf.push(\"    \");\n                }\n            }\n\n            buf.push('\"');\n\n            for(let j = i; j < data.length && j - i < inc; j++)\n            {\n                if(data[j] >= 32 && data[j] < 127)\n                {\n                    buf.push(String.fromCharCode(data[j]));\n                }\n                else\n                {\n                    buf.push('.');\n                }\n            }\n\n            buf.push(\"\\\"\\n\");\n        }\n\n        console.log(buf.join(\"\"));\n    }\n}\n\nIce.TraceUtil = TraceUtil;\nmodule.exports.Ice = Ice;\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/TraceUtil.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/UUID.js":
/*!******************************************!*\
  !*** ./node_modules/ice/src/Ice/UUID.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nfunction generateUUID()\n{\n    let d = new Date().getTime();\n    const uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {\n        const r = (d + Math.random() * 16) % 16 | 0;\n        d = Math.floor(d / 16);\n        return (c == 'x' ? r : (r & 0x3 | 0x8)).toString(16);\n    });\n    return uuid;\n}\n\nconst Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\nIce.generateUUID = generateUUID;\nmodule.exports.Ice = Ice;\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/UUID.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/UnknownSlicedValue.js":
/*!********************************************************!*\
  !*** ./node_modules/ice/src/Ice/UnknownSlicedValue.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nconst Ice = (__webpack_require__(/*! ../Ice/Value */ \"./node_modules/ice/src/Ice/Value.js\").Ice);\n\nclass SliceInfo\n{\n    constructor()\n    {\n        //\n        // The Slice type ID for this slice.\n        //\n        this.typeId = \"\";\n\n        //\n        // The Slice compact type ID for this slice.\n        //\n        this.compactId = -1;\n\n        //\n        // The encoded bytes for this slice, including the leading size integer.\n        //\n        this.bytes = [];\n\n        //\n        // The class instances referenced by this slice.\n        //\n        this.instances = [];\n\n        //\n        // Whether or not the slice contains optional members.\n        //\n        this.hasOptionalMembers = false;\n\n        //\n        // Whether or not this is the last slice.\n        //\n        this.isLastSlice = false;\n    }\n}\nIce.SliceInfo = SliceInfo;\n\nclass SlicedData\n{\n    constructor(slices)\n    {\n        this.slices = slices;\n    }\n}\nIce.SlicedData = SlicedData;\n\nclass UnknownSlicedValue extends Ice.Value\n{\n    constructor(unknownTypeId)\n    {\n        super();\n        this._unknownTypeId = unknownTypeId;\n    }\n\n    ice_getSlicedData()\n    {\n        return this._slicedData;\n    }\n\n    ice_id()\n    {\n        return this._unknownTypeId;\n    }\n\n    _iceWrite(os)\n    {\n        os.startValue(this._slicedData);\n        os.endValue();\n    }\n\n    _iceRead(is)\n    {\n        is.startValue();\n        this._slicedData = is.endValue(true);\n    }\n}\nIce.UnknownSlicedValue = UnknownSlicedValue;\n\nmodule.exports.Ice = Ice;\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/UnknownSlicedValue.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/Value.js":
/*!*******************************************!*\
  !*** ./node_modules/ice/src/Ice/Value.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\n//\n// Ice.Value\n//\nconst Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n__webpack_require__(/*! ../Ice/Exception */ \"./node_modules/ice/src/Ice/Exception.js\");\n__webpack_require__(/*! ../Ice/FormatType */ \"./node_modules/ice/src/Ice/FormatType.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\n__webpack_require__(/*! ../Ice/OptionalFormat */ \"./node_modules/ice/src/Ice/OptionalFormat.js\");\n\nIce.Value = class\n{\n    ice_preMarshal()\n    {\n    }\n\n    ice_postUnmarshal()\n    {\n    }\n\n    ice_getSlicedData()\n    {\n        return null;\n    }\n\n    _iceWrite(os)\n    {\n        os.startValue(null);\n        writeImpl(this, os, this._iceMostDerivedType());\n        os.endValue();\n    }\n\n    _iceRead(is)\n    {\n        is.startValue();\n        readImpl(this, is, this._iceMostDerivedType());\n        is.endValue(false);\n    }\n\n    //\n    // These methods are used for object parameters.\n    //\n    static write(os, v)\n    {\n        os.writeValue(v);\n    }\n\n    static writeOptional(os, tag, v)\n    {\n        os.writeOptionalValue(tag, v);\n    }\n\n    static read(is)\n    {\n        const v = {value: null};\n        is.readValue(o =>\n                     {\n                         v.value = o;\n                     }, this);\n        return v;\n    }\n\n    static readOptional(is, tag)\n    {\n        const v = {value: undefined};\n        is.readOptionalValue(tag, o =>\n                             {\n                                 v.value = o;\n                             }, this);\n        return v;\n    }\n};\n\nIce.InterfaceByValue = class extends Ice.Value\n{\n    constructor(id)\n    {\n        super();\n        this._id = id;\n    }\n\n    ice_id()\n    {\n        return this._id;\n    }\n\n    _iceWrite(os)\n    {\n        os.startValue(null);\n        os.startSlice(this.ice_id(), -1, true);\n        os.endSlice();\n        os.endValue();\n    }\n\n    _iceRead(is)\n    {\n        is.startValue();\n        is.startSlice();\n        is.endSlice();\n        is.endValue(false);\n    }\n};\n\n//\n// Private methods\n//\nconst writeImpl = function(obj, os, type)\n{\n    //\n    // The writeImpl method is a recursive method that goes down the\n    // class hierarchy to marshal each slice of the class using the\n    // generated _iceWriteMemberImpl method.\n    //\n\n    if(type === undefined || type === Ice.Value)\n    {\n        return; // Don't marshal anything for Ice.Value\n    }\n\n    os.startSlice(type.ice_staticId(),\n                  Object.prototype.hasOwnProperty.call(type, '_iceCompactId') ? type._iceCompactId : -1,\n                  Object.getPrototypeOf(type) === Ice.Value);\n    if(type.prototype.hasOwnProperty('_iceWriteMemberImpl'))\n    {\n        type.prototype._iceWriteMemberImpl.call(obj, os);\n    }\n    os.endSlice();\n    writeImpl(obj, os, Object.getPrototypeOf(type));\n};\n\nconst readImpl = function(obj, is, type)\n{\n    //\n    // The readImpl method is a recursive method that goes down the\n    // class hierarchy to unmarshal each slice of the class using the\n    // generated _iceReadMemberImpl method.\n    //\n\n    if(type === undefined || type === Ice.Value)\n    {\n        return; // Don't unmarshal anything for Ice.Value\n    }\n\n    is.startSlice();\n    if(type.prototype.hasOwnProperty('_iceReadMemberImpl'))\n    {\n        type.prototype._iceReadMemberImpl.call(obj, is);\n    }\n    is.endSlice();\n    readImpl(obj, is, Object.getPrototypeOf(type));\n};\n\nfunction writePreserved(os)\n{\n    //\n    // For Slice classes which are marked \"preserved\", the implementation of this method\n    // replaces the Ice.Value.prototype._iceWrite method.\n    //\n    os.startValue(this._iceSlicedData);\n    writeImpl(this, os, this._iceMostDerivedType());\n    os.endValue();\n}\n\nfunction readPreserved(is)\n{\n    //\n    // For Slice classes which are marked \"preserved\", the implementation of this method\n    // replaces the Ice.Value.prototype._iceRead method.\n    //\n    is.startValue();\n    readImpl(this, is, this._iceMostDerivedType());\n    this._iceSlicedData = is.endValue(true);\n}\n\nfunction ice_getSlicedData()\n{\n    return this._iceSlicedData;\n}\n\nconst Slice = Ice.Slice;\n\nSlice.defineValue = function(valueType, id, preserved, compactId = 0)\n{\n    valueType.prototype.ice_id = function()\n    {\n        return id;\n    };\n\n    valueType.prototype._iceMostDerivedType = function()\n    {\n        return valueType;\n    };\n\n    valueType.ice_staticId = function()\n    {\n        return id;\n    };\n\n    if(preserved)\n    {\n        valueType.prototype.ice_getSlicedData = ice_getSlicedData;\n        valueType.prototype._iceWrite = writePreserved;\n        valueType.prototype._iceRead = readPreserved;\n    }\n\n    if(compactId > 0)\n    {\n        Ice.CompactIdRegistry.set(compactId, id);\n    }\n};\nSlice.defineValue(Ice.Value, \"::Ice::Object\");\n\nmodule.exports.Ice = Ice;\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/Value.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/ValueFactory.js":
/*!**************************************************!*\
  !*** ./node_modules/ice/src/Ice/ValueFactory.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n//\n// Ice version 3.7.10\n//\n// <auto-generated>\n//\n// Generated from file `ValueFactory.ice'\n//\n// Warning: do not edit this file.\n//\n// </auto-generated>\n//\n\n/* eslint-disable */\n/* jshint ignore: start */\n\n/* slice2js browser-bundle-skip */\nconst _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\n__webpack_require__(/*! ../Ice/Object */ \"./node_modules/ice/src/Ice/Object.js\");\n__webpack_require__(/*! ../Ice/Value */ \"./node_modules/ice/src/Ice/Value.js\");\n__webpack_require__(/*! ../Ice/ObjectPrx */ \"./node_modules/ice/src/Ice/ObjectPrx.js\");\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\nconst Ice = _ModuleRegistry.module(\"Ice\");\n\nconst Slice = Ice.Slice;\n/* slice2js browser-bundle-skip-end */\n/* slice2js browser-bundle-skip */\nexports.Ice = Ice;\n/* slice2js browser-bundle-skip-end */\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/ValueFactory.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/ValueFactoryManagerI.js":
/*!**********************************************************!*\
  !*** ./node_modules/ice/src/Ice/ValueFactoryManagerI.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nconst Ice = (__webpack_require__(/*! ../Ice/LocalException */ \"./node_modules/ice/src/Ice/LocalException.js\").Ice);\n\nconst AlreadyRegisteredException = Ice.AlreadyRegisteredException;\n\n//\n// Only for use by Instance\n//\nclass ValueFactoryManagerI\n{\n    constructor()\n    {\n        this._factoryMap = new Map(); // Map<String, ValueFactory>\n    }\n\n    add(factory, id)\n    {\n        if(this._factoryMap.has(id))\n        {\n            throw new AlreadyRegisteredException(\"value factory\", id);\n        }\n        this._factoryMap.set(id, factory);\n    }\n\n    find(id)\n    {\n        return this._factoryMap.get(id);\n    }\n\n    destroy()\n    {\n        this._factoryMap = new Map(); // Map<String, ValueFactory>\n    }\n}\n\nIce.ValueFactoryManagerI = ValueFactoryManagerI;\nmodule.exports.Ice = Ice;\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/ValueFactoryManagerI.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/Version.js":
/*!*********************************************!*\
  !*** ./node_modules/ice/src/Ice/Version.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n//\n// Ice version 3.7.10\n//\n// <auto-generated>\n//\n// Generated from file `Version.ice'\n//\n// Warning: do not edit this file.\n//\n// </auto-generated>\n//\n\n/* eslint-disable */\n/* jshint ignore: start */\n\n/* slice2js browser-bundle-skip */\nconst _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\n__webpack_require__(/*! ../Ice/Struct */ \"./node_modules/ice/src/Ice/Struct.js\");\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\nconst Ice = _ModuleRegistry.module(\"Ice\");\n\nconst Slice = Ice.Slice;\n/* slice2js browser-bundle-skip-end */\n\n/**\n * A version structure for the protocol version.\n *\n **/\nIce.ProtocolVersion = class\n{\n    constructor(major = 0, minor = 0)\n    {\n        this.major = major;\n        this.minor = minor;\n    }\n\n    _write(ostr)\n    {\n        ostr.writeByte(this.major);\n        ostr.writeByte(this.minor);\n    }\n\n    _read(istr)\n    {\n        this.major = istr.readByte();\n        this.minor = istr.readByte();\n    }\n\n    static get minWireSize()\n    {\n        return  2;\n    }\n};\n\nSlice.defineStruct(Ice.ProtocolVersion, true, false);\n\n/**\n * A version structure for the encoding version.\n *\n **/\nIce.EncodingVersion = class\n{\n    constructor(major = 0, minor = 0)\n    {\n        this.major = major;\n        this.minor = minor;\n    }\n\n    _write(ostr)\n    {\n        ostr.writeByte(this.major);\n        ostr.writeByte(this.minor);\n    }\n\n    _read(istr)\n    {\n        this.major = istr.readByte();\n        this.minor = istr.readByte();\n    }\n\n    static get minWireSize()\n    {\n        return  2;\n    }\n};\n\nSlice.defineStruct(Ice.EncodingVersion, true, false);\n/* slice2js browser-bundle-skip */\nexports.Ice = Ice;\n/* slice2js browser-bundle-skip-end */\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/Version.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/WSEndpoint.js":
/*!************************************************!*\
  !*** ./node_modules/ice/src/Ice/WSEndpoint.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nconst Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n\n__webpack_require__(/*! ../Ice/EndpointI */ \"./node_modules/ice/src/Ice/EndpointI.js\");\n__webpack_require__(/*! ../Ice/EndpointInfo */ \"./node_modules/ice/src/Ice/EndpointInfo.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/LocalException */ \"./node_modules/ice/src/Ice/LocalException.js\");\n__webpack_require__(/*! ../Ice/WSTransceiver */ \"./node_modules/ice/src/Ice/WSTransceiver.js\");\n\nconst EndpointI = Ice.EndpointI;\nconst HashUtil = Ice.HashUtil;\n\nclass WSEndpoint extends EndpointI\n{\n    constructor(instance, del, re)\n    {\n        super();\n        this._instance = instance;\n        this._delegate = del;\n        this._resource = re || \"/\";\n    }\n\n    getInfo()\n    {\n        const info = new Ice.WSEndpointInfo();\n        info.type = () => this.type();\n        info.datagram = () => this.datagram();\n        info.secure = () => this.secure();\n        info.resource = this._resource;\n        info.underlying = this._delegate.getInfo();\n        info.timeout = info.underlying.timeout;\n        info.compress = info.underlying.compress;\n        return info;\n    }\n\n    type()\n    {\n        return this._delegate.type();\n    }\n\n    protocol()\n    {\n        return this._delegate.protocol();\n    }\n\n    streamWrite(s)\n    {\n        s.startEncapsulation();\n        this._delegate.streamWriteImpl(s);\n        s.writeString(this._resource);\n        s.endEncapsulation();\n    }\n\n    timeout()\n    {\n        return this._delegate.timeout();\n    }\n\n    changeTimeout(timeout)\n    {\n        if(timeout === this._delegate.timeout())\n        {\n            return this;\n        }\n        else\n        {\n            return new WSEndpoint(this._instance, this._delegate.changeTimeout(timeout), this._resource);\n        }\n    }\n\n    changeConnectionId(connectionId)\n    {\n        if(connectionId === this._delegate.connectionId())\n        {\n            return this;\n        }\n        else\n        {\n            return new WSEndpoint(this._instance, this._delegate.changeConnectionId(connectionId), this._resource);\n        }\n    }\n\n    compress()\n    {\n        return this._delegate.compress();\n    }\n\n    changeCompress(compress)\n    {\n        if(compress === this._delegate.compress())\n        {\n            return this;\n        }\n        else\n        {\n            return new WSEndpoint(this._instance, this._delegate.changeCompress(compress), this._resource);\n        }\n    }\n\n    datagram()\n    {\n        return this._delegate.datagram();\n    }\n\n    secure()\n    {\n        return this._delegate.secure();\n    }\n\n    connect()\n    {\n        return Ice.WSTransceiver.createOutgoing(this._instance,\n                                                this._delegate.secure(),\n                                                this._delegate.getAddress(),\n                                                this._resource);\n    }\n\n    hashCode()\n    {\n        if(this._hashCode === undefined)\n        {\n            this._hashCode = this._delegate.hashCode();\n            this._hashCode = HashUtil.addString(this._hashCode, this._resource);\n        }\n        return this._hashCode;\n    }\n\n    compareTo(p)\n    {\n        if(this === p)\n        {\n            return 0;\n        }\n\n        if(p === null)\n        {\n            return 1;\n        }\n\n        if(!(p instanceof WSEndpoint))\n        {\n            return this.type() < p.type() ? -1 : 1;\n        }\n\n        const r = this._delegate.compareTo(p._delegate);\n        if(r !== 0)\n        {\n            return r;\n        }\n\n        if(this._resource !== p._resource)\n        {\n            return this._resource < p._resource ? -1 : 1;\n        }\n\n        return 0;\n    }\n\n    options()\n    {\n        //\n        // WARNING: Certain features, such as proxy validation in Glacier2,\n        // depend on the format of proxy strings. Changes to toString() and\n        // methods called to generate parts of the reference string could break\n        // these features. Please review for all features that depend on the\n        // format of proxyToString() before changing this and related code.\n        //\n        let s = this._delegate.options();\n\n        if(this._resource !== null && this._resource.length > 0)\n        {\n            s += \" -r \";\n            s += (this._resource.indexOf(':') !== -1) ? (\"\\\"\" + this._resource + \"\\\"\") : this._resource;\n        }\n\n        return s;\n    }\n\n    toConnectorString()\n    {\n        return this._delegate.toConnectorString();\n    }\n\n    initWithStream(s)\n    {\n        this._resource = s.readString();\n    }\n\n    checkOption(option, argument, endpoint)\n    {\n        if(option === \"-r\")\n        {\n            if(argument === null)\n            {\n                throw new Ice.EndpointParseException(\"no argument provided for -r option in endpoint \" + endpoint);\n            }\n            this._resource = argument;\n        }\n        else\n        {\n            return false;\n        }\n        return true;\n    }\n\n    connectable()\n    {\n        return typeof WebSocket !== \"undefined\";\n    }\n}\n\nIce.WSEndpoint = WSEndpoint;\nexports.Ice = Ice;\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/WSEndpoint.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/WSEndpointFactory.js":
/*!*******************************************************!*\
  !*** ./node_modules/ice/src/Ice/WSEndpointFactory.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nconst Ice = (__webpack_require__(/*! ../Ice/WSEndpoint */ \"./node_modules/ice/src/Ice/WSEndpoint.js\").Ice);\nconst WSEndpoint = Ice.WSEndpoint;\n\nclass WSEndpointFactory\n{\n    constructor(instance, delegate)\n    {\n        this._instance = instance;\n        this._delegate = delegate;\n    }\n\n    type()\n    {\n        return this._instance.type();\n    }\n\n    protocol()\n    {\n        return this._instance.protocol();\n    }\n\n    create(args, oaEndpoint)\n    {\n        const e = new WSEndpoint(this._instance, this._delegate.create(args, oaEndpoint));\n        e.initWithOptions(args);\n        return e;\n    }\n\n    read(s)\n    {\n        const e = new WSEndpoint(this._instance, this._delegate.read(s));\n        e.initWithStream(s);\n        return e;\n    }\n\n    destroy()\n    {\n        this._delegate.destroy();\n        this._instance = null;\n    }\n}\n\nIce.WSEndpointFactory = WSEndpointFactory;\nexports.Ice = Ice;\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/WSEndpointFactory.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/Ice/WSTransceiver.js":
/*!***************************************************!*\
  !*** ./node_modules/ice/src/Ice/WSTransceiver.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{\n//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nconst Ice = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice);\n\n__webpack_require__(/*! ../Ice/ConnectionInfo */ \"./node_modules/ice/src/Ice/ConnectionInfo.js\");\n__webpack_require__(/*! ../Ice/Debug */ \"./node_modules/ice/src/Ice/Debug.js\");\n__webpack_require__(/*! ../Ice/Exception */ \"./node_modules/ice/src/Ice/Exception.js\");\n__webpack_require__(/*! ../Ice/LocalException */ \"./node_modules/ice/src/Ice/LocalException.js\");\n__webpack_require__(/*! ../Ice/SocketOperation */ \"./node_modules/ice/src/Ice/SocketOperation.js\");\n__webpack_require__(/*! ../Ice/Timer */ \"./node_modules/ice/src/Ice/Timer.js\");\n\nconst IceSSL = Ice._ModuleRegistry.module(\"IceSSL\");\n\nlet WSTransceiver = {};\n\nif (typeof WebSocket !== 'undefined')\n{\n    //\n    // With Chrome we don't want to close the socket while connection is in progress,\n    // see comments on close implementation below.\n    //\n    // We need to check for Edge browser as it might include Chrome in its user agent.\n    //\n    const IsChrome = navigator.userAgent.indexOf(\"Edge/\") === -1 &&\n                    navigator.userAgent.indexOf(\"Chrome/\") !== -1;\n    const IsSafari = (/^((?!chrome).)*safari/i).test(navigator.userAgent);\n\n    const Debug = Ice.Debug;\n    const SocketOperation = Ice.SocketOperation;\n    const Timer = Ice.Timer;\n\n    const StateNeedConnect = 0;\n    const StateConnectPending = 1;\n    const StateConnected = 2;\n    const StateClosePending = 3;\n    const StateClosed = 4;\n\n    WSTransceiver = class\n    {\n        constructor(instance)\n        {\n            this._readBuffers = [];\n            this._readPosition = 0;\n            this._maxSendPacketSize = instance.properties().getPropertyAsIntWithDefault(\"Ice.TCP.SndSize\", 512 * 1024);\n            this._writeReadyTimeout = 0;\n        }\n\n        writeReadyTimeout()\n        {\n            const t = Math.round(this._writeReadyTimeout);\n            this._writeReadyTimeout += (this._writeReadyTimeout >= 5 ? 5 : 0.2);\n            return Math.min(t, 25);\n        }\n\n        setCallbacks(connectedCallback, bytesAvailableCallback, bytesWrittenCallback)\n        {\n            this._connectedCallback = connectedCallback;\n            this._bytesAvailableCallback = bytesAvailableCallback;\n            this._bytesWrittenCallback = bytesWrittenCallback;\n        }\n\n        //\n        // Returns SocketOperation.None when initialization is complete.\n        //\n        initialize(readBuffer, writeBuffer)\n        {\n            try\n            {\n                if(this._exception)\n                {\n                    throw this._exception;\n                }\n\n                if(this._state === StateNeedConnect)\n                {\n                    this._state = StateConnectPending;\n                    this._fd = new WebSocket(this._url, \"ice.zeroc.com\");\n                    this._fd.binaryType = \"arraybuffer\";\n                    this._fd.onopen = e => this.socketConnected(e);\n                    this._fd.onmessage = e => this.socketBytesAvailable(e.data);\n                    this._fd.onclose = e => this.socketClosed(e);\n                    return SocketOperation.Connect; // Waiting for connect to complete.\n                }\n                else if(this._state === StateConnectPending)\n                {\n                    //\n                    // Socket is connected.\n                    //\n                    this._desc = fdToString(this._addr);\n                    this._state = StateConnected;\n                }\n            }\n            catch(err)\n            {\n                if(!this._exception)\n                {\n                    this._exception = translateError(this._state, err);\n                }\n                throw this._exception;\n            }\n\n            Debug.assert(this._state === StateConnected);\n            return SocketOperation.None;\n        }\n\n        register()\n        {\n            //\n            // Register the socket data listener.\n            //\n            this._registered = true;\n            if(this._hasBytesAvailable || this._exception)\n            {\n                this._hasBytesAvailable = false;\n                Timer.setTimeout(() => this._bytesAvailableCallback(), 0);\n            }\n        }\n\n        unregister()\n        {\n            //\n            // Unregister the socket data listener.\n            //\n            this._registered = false;\n        }\n\n        close()\n        {\n            if(this._fd === null)\n            {\n                Debug.assert(this._exception); // Websocket creation failed.\n                return;\n            }\n\n            //\n            // With Chrome (in particular on macOS) calling close() while the websocket isn't\n            // connected yet doesn't abort the connection attempt, and might result in the\n            // connection being reused by a different web socket.\n            //\n            // To workaround this problem, we always wait for the socket to be connected or\n            // closed before closing the socket.\n            //\n            // NOTE: when this workaround is no longer necessary, don't forget removing the\n            // StateClosePending state.\n            //\n            if((IsChrome || IsSafari) && this._fd.readyState === WebSocket.CONNECTING)\n            {\n                this._state = StateClosePending;\n                return;\n            }\n\n            Debug.assert(this._fd !== null);\n            try\n            {\n                this._state = StateClosed;\n                this._fd.close();\n            }\n            catch(ex)\n            {\n                throw translateError(this._state, ex);\n            }\n            finally\n            {\n                this._fd = null;\n            }\n        }\n\n        //\n        // Returns true if all of the data was flushed to the kernel buffer.\n        //\n        write(byteBuffer)\n        {\n            if(this._exception)\n            {\n                throw this._exception;\n            }\n            else if(byteBuffer.remaining === 0)\n            {\n                return true;\n            }\n            Debug.assert(this._fd);\n\n            const cb = () =>\n                {\n                    if(this._fd)\n                    {\n                        const packetSize = this._maxSendPacketSize > 0 && byteBuffer.remaining > this._maxSendPacketSize ?\n                                this._maxSendPacketSize : byteBuffer.remaining;\n                        if(this._fd.bufferedAmount + packetSize <= this._maxSendPacketSize)\n                        {\n                            this._bytesWrittenCallback(0, 0);\n                        }\n                        else\n                        {\n                            Timer.setTimeout(cb, this.writeReadyTimeout());\n                        }\n                    }\n                };\n\n            while(true)\n            {\n                const packetSize = this._maxSendPacketSize > 0 && byteBuffer.remaining > this._maxSendPacketSize ?\n                    this._maxSendPacketSize : byteBuffer.remaining;\n                if(byteBuffer.remaining === 0)\n                {\n                    break;\n                }\n                Debug.assert(packetSize > 0);\n                if(this._fd.bufferedAmount + packetSize > this._maxSendPacketSize)\n                {\n                    Timer.setTimeout(cb, this.writeReadyTimeout());\n                    return false;\n                }\n                this._writeReadyTimeout = 0;\n                const slice = byteBuffer.b.slice(byteBuffer.position, byteBuffer.position + packetSize);\n                this._fd.send(slice);\n                byteBuffer.position += packetSize;\n\n                //\n                // TODO: WORKAROUND for Safari issue. The websocket accepts all the\n                // data (bufferedAmount is always 0). We relinquish the control here\n                // to ensure timeouts work properly.\n                //\n                if(IsSafari && byteBuffer.remaining > 0)\n                {\n                    Timer.setTimeout(cb, this.writeReadyTimeout());\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        read(byteBuffer, moreData)\n        {\n            if(this._exception)\n            {\n                throw this._exception;\n            }\n\n            moreData.value = false;\n\n            if(this._readBuffers.length === 0)\n            {\n                return false; // No data available.\n            }\n\n            let avail = this._readBuffers[0].byteLength - this._readPosition;\n            Debug.assert(avail > 0);\n\n            while(byteBuffer.remaining > 0)\n            {\n                if(avail > byteBuffer.remaining)\n                {\n                    avail = byteBuffer.remaining;\n                }\n\n                new Uint8Array(byteBuffer.b).set(new Uint8Array(this._readBuffers[0], this._readPosition, avail),\n                                                byteBuffer.position);\n\n                byteBuffer.position += avail;\n                this._readPosition += avail;\n                if(this._readPosition === this._readBuffers[0].byteLength)\n                {\n                    //\n                    // We've exhausted the current read buffer.\n                    //\n                    this._readPosition = 0;\n                    this._readBuffers.shift();\n                    if(this._readBuffers.length === 0)\n                    {\n                        break; // No more data - we're done.\n                    }\n                    else\n                    {\n                        avail = this._readBuffers[0].byteLength;\n                    }\n                }\n            }\n\n            moreData.value = this._readBuffers.length > 0;\n\n            return byteBuffer.remaining === 0;\n        }\n\n        type()\n        {\n            return this._secure ? \"wss\" : \"ws\";\n        }\n\n        getInfo()\n        {\n            Debug.assert(this._fd !== null);\n            const info = new Ice.WSConnectionInfo();\n            const tcpinfo = new Ice.TCPConnectionInfo();\n            tcpinfo.localAddress = \"\";\n            tcpinfo.localPort = -1;\n            tcpinfo.remoteAddress = this._addr.host;\n            tcpinfo.remotePort = this._addr.port;\n            info.underlying = this._secure ? new IceSSL.ConnectionInfo(tcpinfo, tcpinfo.timeout, tcpinfo.compress) : tcpinfo;\n            info.rcvSize = -1;\n            info.sndSize = this._maxSendPacketSize;\n            info.headers = {};\n            return info;\n        }\n\n        checkSendSize(stream)\n        {\n        }\n\n        setBufferSize(rcvSize, sndSize)\n        {\n            this._maxSendPacketSize = sndSize;\n        }\n\n        toString()\n        {\n            return this._desc;\n        }\n\n        socketConnected(e)\n        {\n            if(this._state == StateClosePending)\n            {\n                this.close();\n                return;\n            }\n\n            Debug.assert(this._connectedCallback !== null);\n            this._connectedCallback();\n        }\n\n        socketBytesAvailable(buf)\n        {\n            Debug.assert(this._bytesAvailableCallback !== null);\n            if(buf.byteLength > 0)\n            {\n                this._readBuffers.push(buf);\n                if(this._registered)\n                {\n                    this._bytesAvailableCallback();\n                }\n                else if(!this._hasBytesAvailable)\n                {\n                    this._hasBytesAvailable = true;\n                }\n            }\n        }\n\n        socketClosed(err)\n        {\n            if(this._state == StateClosePending)\n            {\n                this.close();\n                return;\n            }\n\n            this._exception = translateError(this._state, err);\n            if(this._state < StateConnected)\n            {\n                this._connectedCallback();\n            }\n            else if(this._registered)\n            {\n                this._bytesAvailableCallback();\n            }\n        }\n\n        static createOutgoing(instance, secure, addr, resource)\n        {\n            const transceiver = new WSTransceiver(instance);\n            let url = secure ? \"wss\" : \"ws\";\n            url += \"://\" + addr.host;\n            if(addr.port !== 80)\n            {\n                url += \":\" + addr.port;\n            }\n            url += resource ? resource : \"/\";\n            transceiver._url = url;\n            transceiver._fd = null;\n            transceiver._addr = addr;\n            transceiver._desc = \"local address = <not available>\\nremote address = \" + addr.host + \":\" + addr.port;\n            transceiver._state = StateNeedConnect;\n            transceiver._secure = secure;\n            transceiver._exception = null;\n            return transceiver;\n        }\n    }\n\n    function fdToString(address)\n    {\n        return \"local address = <not available>\\nremote address = \" + address.host + \":\" + address.port;\n    }\n\n    function translateError(state, err)\n    {\n        if(state < StateConnected)\n        {\n            return new Ice.ConnectFailedException(err.code, err);\n        }\n        else\n        {\n            if(err.code === 1000 || err.code === 1006) // CLOSE_NORMAL | CLOSE_ABNORMAL\n            {\n                return new Ice.ConnectionLostException();\n            }\n            return new Ice.SocketException(err.code, err);\n        }\n    }\n}\nelse\n{\n    WSTransceiver = class {}\n}\nIce.WSTransceiver = WSTransceiver;\n\nexports.Ice = Ice;\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/Ice/WSTransceiver.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/IceGrid/Admin.js":
/*!***********************************************!*\
  !*** ./node_modules/ice/src/IceGrid/Admin.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n//\n// Ice version 3.7.10\n//\n// <auto-generated>\n//\n// Generated from file `Admin.ice'\n//\n// Warning: do not edit this file.\n//\n// </auto-generated>\n//\n\n/* eslint-disable */\n/* jshint ignore: start */\n\n/* slice2js browser-bundle-skip */\nconst _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\nconst Glacier2 = (__webpack_require__(/*! ../Glacier2/Session */ \"./node_modules/ice/src/Glacier2/Session.js\").Glacier2);\n__webpack_require__(/*! ../Ice/Object */ \"./node_modules/ice/src/Ice/Object.js\");\n__webpack_require__(/*! ../Ice/Value */ \"./node_modules/ice/src/Ice/Value.js\");\n__webpack_require__(/*! ../Ice/ObjectPrx */ \"./node_modules/ice/src/Ice/ObjectPrx.js\");\n__webpack_require__(/*! ../Ice/Operation */ \"./node_modules/ice/src/Ice/Operation.js\");\n__webpack_require__(/*! ../Ice/Struct */ \"./node_modules/ice/src/Ice/Struct.js\");\n__webpack_require__(/*! ../Ice/EnumBase */ \"./node_modules/ice/src/Ice/EnumBase.js\");\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\n__webpack_require__(/*! ../Ice/Identity */ \"./node_modules/ice/src/Ice/Identity.js\");\n__webpack_require__(/*! ../Ice/BuiltinSequences */ \"./node_modules/ice/src/Ice/BuiltinSequences.js\");\n__webpack_require__(/*! ../Ice/Properties */ \"./node_modules/ice/src/Ice/Properties.js\");\n__webpack_require__(/*! ../Ice/SliceChecksumDict */ \"./node_modules/ice/src/Ice/SliceChecksumDict.js\");\nconst Ice = _ModuleRegistry.module(\"Ice\");\n\n__webpack_require__(/*! ../IceGrid/Exception */ \"./node_modules/ice/src/IceGrid/Exception.js\");\n__webpack_require__(/*! ../IceGrid/Descriptor */ \"./node_modules/ice/src/IceGrid/Descriptor.js\");\nconst IceGrid = _ModuleRegistry.module(\"IceGrid\");\n\nconst Slice = Ice.Slice;\n/* slice2js browser-bundle-skip-end */\n\n/**\n * An enumeration representing the state of the server.\n *\n **/\nIceGrid.ServerState = Slice.defineEnum([\n    ['Inactive', 0], ['Activating', 1], ['ActivationTimedOut', 2], ['Active', 3], ['Deactivating', 4],\n    ['Destroying', 5], ['Destroyed', 6]]);\n\nSlice.defineDictionary(IceGrid, \"StringObjectProxyDict\", \"StringObjectProxyDictHelper\", \"Ice.StringHelper\", \"Ice.ObjectPrx\", false, undefined, undefined);\n\n/**\n * Information about an Ice object.\n *\n **/\nIceGrid.ObjectInfo = class\n{\n    constructor(proxy = null, type = \"\")\n    {\n        this.proxy = proxy;\n        this.type = type;\n    }\n\n    _write(ostr)\n    {\n        ostr.writeProxy(this.proxy);\n        ostr.writeString(this.type);\n    }\n\n    _read(istr)\n    {\n        this.proxy = istr.readProxy();\n        this.type = istr.readString();\n    }\n\n    static get minWireSize()\n    {\n        return  3;\n    }\n};\n\nSlice.defineStruct(IceGrid.ObjectInfo, false, true);\n\nSlice.defineSequence(IceGrid, \"ObjectInfoSeqHelper\", \"IceGrid.ObjectInfo\", false);\n\n/**\n * Information about an adapter registered with the IceGrid registry.\n *\n **/\nIceGrid.AdapterInfo = class\n{\n    constructor(id = \"\", proxy = null, replicaGroupId = \"\")\n    {\n        this.id = id;\n        this.proxy = proxy;\n        this.replicaGroupId = replicaGroupId;\n    }\n\n    _write(ostr)\n    {\n        ostr.writeString(this.id);\n        ostr.writeProxy(this.proxy);\n        ostr.writeString(this.replicaGroupId);\n    }\n\n    _read(istr)\n    {\n        this.id = istr.readString();\n        this.proxy = istr.readProxy();\n        this.replicaGroupId = istr.readString();\n    }\n\n    static get minWireSize()\n    {\n        return  4;\n    }\n};\n\nSlice.defineStruct(IceGrid.AdapterInfo, false, true);\n\nSlice.defineSequence(IceGrid, \"AdapterInfoSeqHelper\", \"IceGrid.AdapterInfo\", false);\n\n/**\n * Information about a server managed by an IceGrid node.\n *\n **/\nIceGrid.ServerInfo = class\n{\n    constructor(application = \"\", uuid = \"\", revision = 0, node = \"\", descriptor = null, sessionId = \"\")\n    {\n        this.application = application;\n        this.uuid = uuid;\n        this.revision = revision;\n        this.node = node;\n        this.descriptor = descriptor;\n        this.sessionId = sessionId;\n    }\n\n    _write(ostr)\n    {\n        ostr.writeString(this.application);\n        ostr.writeString(this.uuid);\n        ostr.writeInt(this.revision);\n        ostr.writeString(this.node);\n        ostr.writeValue(this.descriptor);\n        ostr.writeString(this.sessionId);\n    }\n\n    _read(istr)\n    {\n        this.application = istr.readString();\n        this.uuid = istr.readString();\n        this.revision = istr.readInt();\n        this.node = istr.readString();\n        istr.readValue(obj => this.descriptor = obj, IceGrid.ServerDescriptor);\n        this.sessionId = istr.readString();\n    }\n\n    static get minWireSize()\n    {\n        return  9;\n    }\n};\n\nSlice.defineStruct(IceGrid.ServerInfo, false, true);\n\n/**\n * Information about an IceGrid node.\n *\n **/\nIceGrid.NodeInfo = class\n{\n    constructor(name = \"\", os = \"\", hostname = \"\", release = \"\", version = \"\", machine = \"\", nProcessors = 0, dataDir = \"\")\n    {\n        this.name = name;\n        this.os = os;\n        this.hostname = hostname;\n        this.release = release;\n        this.version = version;\n        this.machine = machine;\n        this.nProcessors = nProcessors;\n        this.dataDir = dataDir;\n    }\n\n    _write(ostr)\n    {\n        ostr.writeString(this.name);\n        ostr.writeString(this.os);\n        ostr.writeString(this.hostname);\n        ostr.writeString(this.release);\n        ostr.writeString(this.version);\n        ostr.writeString(this.machine);\n        ostr.writeInt(this.nProcessors);\n        ostr.writeString(this.dataDir);\n    }\n\n    _read(istr)\n    {\n        this.name = istr.readString();\n        this.os = istr.readString();\n        this.hostname = istr.readString();\n        this.release = istr.readString();\n        this.version = istr.readString();\n        this.machine = istr.readString();\n        this.nProcessors = istr.readInt();\n        this.dataDir = istr.readString();\n    }\n\n    static get minWireSize()\n    {\n        return  11;\n    }\n};\n\nSlice.defineStruct(IceGrid.NodeInfo, true, true);\n\n/**\n * Information about an IceGrid registry replica.\n *\n **/\nIceGrid.RegistryInfo = class\n{\n    constructor(name = \"\", hostname = \"\")\n    {\n        this.name = name;\n        this.hostname = hostname;\n    }\n\n    _write(ostr)\n    {\n        ostr.writeString(this.name);\n        ostr.writeString(this.hostname);\n    }\n\n    _read(istr)\n    {\n        this.name = istr.readString();\n        this.hostname = istr.readString();\n    }\n\n    static get minWireSize()\n    {\n        return  2;\n    }\n};\n\nSlice.defineStruct(IceGrid.RegistryInfo, true, true);\n\nSlice.defineSequence(IceGrid, \"RegistryInfoSeqHelper\", \"IceGrid.RegistryInfo\", false);\n\n/**\n * Information about the load of a node.\n *\n **/\nIceGrid.LoadInfo = class\n{\n    constructor(avg1 = 0.0, avg5 = 0.0, avg15 = 0.0)\n    {\n        this.avg1 = avg1;\n        this.avg5 = avg5;\n        this.avg15 = avg15;\n    }\n\n    _write(ostr)\n    {\n        ostr.writeFloat(this.avg1);\n        ostr.writeFloat(this.avg5);\n        ostr.writeFloat(this.avg15);\n    }\n\n    _read(istr)\n    {\n        this.avg1 = istr.readFloat();\n        this.avg5 = istr.readFloat();\n        this.avg15 = istr.readFloat();\n    }\n\n    static get minWireSize()\n    {\n        return  12;\n    }\n};\n\nSlice.defineStruct(IceGrid.LoadInfo, false, false);\n\n/**\n * Information about an IceGrid application.\n *\n **/\nIceGrid.ApplicationInfo = class\n{\n    constructor(uuid = \"\", createTime = new Ice.Long(0, 0), createUser = \"\", updateTime = new Ice.Long(0, 0), updateUser = \"\", revision = 0, descriptor = new IceGrid.ApplicationDescriptor())\n    {\n        this.uuid = uuid;\n        this.createTime = createTime;\n        this.createUser = createUser;\n        this.updateTime = updateTime;\n        this.updateUser = updateUser;\n        this.revision = revision;\n        this.descriptor = descriptor;\n    }\n\n    _write(ostr)\n    {\n        ostr.writeString(this.uuid);\n        ostr.writeLong(this.createTime);\n        ostr.writeString(this.createUser);\n        ostr.writeLong(this.updateTime);\n        ostr.writeString(this.updateUser);\n        ostr.writeInt(this.revision);\n        IceGrid.ApplicationDescriptor.write(ostr, this.descriptor);\n    }\n\n    _read(istr)\n    {\n        this.uuid = istr.readString();\n        this.createTime = istr.readLong();\n        this.createUser = istr.readString();\n        this.updateTime = istr.readLong();\n        this.updateUser = istr.readString();\n        this.revision = istr.readInt();\n        this.descriptor = IceGrid.ApplicationDescriptor.read(istr, this.descriptor);\n    }\n\n    static get minWireSize()\n    {\n        return  33;\n    }\n};\n\nSlice.defineStruct(IceGrid.ApplicationInfo, false, true);\n\nSlice.defineSequence(IceGrid, \"ApplicationInfoSeqHelper\", \"IceGrid.ApplicationInfo\", false);\n\n/**\n * Information about updates to an IceGrid application.\n *\n **/\nIceGrid.ApplicationUpdateInfo = class\n{\n    constructor(updateTime = new Ice.Long(0, 0), updateUser = \"\", revision = 0, descriptor = new IceGrid.ApplicationUpdateDescriptor())\n    {\n        this.updateTime = updateTime;\n        this.updateUser = updateUser;\n        this.revision = revision;\n        this.descriptor = descriptor;\n    }\n\n    _write(ostr)\n    {\n        ostr.writeLong(this.updateTime);\n        ostr.writeString(this.updateUser);\n        ostr.writeInt(this.revision);\n        IceGrid.ApplicationUpdateDescriptor.write(ostr, this.descriptor);\n    }\n\n    _read(istr)\n    {\n        this.updateTime = istr.readLong();\n        this.updateUser = istr.readString();\n        this.revision = istr.readInt();\n        this.descriptor = IceGrid.ApplicationUpdateDescriptor.read(istr, this.descriptor);\n    }\n\n    static get minWireSize()\n    {\n        return  28;\n    }\n};\n\nSlice.defineStruct(IceGrid.ApplicationUpdateInfo, false, true);\n\nconst iceC_IceGrid_Admin_ids = [\n    \"::Ice::Object\",\n    \"::IceGrid::Admin\"\n];\n\n/**\n * The IceGrid administrative interface.\n * <p class=\"Warning\">Allowing access to this interface\n * is a security risk! Please see the IceGrid documentation\n * for further information.\n *\n **/\nIceGrid.Admin = class extends Ice.Object\n{\n};\n\nIceGrid.AdminPrx = class extends Ice.ObjectPrx\n{\n};\n\nSlice.defineOperations(IceGrid.Admin, IceGrid.AdminPrx, iceC_IceGrid_Admin_ids, 1,\n{\n    \"addApplication\": [, , , , , [[IceGrid.ApplicationDescriptor]], ,\n    [\n        IceGrid.AccessDeniedException,\n        IceGrid.DeploymentException\n    ], true, ],\n    \"syncApplication\": [, , , , , [[IceGrid.ApplicationDescriptor]], ,\n    [\n        IceGrid.AccessDeniedException,\n        IceGrid.ApplicationNotExistException,\n        IceGrid.DeploymentException\n    ], true, ],\n    \"updateApplication\": [, , , , , [[IceGrid.ApplicationUpdateDescriptor]], ,\n    [\n        IceGrid.AccessDeniedException,\n        IceGrid.ApplicationNotExistException,\n        IceGrid.DeploymentException\n    ], true, ],\n    \"syncApplicationWithoutRestart\": [, , , , , [[IceGrid.ApplicationDescriptor]], ,\n    [\n        IceGrid.AccessDeniedException,\n        IceGrid.ApplicationNotExistException,\n        IceGrid.DeploymentException\n    ], true, ],\n    \"updateApplicationWithoutRestart\": [, , , , , [[IceGrid.ApplicationUpdateDescriptor]], ,\n    [\n        IceGrid.AccessDeniedException,\n        IceGrid.ApplicationNotExistException,\n        IceGrid.DeploymentException\n    ], true, ],\n    \"removeApplication\": [, , , , , [[7]], ,\n    [\n        IceGrid.AccessDeniedException,\n        IceGrid.ApplicationNotExistException,\n        IceGrid.DeploymentException\n    ], , ],\n    \"instantiateServer\": [, , , , , [[7], [7], [IceGrid.ServerInstanceDescriptor]], ,\n    [\n        IceGrid.AccessDeniedException,\n        IceGrid.ApplicationNotExistException,\n        IceGrid.DeploymentException\n    ], , ],\n    \"patchApplication\": [, , , , , [[7], [1]], ,\n    [\n        IceGrid.ApplicationNotExistException,\n        IceGrid.PatchException\n    ], , ],\n    \"getApplicationInfo\": [, 2, 1, , [IceGrid.ApplicationInfo], [[7]], ,\n    [\n        IceGrid.ApplicationNotExistException\n    ], , true],\n    \"getDefaultApplicationDescriptor\": [, 2, 1, , [IceGrid.ApplicationDescriptor], , ,\n    [\n        IceGrid.DeploymentException\n    ], , true],\n    \"getAllApplicationNames\": [, 2, 1, , [\"Ice.StringSeqHelper\"], , , , , ],\n    \"getServerInfo\": [, 2, 1, , [IceGrid.ServerInfo], [[7]], ,\n    [\n        IceGrid.ServerNotExistException\n    ], , true],\n    \"getServerState\": [, 2, 1, , [IceGrid.ServerState._helper], [[7]], ,\n    [\n        IceGrid.DeploymentException,\n        IceGrid.NodeUnreachableException,\n        IceGrid.ServerNotExistException\n    ], , ],\n    \"getServerPid\": [, 2, 1, , [3], [[7]], ,\n    [\n        IceGrid.DeploymentException,\n        IceGrid.NodeUnreachableException,\n        IceGrid.ServerNotExistException\n    ], , ],\n    \"getServerAdminCategory\": [, 2, 2, , [7], , , , , ],\n    \"getServerAdmin\": [, 2, 2, , [9], [[7]], ,\n    [\n        IceGrid.DeploymentException,\n        IceGrid.NodeUnreachableException,\n        IceGrid.ServerNotExistException\n    ], , ],\n    \"enableServer\": [, 2, 2, , , [[7], [1]], ,\n    [\n        IceGrid.DeploymentException,\n        IceGrid.NodeUnreachableException,\n        IceGrid.ServerNotExistException\n    ], , ],\n    \"isServerEnabled\": [, 2, 1, , [1], [[7]], ,\n    [\n        IceGrid.DeploymentException,\n        IceGrid.NodeUnreachableException,\n        IceGrid.ServerNotExistException\n    ], , ],\n    \"startServer\": [, , , , , [[7]], ,\n    [\n        IceGrid.DeploymentException,\n        IceGrid.NodeUnreachableException,\n        IceGrid.ServerNotExistException,\n        IceGrid.ServerStartException\n    ], , ],\n    \"stopServer\": [, , , , , [[7]], ,\n    [\n        IceGrid.DeploymentException,\n        IceGrid.NodeUnreachableException,\n        IceGrid.ServerNotExistException,\n        IceGrid.ServerStopException\n    ], , ],\n    \"patchServer\": [, , , , , [[7], [1]], ,\n    [\n        IceGrid.DeploymentException,\n        IceGrid.NodeUnreachableException,\n        IceGrid.PatchException,\n        IceGrid.ServerNotExistException\n    ], , ],\n    \"sendSignal\": [, , , , , [[7], [7]], ,\n    [\n        IceGrid.BadSignalException,\n        IceGrid.DeploymentException,\n        IceGrid.NodeUnreachableException,\n        IceGrid.ServerNotExistException\n    ], , ],\n    \"getAllServerIds\": [, 2, 1, , [\"Ice.StringSeqHelper\"], , , , , ],\n    \"getAdapterInfo\": [, 2, 1, , [\"IceGrid.AdapterInfoSeqHelper\"], [[7]], ,\n    [\n        IceGrid.AdapterNotExistException\n    ], , ],\n    \"removeAdapter\": [, , , , , [[7]], ,\n    [\n        IceGrid.AdapterNotExistException,\n        IceGrid.DeploymentException\n    ], , ],\n    \"getAllAdapterIds\": [, 2, 1, , [\"Ice.StringSeqHelper\"], , , , , ],\n    \"addObject\": [, , , , , [[9]], ,\n    [\n        IceGrid.DeploymentException,\n        IceGrid.ObjectExistsException\n    ], , ],\n    \"updateObject\": [, , , , , [[9]], ,\n    [\n        IceGrid.DeploymentException,\n        IceGrid.ObjectNotRegisteredException\n    ], , ],\n    \"addObjectWithType\": [, , , , , [[9], [7]], ,\n    [\n        IceGrid.DeploymentException,\n        IceGrid.ObjectExistsException\n    ], , ],\n    \"removeObject\": [, , , , , [[Ice.Identity]], ,\n    [\n        IceGrid.DeploymentException,\n        IceGrid.ObjectNotRegisteredException\n    ], , ],\n    \"getObjectInfo\": [, 2, 1, , [IceGrid.ObjectInfo], [[Ice.Identity]], ,\n    [\n        IceGrid.ObjectNotRegisteredException\n    ], , ],\n    \"getObjectInfosByType\": [, 2, 1, , [\"IceGrid.ObjectInfoSeqHelper\"], [[7]], , , , ],\n    \"getAllObjectInfos\": [, 2, 1, , [\"IceGrid.ObjectInfoSeqHelper\"], [[7]], , , , ],\n    \"pingNode\": [, 2, 1, , [1], [[7]], ,\n    [\n        IceGrid.NodeNotExistException\n    ], , ],\n    \"getNodeLoad\": [, 2, 1, , [IceGrid.LoadInfo], [[7]], ,\n    [\n        IceGrid.NodeNotExistException,\n        IceGrid.NodeUnreachableException\n    ], , ],\n    \"getNodeInfo\": [, 2, 1, , [IceGrid.NodeInfo], [[7]], ,\n    [\n        IceGrid.NodeNotExistException,\n        IceGrid.NodeUnreachableException\n    ], , ],\n    \"getNodeAdmin\": [, 2, 2, , [9], [[7]], ,\n    [\n        IceGrid.NodeNotExistException,\n        IceGrid.NodeUnreachableException\n    ], , ],\n    \"getNodeProcessorSocketCount\": [, 2, 1, , [3], [[7]], ,\n    [\n        IceGrid.NodeNotExistException,\n        IceGrid.NodeUnreachableException\n    ], , ],\n    \"shutdownNode\": [, , , , , [[7]], ,\n    [\n        IceGrid.NodeNotExistException,\n        IceGrid.NodeUnreachableException\n    ], , ],\n    \"getNodeHostname\": [, 2, 1, , [7], [[7]], ,\n    [\n        IceGrid.NodeNotExistException,\n        IceGrid.NodeUnreachableException\n    ], , ],\n    \"getAllNodeNames\": [, 2, 1, , [\"Ice.StringSeqHelper\"], , , , , ],\n    \"pingRegistry\": [, 2, 2, , [1], [[7]], ,\n    [\n        IceGrid.RegistryNotExistException\n    ], , ],\n    \"getRegistryInfo\": [, 2, 2, , [IceGrid.RegistryInfo], [[7]], ,\n    [\n        IceGrid.RegistryNotExistException,\n        IceGrid.RegistryUnreachableException\n    ], , ],\n    \"getRegistryAdmin\": [, 2, 2, , [9], [[7]], ,\n    [\n        IceGrid.RegistryNotExistException\n    ], , ],\n    \"shutdownRegistry\": [, 2, 2, , , [[7]], ,\n    [\n        IceGrid.RegistryNotExistException,\n        IceGrid.RegistryUnreachableException\n    ], , ],\n    \"getAllRegistryNames\": [, 2, 2, , [\"Ice.StringSeqHelper\"], , , , , ],\n    \"shutdown\": [, , , , , , , , , ],\n    \"getSliceChecksums\": [, 2, 1, , [\"Ice.SliceChecksumDictHelper\"], , , , , ]\n});\n\nconst iceC_IceGrid_FileIterator_ids = [\n    \"::Ice::Object\",\n    \"::IceGrid::FileIterator\"\n];\n\n/**\n * This interface provides access to IceGrid log file contents.\n *\n **/\nIceGrid.FileIterator = class extends Ice.Object\n{\n};\n\nIceGrid.FileIteratorPrx = class extends Ice.ObjectPrx\n{\n};\n\nSlice.defineOperations(IceGrid.FileIterator, IceGrid.FileIteratorPrx, iceC_IceGrid_FileIterator_ids, 1,\n{\n    \"read\": [, , , , [1], [[3]], [[\"Ice.StringSeqHelper\"]],\n    [\n        IceGrid.FileNotAvailableException\n    ], , ],\n    \"destroy\": [, , , , , , , , , ]\n});\n\n/**\n * Dynamic information about the state of a server.\n *\n **/\nIceGrid.ServerDynamicInfo = class\n{\n    constructor(id = \"\", state = IceGrid.ServerState.Inactive, pid = 0, enabled = false)\n    {\n        this.id = id;\n        this.state = state;\n        this.pid = pid;\n        this.enabled = enabled;\n    }\n\n    _write(ostr)\n    {\n        ostr.writeString(this.id);\n        IceGrid.ServerState._write(ostr, this.state);\n        ostr.writeInt(this.pid);\n        ostr.writeBool(this.enabled);\n    }\n\n    _read(istr)\n    {\n        this.id = istr.readString();\n        this.state = IceGrid.ServerState._read(istr);\n        this.pid = istr.readInt();\n        this.enabled = istr.readBool();\n    }\n\n    static get minWireSize()\n    {\n        return  7;\n    }\n};\n\nSlice.defineStruct(IceGrid.ServerDynamicInfo, true, true);\n\nSlice.defineSequence(IceGrid, \"ServerDynamicInfoSeqHelper\", \"IceGrid.ServerDynamicInfo\", false);\n\n/**\n * Dynamic information about the state of an adapter.\n *\n **/\nIceGrid.AdapterDynamicInfo = class\n{\n    constructor(id = \"\", proxy = null)\n    {\n        this.id = id;\n        this.proxy = proxy;\n    }\n\n    _write(ostr)\n    {\n        ostr.writeString(this.id);\n        ostr.writeProxy(this.proxy);\n    }\n\n    _read(istr)\n    {\n        this.id = istr.readString();\n        this.proxy = istr.readProxy();\n    }\n\n    static get minWireSize()\n    {\n        return  3;\n    }\n};\n\nSlice.defineStruct(IceGrid.AdapterDynamicInfo, false, true);\n\nSlice.defineSequence(IceGrid, \"AdapterDynamicInfoSeqHelper\", \"IceGrid.AdapterDynamicInfo\", false);\n\n/**\n * Dynamic information about the state of a node.\n *\n **/\nIceGrid.NodeDynamicInfo = class\n{\n    constructor(info = new IceGrid.NodeInfo(), servers = null, adapters = null)\n    {\n        this.info = info;\n        this.servers = servers;\n        this.adapters = adapters;\n    }\n\n    _write(ostr)\n    {\n        IceGrid.NodeInfo.write(ostr, this.info);\n        IceGrid.ServerDynamicInfoSeqHelper.write(ostr, this.servers);\n        IceGrid.AdapterDynamicInfoSeqHelper.write(ostr, this.adapters);\n    }\n\n    _read(istr)\n    {\n        this.info = IceGrid.NodeInfo.read(istr, this.info);\n        this.servers = IceGrid.ServerDynamicInfoSeqHelper.read(istr);\n        this.adapters = IceGrid.AdapterDynamicInfoSeqHelper.read(istr);\n    }\n\n    static get minWireSize()\n    {\n        return  13;\n    }\n};\n\nSlice.defineStruct(IceGrid.NodeDynamicInfo, false, true);\n\nconst iceC_IceGrid_RegistryObserver_ids = [\n    \"::Ice::Object\",\n    \"::IceGrid::RegistryObserver\"\n];\n\n/**\n * This interface allows applications to monitor changes the state\n * of the registry.\n *\n **/\nIceGrid.RegistryObserver = class extends Ice.Object\n{\n};\n\nIceGrid.RegistryObserverPrx = class extends Ice.ObjectPrx\n{\n};\n\nSlice.defineOperations(IceGrid.RegistryObserver, IceGrid.RegistryObserverPrx, iceC_IceGrid_RegistryObserver_ids, 1,\n{\n    \"registryInit\": [, , , , , [[\"IceGrid.RegistryInfoSeqHelper\"]], , , , ],\n    \"registryUp\": [, , , , , [[IceGrid.RegistryInfo]], , , , ],\n    \"registryDown\": [, , , , , [[7]], , , , ]\n});\n\nSlice.defineSequence(IceGrid, \"NodeDynamicInfoSeqHelper\", \"IceGrid.NodeDynamicInfo\", false);\n\nconst iceC_IceGrid_NodeObserver_ids = [\n    \"::Ice::Object\",\n    \"::IceGrid::NodeObserver\"\n];\n\n/**\n * The node observer interface. Observers should implement this\n * interface to receive information about the state of the IceGrid\n * nodes.\n *\n **/\nIceGrid.NodeObserver = class extends Ice.Object\n{\n};\n\nIceGrid.NodeObserverPrx = class extends Ice.ObjectPrx\n{\n};\n\nSlice.defineOperations(IceGrid.NodeObserver, IceGrid.NodeObserverPrx, iceC_IceGrid_NodeObserver_ids, 1,\n{\n    \"nodeInit\": [, , , , , [[\"IceGrid.NodeDynamicInfoSeqHelper\"]], , , , ],\n    \"nodeUp\": [, , , , , [[IceGrid.NodeDynamicInfo]], , , , ],\n    \"nodeDown\": [, , , , , [[7]], , , , ],\n    \"updateServer\": [, , , , , [[7], [IceGrid.ServerDynamicInfo]], , , , ],\n    \"updateAdapter\": [, , , , , [[7], [IceGrid.AdapterDynamicInfo]], , , , ]\n});\n\nconst iceC_IceGrid_ApplicationObserver_ids = [\n    \"::Ice::Object\",\n    \"::IceGrid::ApplicationObserver\"\n];\n\n/**\n * The database observer interface. Observers should implement this\n * interface to receive information about the state of the IceGrid\n * registry database.\n *\n **/\nIceGrid.ApplicationObserver = class extends Ice.Object\n{\n};\n\nIceGrid.ApplicationObserverPrx = class extends Ice.ObjectPrx\n{\n};\n\nSlice.defineOperations(IceGrid.ApplicationObserver, IceGrid.ApplicationObserverPrx, iceC_IceGrid_ApplicationObserver_ids, 1,\n{\n    \"applicationInit\": [, , , , , [[3], [\"IceGrid.ApplicationInfoSeqHelper\"]], , , true, ],\n    \"applicationAdded\": [, , , , , [[3], [IceGrid.ApplicationInfo]], , , true, ],\n    \"applicationRemoved\": [, , , , , [[3], [7]], , , , ],\n    \"applicationUpdated\": [, , , , , [[3], [IceGrid.ApplicationUpdateInfo]], , , true, ]\n});\n\nconst iceC_IceGrid_AdapterObserver_ids = [\n    \"::Ice::Object\",\n    \"::IceGrid::AdapterObserver\"\n];\n\n/**\n * This interface allows applications to monitor the state of object\n * adapters that are registered with IceGrid.\n *\n **/\nIceGrid.AdapterObserver = class extends Ice.Object\n{\n};\n\nIceGrid.AdapterObserverPrx = class extends Ice.ObjectPrx\n{\n};\n\nSlice.defineOperations(IceGrid.AdapterObserver, IceGrid.AdapterObserverPrx, iceC_IceGrid_AdapterObserver_ids, 1,\n{\n    \"adapterInit\": [, , , , , [[\"IceGrid.AdapterInfoSeqHelper\"]], , , , ],\n    \"adapterAdded\": [, , , , , [[IceGrid.AdapterInfo]], , , , ],\n    \"adapterUpdated\": [, , , , , [[IceGrid.AdapterInfo]], , , , ],\n    \"adapterRemoved\": [, , , , , [[7]], , , , ]\n});\n\nconst iceC_IceGrid_ObjectObserver_ids = [\n    \"::Ice::Object\",\n    \"::IceGrid::ObjectObserver\"\n];\n\n/**\n * This interface allows applications to monitor IceGrid well-known objects.\n *\n **/\nIceGrid.ObjectObserver = class extends Ice.Object\n{\n};\n\nIceGrid.ObjectObserverPrx = class extends Ice.ObjectPrx\n{\n};\n\nSlice.defineOperations(IceGrid.ObjectObserver, IceGrid.ObjectObserverPrx, iceC_IceGrid_ObjectObserver_ids, 1,\n{\n    \"objectInit\": [, , , , , [[\"IceGrid.ObjectInfoSeqHelper\"]], , , , ],\n    \"objectAdded\": [, , , , , [[IceGrid.ObjectInfo]], , , , ],\n    \"objectUpdated\": [, , , , , [[IceGrid.ObjectInfo]], , , , ],\n    \"objectRemoved\": [, , , , , [[Ice.Identity]], , , , ]\n});\n\nconst iceC_IceGrid_AdminSession_ids = [\n    \"::Glacier2::Session\",\n    \"::Ice::Object\",\n    \"::IceGrid::AdminSession\"\n];\n\n/**\n * Used by administrative clients to view,\n * update, and receive observer updates from the IceGrid\n * registry. Admin sessions are created either via the {@link Registry}\n * object or via the registry admin <code>SessionManager</code> object.\n *\n * @see Registry\n *\n **/\nIceGrid.AdminSession = class extends Ice.Object\n{\n    static get _iceImplements()\n    {\n        return [\n            Glacier2.Session\n        ];\n    }\n};\n\nIceGrid.AdminSessionPrx = class extends Ice.ObjectPrx\n{\n    static get _implements()\n    {\n        return [\n            Glacier2.SessionPrx];\n    }\n};\n\nSlice.defineOperations(IceGrid.AdminSession, IceGrid.AdminSessionPrx, iceC_IceGrid_AdminSession_ids, 2,\n{\n    \"keepAlive\": [, 2, 2, , , , , , , ],\n    \"getAdmin\": [, 2, 1, , [\"IceGrid.AdminPrx\"], , , , , ],\n    \"getAdminCallbackTemplate\": [, 2, 2, , [9], , , , , ],\n    \"setObservers\": [, 2, 2, , , [[\"IceGrid.RegistryObserverPrx\"], [\"IceGrid.NodeObserverPrx\"], [\"IceGrid.ApplicationObserverPrx\"], [\"IceGrid.AdapterObserverPrx\"], [\"IceGrid.ObjectObserverPrx\"]], ,\n    [\n        IceGrid.ObserverAlreadyRegisteredException\n    ], , ],\n    \"setObserversByIdentity\": [, 2, 2, , , [[Ice.Identity], [Ice.Identity], [Ice.Identity], [Ice.Identity], [Ice.Identity]], ,\n    [\n        IceGrid.ObserverAlreadyRegisteredException\n    ], , ],\n    \"startUpdate\": [, , , , [3], , ,\n    [\n        IceGrid.AccessDeniedException\n    ], , ],\n    \"finishUpdate\": [, , , , , , ,\n    [\n        IceGrid.AccessDeniedException\n    ], , ],\n    \"getReplicaName\": [, 2, 2, , [7], , , , , ],\n    \"openServerLog\": [, , , , [\"IceGrid.FileIteratorPrx\"], [[7], [7], [3]], ,\n    [\n        IceGrid.DeploymentException,\n        IceGrid.FileNotAvailableException,\n        IceGrid.NodeUnreachableException,\n        IceGrid.ServerNotExistException\n    ], , ],\n    \"openServerStdErr\": [, , , , [\"IceGrid.FileIteratorPrx\"], [[7], [3]], ,\n    [\n        IceGrid.DeploymentException,\n        IceGrid.FileNotAvailableException,\n        IceGrid.NodeUnreachableException,\n        IceGrid.ServerNotExistException\n    ], , ],\n    \"openServerStdOut\": [, , , , [\"IceGrid.FileIteratorPrx\"], [[7], [3]], ,\n    [\n        IceGrid.DeploymentException,\n        IceGrid.FileNotAvailableException,\n        IceGrid.NodeUnreachableException,\n        IceGrid.ServerNotExistException\n    ], , ],\n    \"openNodeStdErr\": [, , , , [\"IceGrid.FileIteratorPrx\"], [[7], [3]], ,\n    [\n        IceGrid.FileNotAvailableException,\n        IceGrid.NodeNotExistException,\n        IceGrid.NodeUnreachableException\n    ], , ],\n    \"openNodeStdOut\": [, , , , [\"IceGrid.FileIteratorPrx\"], [[7], [3]], ,\n    [\n        IceGrid.FileNotAvailableException,\n        IceGrid.NodeNotExistException,\n        IceGrid.NodeUnreachableException\n    ], , ],\n    \"openRegistryStdErr\": [, , , , [\"IceGrid.FileIteratorPrx\"], [[7], [3]], ,\n    [\n        IceGrid.FileNotAvailableException,\n        IceGrid.RegistryNotExistException,\n        IceGrid.RegistryUnreachableException\n    ], , ],\n    \"openRegistryStdOut\": [, , , , [\"IceGrid.FileIteratorPrx\"], [[7], [3]], ,\n    [\n        IceGrid.FileNotAvailableException,\n        IceGrid.RegistryNotExistException,\n        IceGrid.RegistryUnreachableException\n    ], , ]\n});\n/* slice2js browser-bundle-skip */\nexports.IceGrid = IceGrid;\n/* slice2js browser-bundle-skip-end */\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/IceGrid/Admin.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/IceGrid/Descriptor.js":
/*!****************************************************!*\
  !*** ./node_modules/ice/src/IceGrid/Descriptor.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n//\n// Ice version 3.7.10\n//\n// <auto-generated>\n//\n// Generated from file `Descriptor.ice'\n//\n// Warning: do not edit this file.\n//\n// </auto-generated>\n//\n\n/* eslint-disable */\n/* jshint ignore: start */\n\n/* slice2js browser-bundle-skip */\nconst _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\n__webpack_require__(/*! ../Ice/Object */ \"./node_modules/ice/src/Ice/Object.js\");\n__webpack_require__(/*! ../Ice/Value */ \"./node_modules/ice/src/Ice/Value.js\");\n__webpack_require__(/*! ../Ice/ObjectPrx */ \"./node_modules/ice/src/Ice/ObjectPrx.js\");\n__webpack_require__(/*! ../Ice/Struct */ \"./node_modules/ice/src/Ice/Struct.js\");\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\n__webpack_require__(/*! ../Ice/Identity */ \"./node_modules/ice/src/Ice/Identity.js\");\n__webpack_require__(/*! ../Ice/BuiltinSequences */ \"./node_modules/ice/src/Ice/BuiltinSequences.js\");\nconst Ice = _ModuleRegistry.module(\"Ice\");\n\nconst Slice = Ice.Slice;\n/* slice2js browser-bundle-skip-end */\n/* slice2js browser-bundle-skip */\n\nlet IceGrid = _ModuleRegistry.module(\"IceGrid\");\n/* slice2js browser-bundle-skip-end */\n\nSlice.defineDictionary(IceGrid, \"StringStringDict\", \"StringStringDictHelper\", \"Ice.StringHelper\", \"Ice.StringHelper\", false, undefined, undefined);\n\n/**\n * Property descriptor.\n *\n **/\nIceGrid.PropertyDescriptor = class\n{\n    constructor(name = \"\", value = \"\")\n    {\n        this.name = name;\n        this.value = value;\n    }\n\n    _write(ostr)\n    {\n        ostr.writeString(this.name);\n        ostr.writeString(this.value);\n    }\n\n    _read(istr)\n    {\n        this.name = istr.readString();\n        this.value = istr.readString();\n    }\n\n    static get minWireSize()\n    {\n        return  2;\n    }\n};\n\nSlice.defineStruct(IceGrid.PropertyDescriptor, true, true);\n\nSlice.defineSequence(IceGrid, \"PropertyDescriptorSeqHelper\", \"IceGrid.PropertyDescriptor\", false);\n\n/**\n * A property set descriptor.\n *\n **/\nIceGrid.PropertySetDescriptor = class\n{\n    constructor(references = null, properties = null)\n    {\n        this.references = references;\n        this.properties = properties;\n    }\n\n    _write(ostr)\n    {\n        Ice.StringSeqHelper.write(ostr, this.references);\n        IceGrid.PropertyDescriptorSeqHelper.write(ostr, this.properties);\n    }\n\n    _read(istr)\n    {\n        this.references = Ice.StringSeqHelper.read(istr);\n        this.properties = IceGrid.PropertyDescriptorSeqHelper.read(istr);\n    }\n\n    static get minWireSize()\n    {\n        return  2;\n    }\n};\n\nSlice.defineStruct(IceGrid.PropertySetDescriptor, true, true);\n\nSlice.defineDictionary(IceGrid, \"PropertySetDescriptorDict\", \"PropertySetDescriptorDictHelper\", \"Ice.StringHelper\", \"IceGrid.PropertySetDescriptor\", false, undefined, undefined);\n\n/**\n * An Ice object descriptor.\n *\n **/\nIceGrid.ObjectDescriptor = class\n{\n    constructor(id = new Ice.Identity(), type = \"\", proxyOptions = \"\")\n    {\n        this.id = id;\n        this.type = type;\n        this.proxyOptions = proxyOptions;\n    }\n\n    _write(ostr)\n    {\n        Ice.Identity.write(ostr, this.id);\n        ostr.writeString(this.type);\n        ostr.writeString(this.proxyOptions);\n    }\n\n    _read(istr)\n    {\n        this.id = Ice.Identity.read(istr, this.id);\n        this.type = istr.readString();\n        this.proxyOptions = istr.readString();\n    }\n\n    static get minWireSize()\n    {\n        return  4;\n    }\n};\n\nSlice.defineStruct(IceGrid.ObjectDescriptor, true, true);\n\nSlice.defineSequence(IceGrid, \"ObjectDescriptorSeqHelper\", \"IceGrid.ObjectDescriptor\", false);\n\n/**\n * An Ice object adapter descriptor.\n *\n **/\nIceGrid.AdapterDescriptor = class\n{\n    constructor(name = \"\", description = \"\", id = \"\", replicaGroupId = \"\", priority = \"\", registerProcess = false, serverLifetime = false, objects = null, allocatables = null)\n    {\n        this.name = name;\n        this.description = description;\n        this.id = id;\n        this.replicaGroupId = replicaGroupId;\n        this.priority = priority;\n        this.registerProcess = registerProcess;\n        this.serverLifetime = serverLifetime;\n        this.objects = objects;\n        this.allocatables = allocatables;\n    }\n\n    _write(ostr)\n    {\n        ostr.writeString(this.name);\n        ostr.writeString(this.description);\n        ostr.writeString(this.id);\n        ostr.writeString(this.replicaGroupId);\n        ostr.writeString(this.priority);\n        ostr.writeBool(this.registerProcess);\n        ostr.writeBool(this.serverLifetime);\n        IceGrid.ObjectDescriptorSeqHelper.write(ostr, this.objects);\n        IceGrid.ObjectDescriptorSeqHelper.write(ostr, this.allocatables);\n    }\n\n    _read(istr)\n    {\n        this.name = istr.readString();\n        this.description = istr.readString();\n        this.id = istr.readString();\n        this.replicaGroupId = istr.readString();\n        this.priority = istr.readString();\n        this.registerProcess = istr.readBool();\n        this.serverLifetime = istr.readBool();\n        this.objects = IceGrid.ObjectDescriptorSeqHelper.read(istr);\n        this.allocatables = IceGrid.ObjectDescriptorSeqHelper.read(istr);\n    }\n\n    static get minWireSize()\n    {\n        return  9;\n    }\n};\n\nSlice.defineStruct(IceGrid.AdapterDescriptor, true, true);\n\nSlice.defineSequence(IceGrid, \"AdapterDescriptorSeqHelper\", \"IceGrid.AdapterDescriptor\", false);\n\n/**\n * A Freeze database environment descriptor.\n *\n **/\nIceGrid.DbEnvDescriptor = class\n{\n    constructor(name = \"\", description = \"\", dbHome = \"\", properties = null)\n    {\n        this.name = name;\n        this.description = description;\n        this.dbHome = dbHome;\n        this.properties = properties;\n    }\n\n    _write(ostr)\n    {\n        ostr.writeString(this.name);\n        ostr.writeString(this.description);\n        ostr.writeString(this.dbHome);\n        IceGrid.PropertyDescriptorSeqHelper.write(ostr, this.properties);\n    }\n\n    _read(istr)\n    {\n        this.name = istr.readString();\n        this.description = istr.readString();\n        this.dbHome = istr.readString();\n        this.properties = IceGrid.PropertyDescriptorSeqHelper.read(istr);\n    }\n\n    static get minWireSize()\n    {\n        return  4;\n    }\n};\n\nSlice.defineStruct(IceGrid.DbEnvDescriptor, true, true);\n\nSlice.defineSequence(IceGrid, \"DbEnvDescriptorSeqHelper\", \"IceGrid.DbEnvDescriptor\", false);\n\nconst iceC_IceGrid_CommunicatorDescriptor_ids = [\n    \"::Ice::Object\",\n    \"::IceGrid::CommunicatorDescriptor\"\n];\n\n/**\n * A communicator descriptor.\n *\n **/\nIceGrid.CommunicatorDescriptor = class extends Ice.Value\n{\n    constructor(adapters = null, propertySet = new IceGrid.PropertySetDescriptor(), dbEnvs = null, logs = null, description = \"\")\n    {\n        super();\n        this.adapters = adapters;\n        this.propertySet = propertySet;\n        this.dbEnvs = dbEnvs;\n        this.logs = logs;\n        this.description = description;\n    }\n\n    _iceWriteMemberImpl(ostr)\n    {\n        IceGrid.AdapterDescriptorSeqHelper.write(ostr, this.adapters);\n        IceGrid.PropertySetDescriptor.write(ostr, this.propertySet);\n        IceGrid.DbEnvDescriptorSeqHelper.write(ostr, this.dbEnvs);\n        Ice.StringSeqHelper.write(ostr, this.logs);\n        ostr.writeString(this.description);\n    }\n\n    _iceReadMemberImpl(istr)\n    {\n        this.adapters = IceGrid.AdapterDescriptorSeqHelper.read(istr);\n        this.propertySet = IceGrid.PropertySetDescriptor.read(istr, this.propertySet);\n        this.dbEnvs = IceGrid.DbEnvDescriptorSeqHelper.read(istr);\n        this.logs = Ice.StringSeqHelper.read(istr);\n        this.description = istr.readString();\n    }\n};\n\nSlice.defineValue(IceGrid.CommunicatorDescriptor, iceC_IceGrid_CommunicatorDescriptor_ids[1], false);\n\n/**\n * A distribution descriptor defines an IcePatch2 server and the\n * directories to retrieve from the patch server.\n *\n **/\nIceGrid.DistributionDescriptor = class\n{\n    constructor(icepatch = \"\", directories = null)\n    {\n        this.icepatch = icepatch;\n        this.directories = directories;\n    }\n\n    _write(ostr)\n    {\n        ostr.writeString(this.icepatch);\n        Ice.StringSeqHelper.write(ostr, this.directories);\n    }\n\n    _read(istr)\n    {\n        this.icepatch = istr.readString();\n        this.directories = Ice.StringSeqHelper.read(istr);\n    }\n\n    static get minWireSize()\n    {\n        return  2;\n    }\n};\n\nSlice.defineStruct(IceGrid.DistributionDescriptor, true, true);\n\nconst iceC_IceGrid_ServerDescriptor_ids = [\n    \"::Ice::Object\",\n    \"::IceGrid::CommunicatorDescriptor\",\n    \"::IceGrid::ServerDescriptor\"\n];\n\n/**\n * An Ice server descriptor.\n *\n **/\nIceGrid.ServerDescriptor = class extends IceGrid.CommunicatorDescriptor\n{\n    constructor(adapters, propertySet, dbEnvs, logs, description, id = \"\", exe = \"\", iceVersion = \"\", pwd = \"\", options = null, envs = null, activation = \"\", activationTimeout = \"\", deactivationTimeout = \"\", applicationDistrib = false, distrib = new IceGrid.DistributionDescriptor(), allocatable = false, user = \"\")\n    {\n        super(adapters, propertySet, dbEnvs, logs, description);\n        this.id = id;\n        this.exe = exe;\n        this.iceVersion = iceVersion;\n        this.pwd = pwd;\n        this.options = options;\n        this.envs = envs;\n        this.activation = activation;\n        this.activationTimeout = activationTimeout;\n        this.deactivationTimeout = deactivationTimeout;\n        this.applicationDistrib = applicationDistrib;\n        this.distrib = distrib;\n        this.allocatable = allocatable;\n        this.user = user;\n    }\n\n    _iceWriteMemberImpl(ostr)\n    {\n        ostr.writeString(this.id);\n        ostr.writeString(this.exe);\n        ostr.writeString(this.iceVersion);\n        ostr.writeString(this.pwd);\n        Ice.StringSeqHelper.write(ostr, this.options);\n        Ice.StringSeqHelper.write(ostr, this.envs);\n        ostr.writeString(this.activation);\n        ostr.writeString(this.activationTimeout);\n        ostr.writeString(this.deactivationTimeout);\n        ostr.writeBool(this.applicationDistrib);\n        IceGrid.DistributionDescriptor.write(ostr, this.distrib);\n        ostr.writeBool(this.allocatable);\n        ostr.writeString(this.user);\n    }\n\n    _iceReadMemberImpl(istr)\n    {\n        this.id = istr.readString();\n        this.exe = istr.readString();\n        this.iceVersion = istr.readString();\n        this.pwd = istr.readString();\n        this.options = Ice.StringSeqHelper.read(istr);\n        this.envs = Ice.StringSeqHelper.read(istr);\n        this.activation = istr.readString();\n        this.activationTimeout = istr.readString();\n        this.deactivationTimeout = istr.readString();\n        this.applicationDistrib = istr.readBool();\n        this.distrib = IceGrid.DistributionDescriptor.read(istr, this.distrib);\n        this.allocatable = istr.readBool();\n        this.user = istr.readString();\n    }\n};\n\nSlice.defineValue(IceGrid.ServerDescriptor, iceC_IceGrid_ServerDescriptor_ids[2], false);\n\nSlice.defineSequence(IceGrid, \"ServerDescriptorSeqHelper\", \"Ice.ObjectHelper\", false, \"IceGrid.ServerDescriptor\");\n\nconst iceC_IceGrid_ServiceDescriptor_ids = [\n    \"::Ice::Object\",\n    \"::IceGrid::CommunicatorDescriptor\",\n    \"::IceGrid::ServiceDescriptor\"\n];\n\n/**\n * An IceBox service descriptor.\n *\n **/\nIceGrid.ServiceDescriptor = class extends IceGrid.CommunicatorDescriptor\n{\n    constructor(adapters, propertySet, dbEnvs, logs, description, name = \"\", entry = \"\")\n    {\n        super(adapters, propertySet, dbEnvs, logs, description);\n        this.name = name;\n        this.entry = entry;\n    }\n\n    _iceWriteMemberImpl(ostr)\n    {\n        ostr.writeString(this.name);\n        ostr.writeString(this.entry);\n    }\n\n    _iceReadMemberImpl(istr)\n    {\n        this.name = istr.readString();\n        this.entry = istr.readString();\n    }\n};\n\nSlice.defineValue(IceGrid.ServiceDescriptor, iceC_IceGrid_ServiceDescriptor_ids[2], false);\n\nSlice.defineSequence(IceGrid, \"ServiceDescriptorSeqHelper\", \"Ice.ObjectHelper\", false, \"IceGrid.ServiceDescriptor\");\n\n/**\n * A server template instance descriptor.\n *\n **/\nIceGrid.ServerInstanceDescriptor = class\n{\n    constructor(template = \"\", parameterValues = null, propertySet = new IceGrid.PropertySetDescriptor(), servicePropertySets = null)\n    {\n        this.template = template;\n        this.parameterValues = parameterValues;\n        this.propertySet = propertySet;\n        this.servicePropertySets = servicePropertySets;\n    }\n\n    _write(ostr)\n    {\n        ostr.writeString(this.template);\n        IceGrid.StringStringDictHelper.write(ostr, this.parameterValues);\n        IceGrid.PropertySetDescriptor.write(ostr, this.propertySet);\n        IceGrid.PropertySetDescriptorDictHelper.write(ostr, this.servicePropertySets);\n    }\n\n    _read(istr)\n    {\n        this.template = istr.readString();\n        this.parameterValues = IceGrid.StringStringDictHelper.read(istr);\n        this.propertySet = IceGrid.PropertySetDescriptor.read(istr, this.propertySet);\n        this.servicePropertySets = IceGrid.PropertySetDescriptorDictHelper.read(istr);\n    }\n\n    static get minWireSize()\n    {\n        return  5;\n    }\n};\n\nSlice.defineStruct(IceGrid.ServerInstanceDescriptor, false, true);\n\nSlice.defineSequence(IceGrid, \"ServerInstanceDescriptorSeqHelper\", \"IceGrid.ServerInstanceDescriptor\", false);\n\n/**\n * A template descriptor for server or service templates.\n *\n **/\nIceGrid.TemplateDescriptor = class\n{\n    constructor(descriptor = null, parameters = null, parameterDefaults = null)\n    {\n        this.descriptor = descriptor;\n        this.parameters = parameters;\n        this.parameterDefaults = parameterDefaults;\n    }\n\n    _write(ostr)\n    {\n        ostr.writeValue(this.descriptor);\n        Ice.StringSeqHelper.write(ostr, this.parameters);\n        IceGrid.StringStringDictHelper.write(ostr, this.parameterDefaults);\n    }\n\n    _read(istr)\n    {\n        istr.readValue(obj => this.descriptor = obj, IceGrid.CommunicatorDescriptor);\n        this.parameters = Ice.StringSeqHelper.read(istr);\n        this.parameterDefaults = IceGrid.StringStringDictHelper.read(istr);\n    }\n\n    static get minWireSize()\n    {\n        return  3;\n    }\n};\n\nSlice.defineStruct(IceGrid.TemplateDescriptor, false, true);\n\nSlice.defineDictionary(IceGrid, \"TemplateDescriptorDict\", \"TemplateDescriptorDictHelper\", \"Ice.StringHelper\", \"IceGrid.TemplateDescriptor\", false, undefined, undefined);\n\n/**\n * A service template instance descriptor.\n *\n **/\nIceGrid.ServiceInstanceDescriptor = class\n{\n    constructor(template = \"\", parameterValues = null, descriptor = null, propertySet = new IceGrid.PropertySetDescriptor())\n    {\n        this.template = template;\n        this.parameterValues = parameterValues;\n        this.descriptor = descriptor;\n        this.propertySet = propertySet;\n    }\n\n    _write(ostr)\n    {\n        ostr.writeString(this.template);\n        IceGrid.StringStringDictHelper.write(ostr, this.parameterValues);\n        ostr.writeValue(this.descriptor);\n        IceGrid.PropertySetDescriptor.write(ostr, this.propertySet);\n    }\n\n    _read(istr)\n    {\n        this.template = istr.readString();\n        this.parameterValues = IceGrid.StringStringDictHelper.read(istr);\n        istr.readValue(obj => this.descriptor = obj, IceGrid.ServiceDescriptor);\n        this.propertySet = IceGrid.PropertySetDescriptor.read(istr, this.propertySet);\n    }\n\n    static get minWireSize()\n    {\n        return  5;\n    }\n};\n\nSlice.defineStruct(IceGrid.ServiceInstanceDescriptor, false, true);\n\nSlice.defineSequence(IceGrid, \"ServiceInstanceDescriptorSeqHelper\", \"IceGrid.ServiceInstanceDescriptor\", false);\n\nconst iceC_IceGrid_IceBoxDescriptor_ids = [\n    \"::Ice::Object\",\n    \"::IceGrid::CommunicatorDescriptor\",\n    \"::IceGrid::IceBoxDescriptor\",\n    \"::IceGrid::ServerDescriptor\"\n];\n\n/**\n * An IceBox server descriptor.\n *\n **/\nIceGrid.IceBoxDescriptor = class extends IceGrid.ServerDescriptor\n{\n    constructor(adapters, propertySet, dbEnvs, logs, description, id, exe, iceVersion, pwd, options, envs, activation, activationTimeout, deactivationTimeout, applicationDistrib, distrib, allocatable, user, services = null)\n    {\n        super(adapters, propertySet, dbEnvs, logs, description, id, exe, iceVersion, pwd, options, envs, activation, activationTimeout, deactivationTimeout, applicationDistrib, distrib, allocatable, user);\n        this.services = services;\n    }\n\n    _iceWriteMemberImpl(ostr)\n    {\n        IceGrid.ServiceInstanceDescriptorSeqHelper.write(ostr, this.services);\n    }\n\n    _iceReadMemberImpl(istr)\n    {\n        this.services = IceGrid.ServiceInstanceDescriptorSeqHelper.read(istr);\n    }\n};\n\nSlice.defineValue(IceGrid.IceBoxDescriptor, iceC_IceGrid_IceBoxDescriptor_ids[2], false);\n\n/**\n * A node descriptor.\n *\n **/\nIceGrid.NodeDescriptor = class\n{\n    constructor(variables = null, serverInstances = null, servers = null, loadFactor = \"\", description = \"\", propertySets = null)\n    {\n        this.variables = variables;\n        this.serverInstances = serverInstances;\n        this.servers = servers;\n        this.loadFactor = loadFactor;\n        this.description = description;\n        this.propertySets = propertySets;\n    }\n\n    _write(ostr)\n    {\n        IceGrid.StringStringDictHelper.write(ostr, this.variables);\n        IceGrid.ServerInstanceDescriptorSeqHelper.write(ostr, this.serverInstances);\n        IceGrid.ServerDescriptorSeqHelper.write(ostr, this.servers);\n        ostr.writeString(this.loadFactor);\n        ostr.writeString(this.description);\n        IceGrid.PropertySetDescriptorDictHelper.write(ostr, this.propertySets);\n    }\n\n    _read(istr)\n    {\n        this.variables = IceGrid.StringStringDictHelper.read(istr);\n        this.serverInstances = IceGrid.ServerInstanceDescriptorSeqHelper.read(istr);\n        this.servers = IceGrid.ServerDescriptorSeqHelper.read(istr);\n        this.loadFactor = istr.readString();\n        this.description = istr.readString();\n        this.propertySets = IceGrid.PropertySetDescriptorDictHelper.read(istr);\n    }\n\n    static get minWireSize()\n    {\n        return  6;\n    }\n};\n\nSlice.defineStruct(IceGrid.NodeDescriptor, false, true);\n\nSlice.defineDictionary(IceGrid, \"NodeDescriptorDict\", \"NodeDescriptorDictHelper\", \"Ice.StringHelper\", \"IceGrid.NodeDescriptor\", false, undefined, undefined);\n\nconst iceC_IceGrid_LoadBalancingPolicy_ids = [\n    \"::Ice::Object\",\n    \"::IceGrid::LoadBalancingPolicy\"\n];\n\n/**\n * A base class for load balancing policies.\n *\n **/\nIceGrid.LoadBalancingPolicy = class extends Ice.Value\n{\n    constructor(nReplicas = \"\")\n    {\n        super();\n        this.nReplicas = nReplicas;\n    }\n\n    _iceWriteMemberImpl(ostr)\n    {\n        ostr.writeString(this.nReplicas);\n    }\n\n    _iceReadMemberImpl(istr)\n    {\n        this.nReplicas = istr.readString();\n    }\n};\n\nSlice.defineValue(IceGrid.LoadBalancingPolicy, iceC_IceGrid_LoadBalancingPolicy_ids[1], false);\n\nconst iceC_IceGrid_RandomLoadBalancingPolicy_ids = [\n    \"::Ice::Object\",\n    \"::IceGrid::LoadBalancingPolicy\",\n    \"::IceGrid::RandomLoadBalancingPolicy\"\n];\n\n/**\n * Random load balancing policy.\n *\n **/\nIceGrid.RandomLoadBalancingPolicy = class extends IceGrid.LoadBalancingPolicy\n{\n    constructor(nReplicas)\n    {\n        super(nReplicas);\n    }\n};\n\nSlice.defineValue(IceGrid.RandomLoadBalancingPolicy, iceC_IceGrid_RandomLoadBalancingPolicy_ids[2], false);\n\nconst iceC_IceGrid_OrderedLoadBalancingPolicy_ids = [\n    \"::Ice::Object\",\n    \"::IceGrid::LoadBalancingPolicy\",\n    \"::IceGrid::OrderedLoadBalancingPolicy\"\n];\n\n/**\n * Ordered load balancing policy.\n *\n **/\nIceGrid.OrderedLoadBalancingPolicy = class extends IceGrid.LoadBalancingPolicy\n{\n    constructor(nReplicas)\n    {\n        super(nReplicas);\n    }\n};\n\nSlice.defineValue(IceGrid.OrderedLoadBalancingPolicy, iceC_IceGrid_OrderedLoadBalancingPolicy_ids[2], false);\n\nconst iceC_IceGrid_RoundRobinLoadBalancingPolicy_ids = [\n    \"::Ice::Object\",\n    \"::IceGrid::LoadBalancingPolicy\",\n    \"::IceGrid::RoundRobinLoadBalancingPolicy\"\n];\n\n/**\n * Round robin load balancing policy.\n *\n **/\nIceGrid.RoundRobinLoadBalancingPolicy = class extends IceGrid.LoadBalancingPolicy\n{\n    constructor(nReplicas)\n    {\n        super(nReplicas);\n    }\n};\n\nSlice.defineValue(IceGrid.RoundRobinLoadBalancingPolicy, iceC_IceGrid_RoundRobinLoadBalancingPolicy_ids[2], false);\n\nconst iceC_IceGrid_AdaptiveLoadBalancingPolicy_ids = [\n    \"::Ice::Object\",\n    \"::IceGrid::AdaptiveLoadBalancingPolicy\",\n    \"::IceGrid::LoadBalancingPolicy\"\n];\n\n/**\n * Adaptive load balancing policy.\n *\n **/\nIceGrid.AdaptiveLoadBalancingPolicy = class extends IceGrid.LoadBalancingPolicy\n{\n    constructor(nReplicas, loadSample = \"\")\n    {\n        super(nReplicas);\n        this.loadSample = loadSample;\n    }\n\n    _iceWriteMemberImpl(ostr)\n    {\n        ostr.writeString(this.loadSample);\n    }\n\n    _iceReadMemberImpl(istr)\n    {\n        this.loadSample = istr.readString();\n    }\n};\n\nSlice.defineValue(IceGrid.AdaptiveLoadBalancingPolicy, iceC_IceGrid_AdaptiveLoadBalancingPolicy_ids[1], false);\n\n/**\n * A replica group descriptor.\n *\n **/\nIceGrid.ReplicaGroupDescriptor = class\n{\n    constructor(id = \"\", loadBalancing = null, proxyOptions = \"\", objects = null, description = \"\", filter = \"\")\n    {\n        this.id = id;\n        this.loadBalancing = loadBalancing;\n        this.proxyOptions = proxyOptions;\n        this.objects = objects;\n        this.description = description;\n        this.filter = filter;\n    }\n\n    _write(ostr)\n    {\n        ostr.writeString(this.id);\n        ostr.writeValue(this.loadBalancing);\n        ostr.writeString(this.proxyOptions);\n        IceGrid.ObjectDescriptorSeqHelper.write(ostr, this.objects);\n        ostr.writeString(this.description);\n        ostr.writeString(this.filter);\n    }\n\n    _read(istr)\n    {\n        this.id = istr.readString();\n        istr.readValue(obj => this.loadBalancing = obj, IceGrid.LoadBalancingPolicy);\n        this.proxyOptions = istr.readString();\n        this.objects = IceGrid.ObjectDescriptorSeqHelper.read(istr);\n        this.description = istr.readString();\n        this.filter = istr.readString();\n    }\n\n    static get minWireSize()\n    {\n        return  6;\n    }\n};\n\nSlice.defineStruct(IceGrid.ReplicaGroupDescriptor, false, true);\n\nSlice.defineSequence(IceGrid, \"ReplicaGroupDescriptorSeqHelper\", \"IceGrid.ReplicaGroupDescriptor\", false);\n\n/**\n * An application descriptor.\n *\n **/\nIceGrid.ApplicationDescriptor = class\n{\n    constructor(name = \"\", variables = null, replicaGroups = null, serverTemplates = null, serviceTemplates = null, nodes = null, distrib = new IceGrid.DistributionDescriptor(), description = \"\", propertySets = null)\n    {\n        this.name = name;\n        this.variables = variables;\n        this.replicaGroups = replicaGroups;\n        this.serverTemplates = serverTemplates;\n        this.serviceTemplates = serviceTemplates;\n        this.nodes = nodes;\n        this.distrib = distrib;\n        this.description = description;\n        this.propertySets = propertySets;\n    }\n\n    _write(ostr)\n    {\n        ostr.writeString(this.name);\n        IceGrid.StringStringDictHelper.write(ostr, this.variables);\n        IceGrid.ReplicaGroupDescriptorSeqHelper.write(ostr, this.replicaGroups);\n        IceGrid.TemplateDescriptorDictHelper.write(ostr, this.serverTemplates);\n        IceGrid.TemplateDescriptorDictHelper.write(ostr, this.serviceTemplates);\n        IceGrid.NodeDescriptorDictHelper.write(ostr, this.nodes);\n        IceGrid.DistributionDescriptor.write(ostr, this.distrib);\n        ostr.writeString(this.description);\n        IceGrid.PropertySetDescriptorDictHelper.write(ostr, this.propertySets);\n    }\n\n    _read(istr)\n    {\n        this.name = istr.readString();\n        this.variables = IceGrid.StringStringDictHelper.read(istr);\n        this.replicaGroups = IceGrid.ReplicaGroupDescriptorSeqHelper.read(istr);\n        this.serverTemplates = IceGrid.TemplateDescriptorDictHelper.read(istr);\n        this.serviceTemplates = IceGrid.TemplateDescriptorDictHelper.read(istr);\n        this.nodes = IceGrid.NodeDescriptorDictHelper.read(istr);\n        this.distrib = IceGrid.DistributionDescriptor.read(istr, this.distrib);\n        this.description = istr.readString();\n        this.propertySets = IceGrid.PropertySetDescriptorDictHelper.read(istr);\n    }\n\n    static get minWireSize()\n    {\n        return  10;\n    }\n};\n\nSlice.defineStruct(IceGrid.ApplicationDescriptor, false, true);\n\nSlice.defineSequence(IceGrid, \"ApplicationDescriptorSeqHelper\", \"IceGrid.ApplicationDescriptor\", false);\n\nconst iceC_IceGrid_BoxedString_ids = [\n    \"::Ice::Object\",\n    \"::IceGrid::BoxedString\"\n];\n\n/**\n * A \"boxed\" string.\n *\n **/\nIceGrid.BoxedString = class extends Ice.Value\n{\n    constructor(value = \"\")\n    {\n        super();\n        this.value = value;\n    }\n\n    _iceWriteMemberImpl(ostr)\n    {\n        ostr.writeString(this.value);\n    }\n\n    _iceReadMemberImpl(istr)\n    {\n        this.value = istr.readString();\n    }\n};\n\nSlice.defineValue(IceGrid.BoxedString, iceC_IceGrid_BoxedString_ids[1], false);\n\n/**\n * A node update descriptor to describe the updates to apply to a\n * node of a deployed application.\n *\n **/\nIceGrid.NodeUpdateDescriptor = class\n{\n    constructor(name = \"\", description = null, variables = null, removeVariables = null, propertySets = null, removePropertySets = null, serverInstances = null, servers = null, removeServers = null, loadFactor = null)\n    {\n        this.name = name;\n        this.description = description;\n        this.variables = variables;\n        this.removeVariables = removeVariables;\n        this.propertySets = propertySets;\n        this.removePropertySets = removePropertySets;\n        this.serverInstances = serverInstances;\n        this.servers = servers;\n        this.removeServers = removeServers;\n        this.loadFactor = loadFactor;\n    }\n\n    _write(ostr)\n    {\n        ostr.writeString(this.name);\n        ostr.writeValue(this.description);\n        IceGrid.StringStringDictHelper.write(ostr, this.variables);\n        Ice.StringSeqHelper.write(ostr, this.removeVariables);\n        IceGrid.PropertySetDescriptorDictHelper.write(ostr, this.propertySets);\n        Ice.StringSeqHelper.write(ostr, this.removePropertySets);\n        IceGrid.ServerInstanceDescriptorSeqHelper.write(ostr, this.serverInstances);\n        IceGrid.ServerDescriptorSeqHelper.write(ostr, this.servers);\n        Ice.StringSeqHelper.write(ostr, this.removeServers);\n        ostr.writeValue(this.loadFactor);\n    }\n\n    _read(istr)\n    {\n        this.name = istr.readString();\n        istr.readValue(obj => this.description = obj, IceGrid.BoxedString);\n        this.variables = IceGrid.StringStringDictHelper.read(istr);\n        this.removeVariables = Ice.StringSeqHelper.read(istr);\n        this.propertySets = IceGrid.PropertySetDescriptorDictHelper.read(istr);\n        this.removePropertySets = Ice.StringSeqHelper.read(istr);\n        this.serverInstances = IceGrid.ServerInstanceDescriptorSeqHelper.read(istr);\n        this.servers = IceGrid.ServerDescriptorSeqHelper.read(istr);\n        this.removeServers = Ice.StringSeqHelper.read(istr);\n        istr.readValue(obj => this.loadFactor = obj, IceGrid.BoxedString);\n    }\n\n    static get minWireSize()\n    {\n        return  10;\n    }\n};\n\nSlice.defineStruct(IceGrid.NodeUpdateDescriptor, false, true);\n\nSlice.defineSequence(IceGrid, \"NodeUpdateDescriptorSeqHelper\", \"IceGrid.NodeUpdateDescriptor\", false);\n\nconst iceC_IceGrid_BoxedDistributionDescriptor_ids = [\n    \"::Ice::Object\",\n    \"::IceGrid::BoxedDistributionDescriptor\"\n];\n\n/**\n * A \"boxed\" distribution descriptor.\n *\n **/\nIceGrid.BoxedDistributionDescriptor = class extends Ice.Value\n{\n    constructor(value = new IceGrid.DistributionDescriptor())\n    {\n        super();\n        this.value = value;\n    }\n\n    _iceWriteMemberImpl(ostr)\n    {\n        IceGrid.DistributionDescriptor.write(ostr, this.value);\n    }\n\n    _iceReadMemberImpl(istr)\n    {\n        this.value = IceGrid.DistributionDescriptor.read(istr, this.value);\n    }\n};\n\nSlice.defineValue(IceGrid.BoxedDistributionDescriptor, iceC_IceGrid_BoxedDistributionDescriptor_ids[1], false);\n\n/**\n * An application update descriptor to describe the updates to apply\n * to a deployed application.\n *\n **/\nIceGrid.ApplicationUpdateDescriptor = class\n{\n    constructor(name = \"\", description = null, distrib = null, variables = null, removeVariables = null, propertySets = null, removePropertySets = null, replicaGroups = null, removeReplicaGroups = null, serverTemplates = null, removeServerTemplates = null, serviceTemplates = null, removeServiceTemplates = null, nodes = null, removeNodes = null)\n    {\n        this.name = name;\n        this.description = description;\n        this.distrib = distrib;\n        this.variables = variables;\n        this.removeVariables = removeVariables;\n        this.propertySets = propertySets;\n        this.removePropertySets = removePropertySets;\n        this.replicaGroups = replicaGroups;\n        this.removeReplicaGroups = removeReplicaGroups;\n        this.serverTemplates = serverTemplates;\n        this.removeServerTemplates = removeServerTemplates;\n        this.serviceTemplates = serviceTemplates;\n        this.removeServiceTemplates = removeServiceTemplates;\n        this.nodes = nodes;\n        this.removeNodes = removeNodes;\n    }\n\n    _write(ostr)\n    {\n        ostr.writeString(this.name);\n        ostr.writeValue(this.description);\n        ostr.writeValue(this.distrib);\n        IceGrid.StringStringDictHelper.write(ostr, this.variables);\n        Ice.StringSeqHelper.write(ostr, this.removeVariables);\n        IceGrid.PropertySetDescriptorDictHelper.write(ostr, this.propertySets);\n        Ice.StringSeqHelper.write(ostr, this.removePropertySets);\n        IceGrid.ReplicaGroupDescriptorSeqHelper.write(ostr, this.replicaGroups);\n        Ice.StringSeqHelper.write(ostr, this.removeReplicaGroups);\n        IceGrid.TemplateDescriptorDictHelper.write(ostr, this.serverTemplates);\n        Ice.StringSeqHelper.write(ostr, this.removeServerTemplates);\n        IceGrid.TemplateDescriptorDictHelper.write(ostr, this.serviceTemplates);\n        Ice.StringSeqHelper.write(ostr, this.removeServiceTemplates);\n        IceGrid.NodeUpdateDescriptorSeqHelper.write(ostr, this.nodes);\n        Ice.StringSeqHelper.write(ostr, this.removeNodes);\n    }\n\n    _read(istr)\n    {\n        this.name = istr.readString();\n        istr.readValue(obj => this.description = obj, IceGrid.BoxedString);\n        istr.readValue(obj => this.distrib = obj, IceGrid.BoxedDistributionDescriptor);\n        this.variables = IceGrid.StringStringDictHelper.read(istr);\n        this.removeVariables = Ice.StringSeqHelper.read(istr);\n        this.propertySets = IceGrid.PropertySetDescriptorDictHelper.read(istr);\n        this.removePropertySets = Ice.StringSeqHelper.read(istr);\n        this.replicaGroups = IceGrid.ReplicaGroupDescriptorSeqHelper.read(istr);\n        this.removeReplicaGroups = Ice.StringSeqHelper.read(istr);\n        this.serverTemplates = IceGrid.TemplateDescriptorDictHelper.read(istr);\n        this.removeServerTemplates = Ice.StringSeqHelper.read(istr);\n        this.serviceTemplates = IceGrid.TemplateDescriptorDictHelper.read(istr);\n        this.removeServiceTemplates = Ice.StringSeqHelper.read(istr);\n        this.nodes = IceGrid.NodeUpdateDescriptorSeqHelper.read(istr);\n        this.removeNodes = Ice.StringSeqHelper.read(istr);\n    }\n\n    static get minWireSize()\n    {\n        return  15;\n    }\n};\n\nSlice.defineStruct(IceGrid.ApplicationUpdateDescriptor, false, true);\n/* slice2js browser-bundle-skip */\nexports.IceGrid = IceGrid;\n/* slice2js browser-bundle-skip-end */\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/IceGrid/Descriptor.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/IceGrid/Exception.js":
/*!***************************************************!*\
  !*** ./node_modules/ice/src/IceGrid/Exception.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n//\n// Ice version 3.7.10\n//\n// <auto-generated>\n//\n// Generated from file `Exception.ice'\n//\n// Warning: do not edit this file.\n//\n// </auto-generated>\n//\n\n/* eslint-disable */\n/* jshint ignore: start */\n\n/* slice2js browser-bundle-skip */\nconst _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\n__webpack_require__(/*! ../Ice/Exception */ \"./node_modules/ice/src/Ice/Exception.js\");\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\n__webpack_require__(/*! ../Ice/Identity */ \"./node_modules/ice/src/Ice/Identity.js\");\n__webpack_require__(/*! ../Ice/BuiltinSequences */ \"./node_modules/ice/src/Ice/BuiltinSequences.js\");\nconst Ice = _ModuleRegistry.module(\"Ice\");\n\nconst Slice = Ice.Slice;\n/* slice2js browser-bundle-skip-end */\n/* slice2js browser-bundle-skip */\n\nlet IceGrid = _ModuleRegistry.module(\"IceGrid\");\n/* slice2js browser-bundle-skip-end */\n\n/**\n * This exception is raised if an application does not exist.\n *\n **/\nIceGrid.ApplicationNotExistException = class extends Ice.UserException\n{\n    constructor(name = \"\", _cause = \"\")\n    {\n        super(_cause);\n        this.name = name;\n    }\n\n    static get _parent()\n    {\n        return Ice.UserException;\n    }\n\n    static get _id()\n    {\n        return \"::IceGrid::ApplicationNotExistException\";\n    }\n\n    _mostDerivedType()\n    {\n        return IceGrid.ApplicationNotExistException;\n    }\n\n    _writeMemberImpl(ostr)\n    {\n        ostr.writeString(this.name);\n    }\n\n    _readMemberImpl(istr)\n    {\n        this.name = istr.readString();\n    }\n};\n\n/**\n * This exception is raised if a server does not exist.\n *\n **/\nIceGrid.ServerNotExistException = class extends Ice.UserException\n{\n    constructor(id = \"\", _cause = \"\")\n    {\n        super(_cause);\n        this.id = id;\n    }\n\n    static get _parent()\n    {\n        return Ice.UserException;\n    }\n\n    static get _id()\n    {\n        return \"::IceGrid::ServerNotExistException\";\n    }\n\n    _mostDerivedType()\n    {\n        return IceGrid.ServerNotExistException;\n    }\n\n    _writeMemberImpl(ostr)\n    {\n        ostr.writeString(this.id);\n    }\n\n    _readMemberImpl(istr)\n    {\n        this.id = istr.readString();\n    }\n};\n\n/**\n * This exception is raised if a server failed to start.\n *\n **/\nIceGrid.ServerStartException = class extends Ice.UserException\n{\n    constructor(id = \"\", reason = \"\", _cause = \"\")\n    {\n        super(_cause);\n        this.id = id;\n        this.reason = reason;\n    }\n\n    static get _parent()\n    {\n        return Ice.UserException;\n    }\n\n    static get _id()\n    {\n        return \"::IceGrid::ServerStartException\";\n    }\n\n    _mostDerivedType()\n    {\n        return IceGrid.ServerStartException;\n    }\n\n    _writeMemberImpl(ostr)\n    {\n        ostr.writeString(this.id);\n        ostr.writeString(this.reason);\n    }\n\n    _readMemberImpl(istr)\n    {\n        this.id = istr.readString();\n        this.reason = istr.readString();\n    }\n};\n\n/**\n * This exception is raised if a server failed to stop.\n *\n **/\nIceGrid.ServerStopException = class extends Ice.UserException\n{\n    constructor(id = \"\", reason = \"\", _cause = \"\")\n    {\n        super(_cause);\n        this.id = id;\n        this.reason = reason;\n    }\n\n    static get _parent()\n    {\n        return Ice.UserException;\n    }\n\n    static get _id()\n    {\n        return \"::IceGrid::ServerStopException\";\n    }\n\n    _mostDerivedType()\n    {\n        return IceGrid.ServerStopException;\n    }\n\n    _writeMemberImpl(ostr)\n    {\n        ostr.writeString(this.id);\n        ostr.writeString(this.reason);\n    }\n\n    _readMemberImpl(istr)\n    {\n        this.id = istr.readString();\n        this.reason = istr.readString();\n    }\n};\n\n/**\n * This exception is raised if an adapter does not exist.\n *\n **/\nIceGrid.AdapterNotExistException = class extends Ice.UserException\n{\n    constructor(id = \"\", _cause = \"\")\n    {\n        super(_cause);\n        this.id = id;\n    }\n\n    static get _parent()\n    {\n        return Ice.UserException;\n    }\n\n    static get _id()\n    {\n        return \"::IceGrid::AdapterNotExistException\";\n    }\n\n    _mostDerivedType()\n    {\n        return IceGrid.AdapterNotExistException;\n    }\n\n    _writeMemberImpl(ostr)\n    {\n        ostr.writeString(this.id);\n    }\n\n    _readMemberImpl(istr)\n    {\n        this.id = istr.readString();\n    }\n};\n\n/**\n * This exception is raised if an object already exists.\n *\n **/\nIceGrid.ObjectExistsException = class extends Ice.UserException\n{\n    constructor(id = new Ice.Identity(), _cause = \"\")\n    {\n        super(_cause);\n        this.id = id;\n    }\n\n    static get _parent()\n    {\n        return Ice.UserException;\n    }\n\n    static get _id()\n    {\n        return \"::IceGrid::ObjectExistsException\";\n    }\n\n    _mostDerivedType()\n    {\n        return IceGrid.ObjectExistsException;\n    }\n\n    _writeMemberImpl(ostr)\n    {\n        Ice.Identity.write(ostr, this.id);\n    }\n\n    _readMemberImpl(istr)\n    {\n        this.id = Ice.Identity.read(istr, this.id);\n    }\n};\n\n/**\n * This exception is raised if an object is not registered.\n *\n **/\nIceGrid.ObjectNotRegisteredException = class extends Ice.UserException\n{\n    constructor(id = new Ice.Identity(), _cause = \"\")\n    {\n        super(_cause);\n        this.id = id;\n    }\n\n    static get _parent()\n    {\n        return Ice.UserException;\n    }\n\n    static get _id()\n    {\n        return \"::IceGrid::ObjectNotRegisteredException\";\n    }\n\n    _mostDerivedType()\n    {\n        return IceGrid.ObjectNotRegisteredException;\n    }\n\n    _writeMemberImpl(ostr)\n    {\n        Ice.Identity.write(ostr, this.id);\n    }\n\n    _readMemberImpl(istr)\n    {\n        this.id = Ice.Identity.read(istr, this.id);\n    }\n};\n\n/**\n * This exception is raised if a node does not exist.\n *\n **/\nIceGrid.NodeNotExistException = class extends Ice.UserException\n{\n    constructor(name = \"\", _cause = \"\")\n    {\n        super(_cause);\n        this.name = name;\n    }\n\n    static get _parent()\n    {\n        return Ice.UserException;\n    }\n\n    static get _id()\n    {\n        return \"::IceGrid::NodeNotExistException\";\n    }\n\n    _mostDerivedType()\n    {\n        return IceGrid.NodeNotExistException;\n    }\n\n    _writeMemberImpl(ostr)\n    {\n        ostr.writeString(this.name);\n    }\n\n    _readMemberImpl(istr)\n    {\n        this.name = istr.readString();\n    }\n};\n\n/**\n * This exception is raised if a registry does not exist.\n *\n **/\nIceGrid.RegistryNotExistException = class extends Ice.UserException\n{\n    constructor(name = \"\", _cause = \"\")\n    {\n        super(_cause);\n        this.name = name;\n    }\n\n    static get _parent()\n    {\n        return Ice.UserException;\n    }\n\n    static get _id()\n    {\n        return \"::IceGrid::RegistryNotExistException\";\n    }\n\n    _mostDerivedType()\n    {\n        return IceGrid.RegistryNotExistException;\n    }\n\n    _writeMemberImpl(ostr)\n    {\n        ostr.writeString(this.name);\n    }\n\n    _readMemberImpl(istr)\n    {\n        this.name = istr.readString();\n    }\n};\n\n/**\n * An exception for deployment errors.\n *\n **/\nIceGrid.DeploymentException = class extends Ice.UserException\n{\n    constructor(reason = \"\", _cause = \"\")\n    {\n        super(_cause);\n        this.reason = reason;\n    }\n\n    static get _parent()\n    {\n        return Ice.UserException;\n    }\n\n    static get _id()\n    {\n        return \"::IceGrid::DeploymentException\";\n    }\n\n    _mostDerivedType()\n    {\n        return IceGrid.DeploymentException;\n    }\n\n    _writeMemberImpl(ostr)\n    {\n        ostr.writeString(this.reason);\n    }\n\n    _readMemberImpl(istr)\n    {\n        this.reason = istr.readString();\n    }\n};\n\n/**\n * This exception is raised if a node could not be reached.\n *\n **/\nIceGrid.NodeUnreachableException = class extends Ice.UserException\n{\n    constructor(name = \"\", reason = \"\", _cause = \"\")\n    {\n        super(_cause);\n        this.name = name;\n        this.reason = reason;\n    }\n\n    static get _parent()\n    {\n        return Ice.UserException;\n    }\n\n    static get _id()\n    {\n        return \"::IceGrid::NodeUnreachableException\";\n    }\n\n    _mostDerivedType()\n    {\n        return IceGrid.NodeUnreachableException;\n    }\n\n    _writeMemberImpl(ostr)\n    {\n        ostr.writeString(this.name);\n        ostr.writeString(this.reason);\n    }\n\n    _readMemberImpl(istr)\n    {\n        this.name = istr.readString();\n        this.reason = istr.readString();\n    }\n};\n\n/**\n * This exception is raised if a server could not be reached.\n *\n **/\nIceGrid.ServerUnreachableException = class extends Ice.UserException\n{\n    constructor(name = \"\", reason = \"\", _cause = \"\")\n    {\n        super(_cause);\n        this.name = name;\n        this.reason = reason;\n    }\n\n    static get _parent()\n    {\n        return Ice.UserException;\n    }\n\n    static get _id()\n    {\n        return \"::IceGrid::ServerUnreachableException\";\n    }\n\n    _mostDerivedType()\n    {\n        return IceGrid.ServerUnreachableException;\n    }\n\n    _writeMemberImpl(ostr)\n    {\n        ostr.writeString(this.name);\n        ostr.writeString(this.reason);\n    }\n\n    _readMemberImpl(istr)\n    {\n        this.name = istr.readString();\n        this.reason = istr.readString();\n    }\n};\n\n/**\n * This exception is raised if a registry could not be reached.\n *\n **/\nIceGrid.RegistryUnreachableException = class extends Ice.UserException\n{\n    constructor(name = \"\", reason = \"\", _cause = \"\")\n    {\n        super(_cause);\n        this.name = name;\n        this.reason = reason;\n    }\n\n    static get _parent()\n    {\n        return Ice.UserException;\n    }\n\n    static get _id()\n    {\n        return \"::IceGrid::RegistryUnreachableException\";\n    }\n\n    _mostDerivedType()\n    {\n        return IceGrid.RegistryUnreachableException;\n    }\n\n    _writeMemberImpl(ostr)\n    {\n        ostr.writeString(this.name);\n        ostr.writeString(this.reason);\n    }\n\n    _readMemberImpl(istr)\n    {\n        this.name = istr.readString();\n        this.reason = istr.readString();\n    }\n};\n\n/**\n * This exception is raised if an unknown signal was sent to\n * to a server.\n *\n **/\nIceGrid.BadSignalException = class extends Ice.UserException\n{\n    constructor(reason = \"\", _cause = \"\")\n    {\n        super(_cause);\n        this.reason = reason;\n    }\n\n    static get _parent()\n    {\n        return Ice.UserException;\n    }\n\n    static get _id()\n    {\n        return \"::IceGrid::BadSignalException\";\n    }\n\n    _mostDerivedType()\n    {\n        return IceGrid.BadSignalException;\n    }\n\n    _writeMemberImpl(ostr)\n    {\n        ostr.writeString(this.reason);\n    }\n\n    _readMemberImpl(istr)\n    {\n        this.reason = istr.readString();\n    }\n};\n\n/**\n * This exception is raised if a patch failed.\n *\n **/\nIceGrid.PatchException = class extends Ice.UserException\n{\n    constructor(reasons = null, _cause = \"\")\n    {\n        super(_cause);\n        this.reasons = reasons;\n    }\n\n    static get _parent()\n    {\n        return Ice.UserException;\n    }\n\n    static get _id()\n    {\n        return \"::IceGrid::PatchException\";\n    }\n\n    _mostDerivedType()\n    {\n        return IceGrid.PatchException;\n    }\n\n    _writeMemberImpl(ostr)\n    {\n        Ice.StringSeqHelper.write(ostr, this.reasons);\n    }\n\n    _readMemberImpl(istr)\n    {\n        this.reasons = Ice.StringSeqHelper.read(istr);\n    }\n};\n\n/**\n * This exception is raised if a registry lock wasn't\n * acquired or is already held by a session.\n *\n **/\nIceGrid.AccessDeniedException = class extends Ice.UserException\n{\n    constructor(lockUserId = \"\", _cause = \"\")\n    {\n        super(_cause);\n        this.lockUserId = lockUserId;\n    }\n\n    static get _parent()\n    {\n        return Ice.UserException;\n    }\n\n    static get _id()\n    {\n        return \"::IceGrid::AccessDeniedException\";\n    }\n\n    _mostDerivedType()\n    {\n        return IceGrid.AccessDeniedException;\n    }\n\n    _writeMemberImpl(ostr)\n    {\n        ostr.writeString(this.lockUserId);\n    }\n\n    _readMemberImpl(istr)\n    {\n        this.lockUserId = istr.readString();\n    }\n};\n\n/**\n * This exception is raised if the allocation of an object failed.\n *\n **/\nIceGrid.AllocationException = class extends Ice.UserException\n{\n    constructor(reason = \"\", _cause = \"\")\n    {\n        super(_cause);\n        this.reason = reason;\n    }\n\n    static get _parent()\n    {\n        return Ice.UserException;\n    }\n\n    static get _id()\n    {\n        return \"::IceGrid::AllocationException\";\n    }\n\n    _mostDerivedType()\n    {\n        return IceGrid.AllocationException;\n    }\n\n    _writeMemberImpl(ostr)\n    {\n        ostr.writeString(this.reason);\n    }\n\n    _readMemberImpl(istr)\n    {\n        this.reason = istr.readString();\n    }\n};\n\n/**\n * This exception is raised if the request to allocate an object times\n * out.\n *\n **/\nIceGrid.AllocationTimeoutException = class extends IceGrid.AllocationException\n{\n    constructor(reason, _cause = \"\")\n    {\n        super(reason, _cause);\n    }\n\n    static get _parent()\n    {\n        return IceGrid.AllocationException;\n    }\n\n    static get _id()\n    {\n        return \"::IceGrid::AllocationTimeoutException\";\n    }\n\n    _mostDerivedType()\n    {\n        return IceGrid.AllocationTimeoutException;\n    }\n};\n\n/**\n * This exception is raised if a client is denied the ability to create\n * a session with IceGrid.\n *\n **/\nIceGrid.PermissionDeniedException = class extends Ice.UserException\n{\n    constructor(reason = \"\", _cause = \"\")\n    {\n        super(_cause);\n        this.reason = reason;\n    }\n\n    static get _parent()\n    {\n        return Ice.UserException;\n    }\n\n    static get _id()\n    {\n        return \"::IceGrid::PermissionDeniedException\";\n    }\n\n    _mostDerivedType()\n    {\n        return IceGrid.PermissionDeniedException;\n    }\n\n    _writeMemberImpl(ostr)\n    {\n        ostr.writeString(this.reason);\n    }\n\n    _readMemberImpl(istr)\n    {\n        this.reason = istr.readString();\n    }\n};\n\n/**\n * This exception is raised if an observer is already registered with\n * the registry.\n *\n * @see AdminSession#setObservers\n * @see AdminSession#setObserversByIdentity\n *\n **/\nIceGrid.ObserverAlreadyRegisteredException = class extends Ice.UserException\n{\n    constructor(id = new Ice.Identity(), _cause = \"\")\n    {\n        super(_cause);\n        this.id = id;\n    }\n\n    static get _parent()\n    {\n        return Ice.UserException;\n    }\n\n    static get _id()\n    {\n        return \"::IceGrid::ObserverAlreadyRegisteredException\";\n    }\n\n    _mostDerivedType()\n    {\n        return IceGrid.ObserverAlreadyRegisteredException;\n    }\n\n    _writeMemberImpl(ostr)\n    {\n        Ice.Identity.write(ostr, this.id);\n    }\n\n    _readMemberImpl(istr)\n    {\n        this.id = Ice.Identity.read(istr, this.id);\n    }\n};\n\n/**\n * This exception is raised if a file is not available.\n *\n * @see AdminSession#openServerStdOut\n * @see AdminSession#openServerStdErr\n * @see AdminSession#openNodeStdOut\n * @see AdminSession#openNodeStdErr\n * @see AdminSession#openRegistryStdOut\n * @see AdminSession#openRegistryStdErr\n *\n **/\nIceGrid.FileNotAvailableException = class extends Ice.UserException\n{\n    constructor(reason = \"\", _cause = \"\")\n    {\n        super(_cause);\n        this.reason = reason;\n    }\n\n    static get _parent()\n    {\n        return Ice.UserException;\n    }\n\n    static get _id()\n    {\n        return \"::IceGrid::FileNotAvailableException\";\n    }\n\n    _mostDerivedType()\n    {\n        return IceGrid.FileNotAvailableException;\n    }\n\n    _writeMemberImpl(ostr)\n    {\n        ostr.writeString(this.reason);\n    }\n\n    _readMemberImpl(istr)\n    {\n        this.reason = istr.readString();\n    }\n};\n/* slice2js browser-bundle-skip */\nexports.IceGrid = IceGrid;\n/* slice2js browser-bundle-skip-end */\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/IceGrid/Exception.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/IceGrid/FileParser.js":
/*!****************************************************!*\
  !*** ./node_modules/ice/src/IceGrid/FileParser.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n//\n// Ice version 3.7.10\n//\n// <auto-generated>\n//\n// Generated from file `FileParser.ice'\n//\n// Warning: do not edit this file.\n//\n// </auto-generated>\n//\n\n/* eslint-disable */\n/* jshint ignore: start */\n\n/* slice2js browser-bundle-skip */\nconst _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\n__webpack_require__(/*! ../Ice/Object */ \"./node_modules/ice/src/Ice/Object.js\");\n__webpack_require__(/*! ../Ice/Value */ \"./node_modules/ice/src/Ice/Value.js\");\n__webpack_require__(/*! ../Ice/ObjectPrx */ \"./node_modules/ice/src/Ice/ObjectPrx.js\");\n__webpack_require__(/*! ../Ice/Operation */ \"./node_modules/ice/src/Ice/Operation.js\");\n__webpack_require__(/*! ../Ice/Exception */ \"./node_modules/ice/src/Ice/Exception.js\");\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\nconst Ice = _ModuleRegistry.module(\"Ice\");\n\nconst IceGrid = (__webpack_require__(/*! ../IceGrid/Admin */ \"./node_modules/ice/src/IceGrid/Admin.js\").IceGrid);\nconst Slice = Ice.Slice;\n/* slice2js browser-bundle-skip-end */\n\n/**\n * This exception is raised if an error occurs during parsing.\n *\n **/\nIceGrid.ParseException = class extends Ice.UserException\n{\n    constructor(reason = \"\", _cause = \"\")\n    {\n        super(_cause);\n        this.reason = reason;\n    }\n\n    static get _parent()\n    {\n        return Ice.UserException;\n    }\n\n    static get _id()\n    {\n        return \"::IceGrid::ParseException\";\n    }\n\n    _mostDerivedType()\n    {\n        return IceGrid.ParseException;\n    }\n\n    _writeMemberImpl(ostr)\n    {\n        ostr.writeString(this.reason);\n    }\n\n    _readMemberImpl(istr)\n    {\n        this.reason = istr.readString();\n    }\n};\n\nconst iceC_IceGrid_FileParser_ids = [\n    \"::Ice::Object\",\n    \"::IceGrid::FileParser\"\n];\n\n/**\n * <code>icegridadmin</code> provides a {@link FileParser}\n * object to transform XML files into {@link ApplicationDescriptor}\n * objects.\n *\n **/\nIceGrid.FileParser = class extends Ice.Object\n{\n};\n\nIceGrid.FileParserPrx = class extends Ice.ObjectPrx\n{\n};\n\nSlice.defineOperations(IceGrid.FileParser, IceGrid.FileParserPrx, iceC_IceGrid_FileParser_ids, 1,\n{\n    \"parse\": [, 2, 2, , [IceGrid.ApplicationDescriptor], [[7], [\"IceGrid.AdminPrx\"]], ,\n    [\n        IceGrid.ParseException\n    ], , true]\n});\n/* slice2js browser-bundle-skip */\nexports.IceGrid = IceGrid;\n/* slice2js browser-bundle-skip-end */\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/IceGrid/FileParser.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/IceGrid/IceGrid.js":
/*!*************************************************!*\
  !*** ./node_modules/ice/src/IceGrid/IceGrid.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nconst _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\n\n__webpack_require__(/*! ../IceGrid/Admin */ \"./node_modules/ice/src/IceGrid/Admin.js\");\n__webpack_require__(/*! ../IceGrid/Descriptor */ \"./node_modules/ice/src/IceGrid/Descriptor.js\");\n__webpack_require__(/*! ../IceGrid/Exception */ \"./node_modules/ice/src/IceGrid/Exception.js\");\n__webpack_require__(/*! ../IceGrid/FileParser */ \"./node_modules/ice/src/IceGrid/FileParser.js\");\n__webpack_require__(/*! ../IceGrid/Registry */ \"./node_modules/ice/src/IceGrid/Registry.js\");\n__webpack_require__(/*! ../IceGrid/Session */ \"./node_modules/ice/src/IceGrid/Session.js\");\n__webpack_require__(/*! ../IceGrid/UserAccountMapper */ \"./node_modules/ice/src/IceGrid/UserAccountMapper.js\");\n\nmodule.exports.IceGrid = _ModuleRegistry.module(\"IceGrid\");\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/IceGrid/IceGrid.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/IceGrid/Registry.js":
/*!**************************************************!*\
  !*** ./node_modules/ice/src/IceGrid/Registry.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n//\n// Ice version 3.7.10\n//\n// <auto-generated>\n//\n// Generated from file `Registry.ice'\n//\n// Warning: do not edit this file.\n//\n// </auto-generated>\n//\n\n/* eslint-disable */\n/* jshint ignore: start */\n\n/* slice2js browser-bundle-skip */\nconst _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\n__webpack_require__(/*! ../Ice/Object */ \"./node_modules/ice/src/Ice/Object.js\");\n__webpack_require__(/*! ../Ice/Value */ \"./node_modules/ice/src/Ice/Value.js\");\n__webpack_require__(/*! ../Ice/ObjectPrx */ \"./node_modules/ice/src/Ice/ObjectPrx.js\");\n__webpack_require__(/*! ../Ice/Operation */ \"./node_modules/ice/src/Ice/Operation.js\");\n__webpack_require__(/*! ../Ice/EnumBase */ \"./node_modules/ice/src/Ice/EnumBase.js\");\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\n__webpack_require__(/*! ../Ice/Locator */ \"./node_modules/ice/src/Ice/Locator.js\");\nconst Ice = _ModuleRegistry.module(\"Ice\");\n\n__webpack_require__(/*! ../IceGrid/Exception */ \"./node_modules/ice/src/IceGrid/Exception.js\");\n__webpack_require__(/*! ../IceGrid/Session */ \"./node_modules/ice/src/IceGrid/Session.js\");\n__webpack_require__(/*! ../IceGrid/Admin */ \"./node_modules/ice/src/IceGrid/Admin.js\");\nconst IceGrid = _ModuleRegistry.module(\"IceGrid\");\n\nconst Slice = Ice.Slice;\n/* slice2js browser-bundle-skip-end */\n\n/**\n * Determines which load sampling interval to use.\n *\n **/\nIceGrid.LoadSample = Slice.defineEnum([\n    ['LoadSample1', 0], ['LoadSample5', 1], ['LoadSample15', 2]]);\n\nconst iceC_IceGrid_Query_ids = [\n    \"::Ice::Object\",\n    \"::IceGrid::Query\"\n];\n\n/**\n * The IceGrid query interface. This interface is accessible to\n * Ice clients who wish to look up well-known objects.\n *\n **/\nIceGrid.Query = class extends Ice.Object\n{\n};\n\nIceGrid.QueryPrx = class extends Ice.ObjectPrx\n{\n};\n\nSlice.defineOperations(IceGrid.Query, IceGrid.QueryPrx, iceC_IceGrid_Query_ids, 1,\n{\n    \"findObjectById\": [, 2, 1, , [9], [[Ice.Identity]], , , , ],\n    \"findObjectByType\": [, 2, 1, , [9], [[7]], , , , ],\n    \"findObjectByTypeOnLeastLoadedNode\": [, 2, 1, , [9], [[7], [IceGrid.LoadSample._helper]], , , , ],\n    \"findAllObjectsByType\": [, 2, 1, , [\"Ice.ObjectProxySeqHelper\"], [[7]], , , , ],\n    \"findAllReplicas\": [, 2, 2, , [\"Ice.ObjectProxySeqHelper\"], [[9]], , , , ]\n});\n\nconst iceC_IceGrid_Registry_ids = [\n    \"::Ice::Object\",\n    \"::IceGrid::Registry\"\n];\n\n/**\n * The IceGrid registry allows clients create sessions\n * directly with the registry.\n *\n * @see Session\n * @see AdminSession\n *\n **/\nIceGrid.Registry = class extends Ice.Object\n{\n};\n\nIceGrid.RegistryPrx = class extends Ice.ObjectPrx\n{\n};\n\nSlice.defineOperations(IceGrid.Registry, IceGrid.RegistryPrx, iceC_IceGrid_Registry_ids, 1,\n{\n    \"createSession\": [, , , , [\"IceGrid.SessionPrx\"], [[7], [7]], ,\n    [\n        IceGrid.PermissionDeniedException\n    ], , ],\n    \"createAdminSession\": [, , , , [\"IceGrid.AdminSessionPrx\"], [[7], [7]], ,\n    [\n        IceGrid.PermissionDeniedException\n    ], , ],\n    \"createSessionFromSecureConnection\": [, , , , [\"IceGrid.SessionPrx\"], , ,\n    [\n        IceGrid.PermissionDeniedException\n    ], , ],\n    \"createAdminSessionFromSecureConnection\": [, , , , [\"IceGrid.AdminSessionPrx\"], , ,\n    [\n        IceGrid.PermissionDeniedException\n    ], , ],\n    \"getSessionTimeout\": [, 2, 1, , [3], , , , , ],\n    \"getACMTimeout\": [, 2, 1, , [3], , , , , ]\n});\n\nconst iceC_IceGrid_Locator_ids = [\n    \"::Ice::Locator\",\n    \"::Ice::Object\",\n    \"::IceGrid::Locator\"\n];\n\n/**\n * The IceGrid locator interface provides access to the {@link Query}\n * and {@link Registry} object of the IceGrid registry.\n *\n * @see Query\n * @see Registry\n *\n **/\nIceGrid.Locator = class extends Ice.Object\n{\n    static get _iceImplements()\n    {\n        return [\n            Ice.Locator\n        ];\n    }\n};\n\nIceGrid.LocatorPrx = class extends Ice.ObjectPrx\n{\n    static get _implements()\n    {\n        return [\n            Ice.LocatorPrx];\n    }\n};\n\nSlice.defineOperations(IceGrid.Locator, IceGrid.LocatorPrx, iceC_IceGrid_Locator_ids, 2,\n{\n    \"getLocalRegistry\": [, 2, 2, , [\"IceGrid.RegistryPrx\"], , , , , ],\n    \"getLocalQuery\": [, 2, 2, , [\"IceGrid.QueryPrx\"], , , , , ]\n});\n/* slice2js browser-bundle-skip */\nexports.IceGrid = IceGrid;\n/* slice2js browser-bundle-skip-end */\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/IceGrid/Registry.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/IceGrid/Session.js":
/*!*************************************************!*\
  !*** ./node_modules/ice/src/IceGrid/Session.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n//\n// Ice version 3.7.10\n//\n// <auto-generated>\n//\n// Generated from file `Session.ice'\n//\n// Warning: do not edit this file.\n//\n// </auto-generated>\n//\n\n/* eslint-disable */\n/* jshint ignore: start */\n\n/* slice2js browser-bundle-skip */\nconst _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\nconst Glacier2 = (__webpack_require__(/*! ../Glacier2/Session */ \"./node_modules/ice/src/Glacier2/Session.js\").Glacier2);\n__webpack_require__(/*! ../Ice/Object */ \"./node_modules/ice/src/Ice/Object.js\");\n__webpack_require__(/*! ../Ice/Value */ \"./node_modules/ice/src/Ice/Value.js\");\n__webpack_require__(/*! ../Ice/ObjectPrx */ \"./node_modules/ice/src/Ice/ObjectPrx.js\");\n__webpack_require__(/*! ../Ice/Operation */ \"./node_modules/ice/src/Ice/Operation.js\");\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\nconst Ice = _ModuleRegistry.module(\"Ice\");\n\nconst IceGrid = (__webpack_require__(/*! ../IceGrid/Exception */ \"./node_modules/ice/src/IceGrid/Exception.js\").IceGrid);\nconst Slice = Ice.Slice;\n/* slice2js browser-bundle-skip-end */\n\nconst iceC_IceGrid_Session_ids = [\n    \"::Glacier2::Session\",\n    \"::Ice::Object\",\n    \"::IceGrid::Session\"\n];\n\n/**\n * A session object is used by IceGrid clients to allocate and\n * release objects. Client sessions are created either via the\n * {@link Registry} object or via the registry client <code>SessionManager</code>\n * object.\n *\n * @see Registry\n *\n **/\nIceGrid.Session = class extends Ice.Object\n{\n    static get _iceImplements()\n    {\n        return [\n            Glacier2.Session\n        ];\n    }\n};\n\nIceGrid.SessionPrx = class extends Ice.ObjectPrx\n{\n    static get _implements()\n    {\n        return [\n            Glacier2.SessionPrx];\n    }\n};\n\nSlice.defineOperations(IceGrid.Session, IceGrid.SessionPrx, iceC_IceGrid_Session_ids, 2,\n{\n    \"keepAlive\": [, 2, 2, , , , , , , ],\n    \"allocateObjectById\": [, , , , [9], [[Ice.Identity]], ,\n    [\n        IceGrid.AllocationException,\n        IceGrid.ObjectNotRegisteredException\n    ], , ],\n    \"allocateObjectByType\": [, , , , [9], [[7]], ,\n    [\n        IceGrid.AllocationException\n    ], , ],\n    \"releaseObject\": [, , , , , [[Ice.Identity]], ,\n    [\n        IceGrid.AllocationException,\n        IceGrid.ObjectNotRegisteredException\n    ], , ],\n    \"setAllocationTimeout\": [, 2, 2, , , [[3]], , , , ]\n});\n/* slice2js browser-bundle-skip */\nexports.IceGrid = IceGrid;\n/* slice2js browser-bundle-skip-end */\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/IceGrid/Session.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/IceGrid/UserAccountMapper.js":
/*!***********************************************************!*\
  !*** ./node_modules/ice/src/IceGrid/UserAccountMapper.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n//\n// Ice version 3.7.10\n//\n// <auto-generated>\n//\n// Generated from file `UserAccountMapper.ice'\n//\n// Warning: do not edit this file.\n//\n// </auto-generated>\n//\n\n/* eslint-disable */\n/* jshint ignore: start */\n\n/* slice2js browser-bundle-skip */\nconst _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\n__webpack_require__(/*! ../Ice/Object */ \"./node_modules/ice/src/Ice/Object.js\");\n__webpack_require__(/*! ../Ice/Value */ \"./node_modules/ice/src/Ice/Value.js\");\n__webpack_require__(/*! ../Ice/ObjectPrx */ \"./node_modules/ice/src/Ice/ObjectPrx.js\");\n__webpack_require__(/*! ../Ice/Operation */ \"./node_modules/ice/src/Ice/Operation.js\");\n__webpack_require__(/*! ../Ice/Exception */ \"./node_modules/ice/src/Ice/Exception.js\");\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\nconst Ice = _ModuleRegistry.module(\"Ice\");\n\nconst Slice = Ice.Slice;\n/* slice2js browser-bundle-skip-end */\n/* slice2js browser-bundle-skip */\n\nlet IceGrid = _ModuleRegistry.module(\"IceGrid\");\n/* slice2js browser-bundle-skip-end */\n\n/**\n * This exception is raised if a user account for a given session\n * identifier can't be found.\n *\n **/\nIceGrid.UserAccountNotFoundException = class extends Ice.UserException\n{\n    constructor(_cause = \"\")\n    {\n        super(_cause);\n    }\n\n    static get _parent()\n    {\n        return Ice.UserException;\n    }\n\n    static get _id()\n    {\n        return \"::IceGrid::UserAccountNotFoundException\";\n    }\n\n    _mostDerivedType()\n    {\n        return IceGrid.UserAccountNotFoundException;\n    }\n};\n\nconst iceC_IceGrid_UserAccountMapper_ids = [\n    \"::Ice::Object\",\n    \"::IceGrid::UserAccountMapper\"\n];\n\n/**\n * A user account mapper object is used by IceGrid nodes to map\n * session identifiers to user accounts.\n *\n **/\nIceGrid.UserAccountMapper = class extends Ice.Object\n{\n};\n\nIceGrid.UserAccountMapperPrx = class extends Ice.ObjectPrx\n{\n};\n\nSlice.defineOperations(IceGrid.UserAccountMapper, IceGrid.UserAccountMapperPrx, iceC_IceGrid_UserAccountMapper_ids, 1,\n{\n    \"getUserAccount\": [, , , , [7], [[7]], ,\n    [\n        IceGrid.UserAccountNotFoundException\n    ], , ]\n});\n/* slice2js browser-bundle-skip */\nexports.IceGrid = IceGrid;\n/* slice2js browser-bundle-skip-end */\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/IceGrid/UserAccountMapper.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/IceStorm/IceStorm.js":
/*!***************************************************!*\
  !*** ./node_modules/ice/src/IceStorm/IceStorm.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n//\n// Ice version 3.7.10\n//\n// <auto-generated>\n//\n// Generated from file `IceStorm.ice'\n//\n// Warning: do not edit this file.\n//\n// </auto-generated>\n//\n\n/* eslint-disable */\n/* jshint ignore: start */\n\n/* slice2js browser-bundle-skip */\nconst _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\n__webpack_require__(/*! ../Ice/Object */ \"./node_modules/ice/src/Ice/Object.js\");\n__webpack_require__(/*! ../Ice/Value */ \"./node_modules/ice/src/Ice/Value.js\");\n__webpack_require__(/*! ../Ice/ObjectPrx */ \"./node_modules/ice/src/Ice/ObjectPrx.js\");\n__webpack_require__(/*! ../Ice/Operation */ \"./node_modules/ice/src/Ice/Operation.js\");\n__webpack_require__(/*! ../Ice/Struct */ \"./node_modules/ice/src/Ice/Struct.js\");\n__webpack_require__(/*! ../Ice/Exception */ \"./node_modules/ice/src/Ice/Exception.js\");\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\n__webpack_require__(/*! ../Ice/Identity */ \"./node_modules/ice/src/Ice/Identity.js\");\n__webpack_require__(/*! ../Ice/SliceChecksumDict */ \"./node_modules/ice/src/Ice/SliceChecksumDict.js\");\nconst Ice = _ModuleRegistry.module(\"Ice\");\n\nconst IceMX = (__webpack_require__(/*! ../IceStorm/Metrics */ \"./node_modules/ice/src/IceStorm/Metrics.js\").IceMX);\nconst Slice = Ice.Slice;\n/* slice2js browser-bundle-skip-end */\n/* slice2js browser-bundle-skip */\n\nlet IceStorm = _ModuleRegistry.module(\"IceStorm\");\n/* slice2js browser-bundle-skip-end */\n\n/**\n * Information on the topic links.\n *\n **/\nIceStorm.LinkInfo = class\n{\n    constructor(theTopic = null, name = \"\", cost = 0)\n    {\n        this.theTopic = theTopic;\n        this.name = name;\n        this.cost = cost;\n    }\n\n    _write(ostr)\n    {\n        IceStorm.TopicPrx.write(ostr, this.theTopic);\n        ostr.writeString(this.name);\n        ostr.writeInt(this.cost);\n    }\n\n    _read(istr)\n    {\n        this.theTopic = IceStorm.TopicPrx.read(istr, this.theTopic);\n        this.name = istr.readString();\n        this.cost = istr.readInt();\n    }\n\n    static get minWireSize()\n    {\n        return  7;\n    }\n};\n\nSlice.defineStruct(IceStorm.LinkInfo, false, true);\n\nSlice.defineSequence(IceStorm, \"LinkInfoSeqHelper\", \"IceStorm.LinkInfo\", false);\n\nSlice.defineDictionary(IceStorm, \"QoS\", \"QoSHelper\", \"Ice.StringHelper\", \"Ice.StringHelper\", false, undefined, undefined);\n\n/**\n * This exception indicates that an attempt was made to create a link\n * that already exists.\n *\n **/\nIceStorm.LinkExists = class extends Ice.UserException\n{\n    constructor(name = \"\", _cause = \"\")\n    {\n        super(_cause);\n        this.name = name;\n    }\n\n    static get _parent()\n    {\n        return Ice.UserException;\n    }\n\n    static get _id()\n    {\n        return \"::IceStorm::LinkExists\";\n    }\n\n    _mostDerivedType()\n    {\n        return IceStorm.LinkExists;\n    }\n\n    _writeMemberImpl(ostr)\n    {\n        ostr.writeString(this.name);\n    }\n\n    _readMemberImpl(istr)\n    {\n        this.name = istr.readString();\n    }\n};\n\n/**\n * This exception indicates that an attempt was made to remove a\n * link that does not exist.\n *\n **/\nIceStorm.NoSuchLink = class extends Ice.UserException\n{\n    constructor(name = \"\", _cause = \"\")\n    {\n        super(_cause);\n        this.name = name;\n    }\n\n    static get _parent()\n    {\n        return Ice.UserException;\n    }\n\n    static get _id()\n    {\n        return \"::IceStorm::NoSuchLink\";\n    }\n\n    _mostDerivedType()\n    {\n        return IceStorm.NoSuchLink;\n    }\n\n    _writeMemberImpl(ostr)\n    {\n        ostr.writeString(this.name);\n    }\n\n    _readMemberImpl(istr)\n    {\n        this.name = istr.readString();\n    }\n};\n\n/**\n * This exception indicates that an attempt was made to subscribe\n * a proxy for which a subscription already exists.\n *\n **/\nIceStorm.AlreadySubscribed = class extends Ice.UserException\n{\n    constructor(_cause = \"\")\n    {\n        super(_cause);\n    }\n\n    static get _parent()\n    {\n        return Ice.UserException;\n    }\n\n    static get _id()\n    {\n        return \"::IceStorm::AlreadySubscribed\";\n    }\n\n    _mostDerivedType()\n    {\n        return IceStorm.AlreadySubscribed;\n    }\n};\n\n/**\n * This exception indicates that an attempt was made to subscribe\n * a proxy that is null.\n *\n **/\nIceStorm.InvalidSubscriber = class extends Ice.UserException\n{\n    constructor(reason = \"\", _cause = \"\")\n    {\n        super(_cause);\n        this.reason = reason;\n    }\n\n    static get _parent()\n    {\n        return Ice.UserException;\n    }\n\n    static get _id()\n    {\n        return \"::IceStorm::InvalidSubscriber\";\n    }\n\n    _mostDerivedType()\n    {\n        return IceStorm.InvalidSubscriber;\n    }\n\n    _writeMemberImpl(ostr)\n    {\n        ostr.writeString(this.reason);\n    }\n\n    _readMemberImpl(istr)\n    {\n        this.reason = istr.readString();\n    }\n};\n\n/**\n * This exception indicates that a subscription failed due to an\n * invalid QoS.\n *\n **/\nIceStorm.BadQoS = class extends Ice.UserException\n{\n    constructor(reason = \"\", _cause = \"\")\n    {\n        super(_cause);\n        this.reason = reason;\n    }\n\n    static get _parent()\n    {\n        return Ice.UserException;\n    }\n\n    static get _id()\n    {\n        return \"::IceStorm::BadQoS\";\n    }\n\n    _mostDerivedType()\n    {\n        return IceStorm.BadQoS;\n    }\n\n    _writeMemberImpl(ostr)\n    {\n        ostr.writeString(this.reason);\n    }\n\n    _readMemberImpl(istr)\n    {\n        this.reason = istr.readString();\n    }\n};\n\nconst iceC_IceStorm_Topic_ids = [\n    \"::Ice::Object\",\n    \"::IceStorm::Topic\"\n];\n\n/**\n * Publishers publish information on a particular topic. A topic\n * logically represents a type.\n *\n * @see TopicManager\n *\n **/\nIceStorm.Topic = class extends Ice.Object\n{\n};\n\nIceStorm.TopicPrx = class extends Ice.ObjectPrx\n{\n};\n\nSlice.defineOperations(IceStorm.Topic, IceStorm.TopicPrx, iceC_IceStorm_Topic_ids, 1,\n{\n    \"getName\": [, 2, 1, , [7], , , , , ],\n    \"getPublisher\": [, 2, 1, , [9], , , , , ],\n    \"getNonReplicatedPublisher\": [, 2, 1, , [9], , , , , ],\n    \"subscribeAndGetPublisher\": [, , , , [9], [[\"IceStorm.QoSHelper\"], [9]], ,\n    [\n        IceStorm.AlreadySubscribed,\n        IceStorm.BadQoS,\n        IceStorm.InvalidSubscriber\n    ], , ],\n    \"unsubscribe\": [, 2, 2, , , [[9]], , , , ],\n    \"link\": [, , , , , [[\"IceStorm.TopicPrx\"], [3]], ,\n    [\n        IceStorm.LinkExists\n    ], , ],\n    \"unlink\": [, , , , , [[\"IceStorm.TopicPrx\"]], ,\n    [\n        IceStorm.NoSuchLink\n    ], , ],\n    \"getLinkInfoSeq\": [, 2, 1, , [\"IceStorm.LinkInfoSeqHelper\"], , , , , ],\n    \"getSubscribers\": [, , , , [\"Ice.IdentitySeqHelper\"], , , , , ],\n    \"destroy\": [, , , , , , , , , ]\n});\n\nSlice.defineDictionary(IceStorm, \"TopicDict\", \"TopicDictHelper\", \"Ice.StringHelper\", \"IceStorm.TopicPrx\", false, undefined, undefined);\n\n/**\n * This exception indicates that an attempt was made to create a topic\n * that already exists.\n *\n **/\nIceStorm.TopicExists = class extends Ice.UserException\n{\n    constructor(name = \"\", _cause = \"\")\n    {\n        super(_cause);\n        this.name = name;\n    }\n\n    static get _parent()\n    {\n        return Ice.UserException;\n    }\n\n    static get _id()\n    {\n        return \"::IceStorm::TopicExists\";\n    }\n\n    _mostDerivedType()\n    {\n        return IceStorm.TopicExists;\n    }\n\n    _writeMemberImpl(ostr)\n    {\n        ostr.writeString(this.name);\n    }\n\n    _readMemberImpl(istr)\n    {\n        this.name = istr.readString();\n    }\n};\n\n/**\n * This exception indicates that an attempt was made to retrieve a\n * topic that does not exist.\n *\n **/\nIceStorm.NoSuchTopic = class extends Ice.UserException\n{\n    constructor(name = \"\", _cause = \"\")\n    {\n        super(_cause);\n        this.name = name;\n    }\n\n    static get _parent()\n    {\n        return Ice.UserException;\n    }\n\n    static get _id()\n    {\n        return \"::IceStorm::NoSuchTopic\";\n    }\n\n    _mostDerivedType()\n    {\n        return IceStorm.NoSuchTopic;\n    }\n\n    _writeMemberImpl(ostr)\n    {\n        ostr.writeString(this.name);\n    }\n\n    _readMemberImpl(istr)\n    {\n        this.name = istr.readString();\n    }\n};\n\nconst iceC_IceStorm_TopicManager_ids = [\n    \"::Ice::Object\",\n    \"::IceStorm::TopicManager\"\n];\n\n/**\n * A topic manager manages topics, and subscribers to topics.\n *\n * @see Topic\n *\n **/\nIceStorm.TopicManager = class extends Ice.Object\n{\n};\n\nIceStorm.TopicManagerPrx = class extends Ice.ObjectPrx\n{\n};\n\nSlice.defineOperations(IceStorm.TopicManager, IceStorm.TopicManagerPrx, iceC_IceStorm_TopicManager_ids, 1,\n{\n    \"create\": [, , , , [\"IceStorm.TopicPrx\"], [[7]], ,\n    [\n        IceStorm.TopicExists\n    ], , ],\n    \"retrieve\": [, 2, 1, , [\"IceStorm.TopicPrx\"], [[7]], ,\n    [\n        IceStorm.NoSuchTopic\n    ], , ],\n    \"retrieveAll\": [, 2, 1, , [\"IceStorm.TopicDictHelper\"], , , , , ],\n    \"getSliceChecksums\": [, 2, 1, , [\"Ice.SliceChecksumDictHelper\"], , , , , ]\n});\n\nconst iceC_IceStorm_Finder_ids = [\n    \"::Ice::Object\",\n    \"::IceStorm::Finder\"\n];\n\n/**\n * This inferface is advertised by the IceStorm service through the\n * Ice object with the identity `IceStorm/Finder'. This allows clients\n * to retrieve the topic manager with just the endpoint information of\n * the IceStorm service.\n *\n **/\nIceStorm.Finder = class extends Ice.Object\n{\n};\n\nIceStorm.FinderPrx = class extends Ice.ObjectPrx\n{\n};\n\nSlice.defineOperations(IceStorm.Finder, IceStorm.FinderPrx, iceC_IceStorm_Finder_ids, 1,\n{\n    \"getTopicManager\": [, , , , [\"IceStorm.TopicManagerPrx\"], , , , , ]\n});\n/* slice2js browser-bundle-skip */\nexports.IceStorm = IceStorm;\n/* slice2js browser-bundle-skip-end */\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/IceStorm/IceStorm.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/IceStorm/Metrics.js":
/*!**************************************************!*\
  !*** ./node_modules/ice/src/IceStorm/Metrics.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n//\n// Ice version 3.7.10\n//\n// <auto-generated>\n//\n// Generated from file `Metrics.ice'\n//\n// Warning: do not edit this file.\n//\n// </auto-generated>\n//\n\n/* eslint-disable */\n/* jshint ignore: start */\n\n/* slice2js browser-bundle-skip */\nconst _ModuleRegistry = (__webpack_require__(/*! ../Ice/ModuleRegistry */ \"./node_modules/ice/src/Ice/ModuleRegistry.js\").Ice)._ModuleRegistry;\n__webpack_require__(/*! ../Ice/Object */ \"./node_modules/ice/src/Ice/Object.js\");\n__webpack_require__(/*! ../Ice/Value */ \"./node_modules/ice/src/Ice/Value.js\");\n__webpack_require__(/*! ../Ice/ObjectPrx */ \"./node_modules/ice/src/Ice/ObjectPrx.js\");\n__webpack_require__(/*! ../Ice/Long */ \"./node_modules/ice/src/Ice/Long.js\");\n__webpack_require__(/*! ../Ice/HashMap */ \"./node_modules/ice/src/Ice/HashMap.js\");\n__webpack_require__(/*! ../Ice/HashUtil */ \"./node_modules/ice/src/Ice/HashUtil.js\");\n__webpack_require__(/*! ../Ice/ArrayUtil */ \"./node_modules/ice/src/Ice/ArrayUtil.js\");\n__webpack_require__(/*! ../Ice/StreamHelpers */ \"./node_modules/ice/src/Ice/StreamHelpers.js\");\nconst Ice = _ModuleRegistry.module(\"Ice\");\n\nconst IceMX = (__webpack_require__(/*! ../Ice/Metrics */ \"./node_modules/ice/src/Ice/Metrics.js\").IceMX);\nconst Slice = Ice.Slice;\n/* slice2js browser-bundle-skip-end */\n\nconst iceC_IceMX_TopicMetrics_ids = [\n    \"::Ice::Object\",\n    \"::IceMX::Metrics\",\n    \"::IceMX::TopicMetrics\"\n];\n\n/**\n * Provides information on IceStorm topics.\n *\n **/\nIceMX.TopicMetrics = class extends IceMX.Metrics\n{\n    constructor(id, total, current, totalLifetime, failures, published = new Ice.Long(0, 0), forwarded = new Ice.Long(0, 0))\n    {\n        super(id, total, current, totalLifetime, failures);\n        this.published = published;\n        this.forwarded = forwarded;\n    }\n\n    _iceWriteMemberImpl(ostr)\n    {\n        ostr.writeLong(this.published);\n        ostr.writeLong(this.forwarded);\n    }\n\n    _iceReadMemberImpl(istr)\n    {\n        this.published = istr.readLong();\n        this.forwarded = istr.readLong();\n    }\n};\n\nSlice.defineValue(IceMX.TopicMetrics, iceC_IceMX_TopicMetrics_ids[2], false);\n\nconst iceC_IceMX_SubscriberMetrics_ids = [\n    \"::Ice::Object\",\n    \"::IceMX::Metrics\",\n    \"::IceMX::SubscriberMetrics\"\n];\n\n/**\n * Provides information on IceStorm subscribers.\n *\n **/\nIceMX.SubscriberMetrics = class extends IceMX.Metrics\n{\n    constructor(id, total, current, totalLifetime, failures, queued = 0, outstanding = 0, delivered = new Ice.Long(0, 0))\n    {\n        super(id, total, current, totalLifetime, failures);\n        this.queued = queued;\n        this.outstanding = outstanding;\n        this.delivered = delivered;\n    }\n\n    _iceWriteMemberImpl(ostr)\n    {\n        ostr.writeInt(this.queued);\n        ostr.writeInt(this.outstanding);\n        ostr.writeLong(this.delivered);\n    }\n\n    _iceReadMemberImpl(istr)\n    {\n        this.queued = istr.readInt();\n        this.outstanding = istr.readInt();\n        this.delivered = istr.readLong();\n    }\n};\n\nSlice.defineValue(IceMX.SubscriberMetrics, iceC_IceMX_SubscriberMetrics_ids[2], false);\n/* slice2js browser-bundle-skip */\nexports.IceMX = IceMX;\n/* slice2js browser-bundle-skip-end */\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/IceStorm/Metrics.js?\n}");

/***/ }),

/***/ "./node_modules/ice/src/index.js":
/*!***************************************!*\
  !*** ./node_modules/ice/src/index.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{//\n// Copyright (c) ZeroC, Inc. All rights reserved.\n//\n\nmodule.exports.Ice = __webpack_require__(/*! ./Ice/Ice */ \"./node_modules/ice/src/Ice/Ice.js\").Ice;\nmodule.exports.IceMX = __webpack_require__(/*! ./Ice/Ice */ \"./node_modules/ice/src/Ice/Ice.js\").IceMX;\nmodule.exports.IceSSL = __webpack_require__(/*! ./Ice/Ice */ \"./node_modules/ice/src/Ice/Ice.js\").IceSSL;\nmodule.exports.Glacier2 = __webpack_require__(/*! ./Glacier2/Glacier2 */ \"./node_modules/ice/src/Glacier2/Glacier2.js\").Glacier2;\nmodule.exports.IceGrid = __webpack_require__(/*! ./IceGrid/IceGrid */ \"./node_modules/ice/src/IceGrid/IceGrid.js\").IceGrid;\nmodule.exports.IceStorm = __webpack_require__(/*! ./IceStorm/IceStorm */ \"./node_modules/ice/src/IceStorm/IceStorm.js\").IceStorm;\n\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/ice/src/index.js?\n}");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {

"use strict";
eval("{\n\nvar stylesInDOM = [];\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n  for (var i = 0; i < stylesInDOM.length; i++) {\n    if (stylesInDOM[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n  return result;\n}\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var indexByIdentifier = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3],\n      supports: item[4],\n      layer: item[5]\n    };\n    if (indexByIdentifier !== -1) {\n      stylesInDOM[indexByIdentifier].references++;\n      stylesInDOM[indexByIdentifier].updater(obj);\n    } else {\n      var updater = addElementStyle(obj, options);\n      options.byIndex = i;\n      stylesInDOM.splice(i, 0, {\n        identifier: identifier,\n        updater: updater,\n        references: 1\n      });\n    }\n    identifiers.push(identifier);\n  }\n  return identifiers;\n}\nfunction addElementStyle(obj, options) {\n  var api = options.domAPI(options);\n  api.update(obj);\n  var updater = function updater(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {\n        return;\n      }\n      api.update(obj = newObj);\n    } else {\n      api.remove();\n    }\n  };\n  return updater;\n}\nmodule.exports = function (list, options) {\n  options = options || {};\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDOM[index].references--;\n    }\n    var newLastIdentifiers = modulesToDom(newList, options);\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n      var _index = getIndexByIdentifier(_identifier);\n      if (stylesInDOM[_index].references === 0) {\n        stylesInDOM[_index].updater();\n        stylesInDOM.splice(_index, 1);\n      }\n    }\n    lastIdentifiers = newLastIdentifiers;\n  };\n};\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js?\n}");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {

"use strict";
eval("{\n\nvar memo = {};\n\n/* istanbul ignore next  */\nfunction getTarget(target) {\n  if (typeof memo[target] === \"undefined\") {\n    var styleTarget = document.querySelector(target);\n\n    // Special case to return head of iframe instead of iframe itself\n    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n      try {\n        // This will throw an exception if access to iframe is blocked\n        // due to cross-origin restrictions\n        styleTarget = styleTarget.contentDocument.head;\n      } catch (e) {\n        // istanbul ignore next\n        styleTarget = null;\n      }\n    }\n    memo[target] = styleTarget;\n  }\n  return memo[target];\n}\n\n/* istanbul ignore next  */\nfunction insertBySelector(insert, style) {\n  var target = getTarget(insert);\n  if (!target) {\n    throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n  }\n  target.appendChild(style);\n}\nmodule.exports = insertBySelector;\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/style-loader/dist/runtime/insertBySelector.js?\n}");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";
eval("{\n\n/* istanbul ignore next  */\nfunction insertStyleElement(options) {\n  var element = document.createElement(\"style\");\n  options.setAttributes(element, options.attributes);\n  options.insert(element, options.options);\n  return element;\n}\nmodule.exports = insertStyleElement;\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/style-loader/dist/runtime/insertStyleElement.js?\n}");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("{\n\n/* istanbul ignore next  */\nfunction setAttributesWithoutAttributes(styleElement) {\n  var nonce =  true ? __webpack_require__.nc : 0;\n  if (nonce) {\n    styleElement.setAttribute(\"nonce\", nonce);\n  }\n}\nmodule.exports = setAttributesWithoutAttributes;\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js?\n}");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";
eval("{\n\n/* istanbul ignore next  */\nfunction apply(styleElement, options, obj) {\n  var css = \"\";\n  if (obj.supports) {\n    css += \"@supports (\".concat(obj.supports, \") {\");\n  }\n  if (obj.media) {\n    css += \"@media \".concat(obj.media, \" {\");\n  }\n  var needLayer = typeof obj.layer !== \"undefined\";\n  if (needLayer) {\n    css += \"@layer\".concat(obj.layer.length > 0 ? \" \".concat(obj.layer) : \"\", \" {\");\n  }\n  css += obj.css;\n  if (needLayer) {\n    css += \"}\";\n  }\n  if (obj.media) {\n    css += \"}\";\n  }\n  if (obj.supports) {\n    css += \"}\";\n  }\n  var sourceMap = obj.sourceMap;\n  if (sourceMap && typeof btoa !== \"undefined\") {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  }\n\n  // For old IE\n  /* istanbul ignore if  */\n  options.styleTagTransform(css, styleElement, options.options);\n}\nfunction removeStyleElement(styleElement) {\n  // istanbul ignore if\n  if (styleElement.parentNode === null) {\n    return false;\n  }\n  styleElement.parentNode.removeChild(styleElement);\n}\n\n/* istanbul ignore next  */\nfunction domAPI(options) {\n  if (typeof document === \"undefined\") {\n    return {\n      update: function update() {},\n      remove: function remove() {}\n    };\n  }\n  var styleElement = options.insertStyleElement(options);\n  return {\n    update: function update(obj) {\n      apply(styleElement, options, obj);\n    },\n    remove: function remove() {\n      removeStyleElement(styleElement);\n    }\n  };\n}\nmodule.exports = domAPI;\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/style-loader/dist/runtime/styleDomAPI.js?\n}");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {

"use strict";
eval("{\n\n/* istanbul ignore next  */\nfunction styleTagTransform(css, styleElement) {\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css;\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild);\n    }\n    styleElement.appendChild(document.createTextNode(css));\n  }\n}\nmodule.exports = styleTagTransform;\n\n//# sourceURL=webpack://compunet-chat-client/./node_modules/style-loader/dist/runtime/styleTagTransform.js?\n}");

/***/ }),

/***/ "./src/ChatStateManager.js":
/*!*********************************!*\
  !*** ./src/ChatStateManager.js ***!
  \*********************************/
/***/ ((module) => {

eval("{class ChatStateManager {\r\n    constructor() {\r\n        this.currentUserId = 'user1'; // Usuario fijo para esta iteracin\r\n        this.currentUserName = 'Alice';\r\n        this.chats = []; // Array de ChatSummary (directos + grupos)\r\n        this.activeChat = null; // {id, name, isGroup}\r\n        this.activeMessages = []; // Array de Messages del chat activo\r\n        this.allUsers = []; // Todos los usuarios disponibles\r\n    }\r\n\r\n    // === Gestin de usuario actual ===\r\n\r\n    setCurrentUser(userId, userName) {\r\n        this.currentUserId = userId;\r\n        this.currentUserName = userName;\r\n    }\r\n\r\n    getCurrentUserId() {\r\n        return this.currentUserId;\r\n    }\r\n\r\n    getCurrentUserName() {\r\n        return this.currentUserName;\r\n    }\r\n\r\n    // === Gestin de chats ===\r\n\r\n    setChats(chats) {\r\n        // Combinar chats directos y de grupo, ordenados por timestamp\r\n        this.chats = chats.sort((a, b) => \r\n            b.lastMessageTimestamp - a.lastMessageTimestamp\r\n        );\r\n    }\r\n\r\n    getChats() {\r\n        return this.chats;\r\n    }\r\n\r\n    addChat(chatSummary) {\r\n        // Verificar si el chat ya existe\r\n        const existingIndex = this.chats.findIndex(c => c.chatId === chatSummary.chatId);\r\n        \r\n        if (existingIndex >= 0) {\r\n            // Actualizar el chat existente\r\n            this.chats[existingIndex] = chatSummary;\r\n        } else {\r\n            // Agregar nuevo chat\r\n            this.chats.push(chatSummary);\r\n        }\r\n        \r\n        // Reordenar por timestamp\r\n        this.chats.sort((a, b) => \r\n            b.lastMessageTimestamp - a.lastMessageTimestamp\r\n        );\r\n    }\r\n\r\n    // === Gestin de chat activo ===\r\n\r\n    setActiveChat(chatId, chatName, isGroup) {\r\n        this.activeChat = {\r\n            id: chatId,\r\n            name: chatName,\r\n            isGroup: isGroup\r\n        };\r\n        this.activeMessages = []; // Limpiar mensajes al cambiar de chat\r\n    }\r\n\r\n    getActiveChat() {\r\n        return this.activeChat;\r\n    }\r\n\r\n    clearActiveChat() {\r\n        this.activeChat = null;\r\n        this.activeMessages = [];\r\n    }\r\n\r\n    // === Gestin de mensajes ===\r\n\r\n    setActiveMessages(messages) {\r\n        this.activeMessages = messages;\r\n    }\r\n\r\n    getActiveMessages() {\r\n        return this.activeMessages;\r\n    }\r\n\r\n    addMessage(message) {\r\n        this.activeMessages.push(message);\r\n        \r\n        // Actualizar el resumen del chat en la lista\r\n        if (this.activeChat) {\r\n            const chatIndex = this.chats.findIndex(c => c.chatId === this.activeChat.id);\r\n            if (chatIndex >= 0) {\r\n                this.chats[chatIndex].lastMessageContent = message.content;\r\n                this.chats[chatIndex].lastMessageTimestamp = message.timestamp;\r\n                \r\n                // Reordenar\r\n                this.chats.sort((a, b) => \r\n                    b.lastMessageTimestamp - a.lastMessageTimestamp\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    // === Gestin de usuarios ===\r\n\r\n    setAllUsers(users) {\r\n        this.allUsers = users;\r\n    }\r\n\r\n    getAllUsers() {\r\n        return this.allUsers;\r\n    }\r\n\r\n    getUsersExceptCurrent() {\r\n        return this.allUsers.filter(u => u.id !== this.currentUserId);\r\n    }\r\n\r\n    // === Utilidades ===\r\n\r\n    isChatActive(chatId) {\r\n        return this.activeChat && this.activeChat.id === chatId;\r\n    }\r\n\r\n    formatTimestamp(timestamp) {\r\n        const date = new Date(timestamp);\r\n        const now = new Date();\r\n        \r\n        // Si es hoy, mostrar solo hora\r\n        if (date.toDateString() === now.toDateString()) {\r\n            return date.toLocaleTimeString('es-ES', { \r\n                hour: '2-digit', \r\n                minute: '2-digit' \r\n            });\r\n        }\r\n        \r\n        // Si es de esta semana, mostrar da de la semana\r\n        const daysDiff = Math.floor((now - date) / (1000 * 60 * 60 * 24));\r\n        if (daysDiff < 7) {\r\n            return date.toLocaleDateString('es-ES', { weekday: 'short' });\r\n        }\r\n        \r\n        // De lo contrario, mostrar fecha completa\r\n        return date.toLocaleDateString('es-ES', { \r\n            day: '2-digit', \r\n            month: '2-digit' \r\n        });\r\n    }\r\n}\r\n\r\n// Exportar instancia singleton\r\nconst chatState = new ChatStateManager();\r\nmodule.exports = chatState;\n\n//# sourceURL=webpack://compunet-chat-client/./src/ChatStateManager.js?\n}");

/***/ }),

/***/ "./src/ChatUIController.js":
/*!*********************************!*\
  !*** ./src/ChatUIController.js ***!
  \*********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{const chatState = __webpack_require__(/*! ./ChatStateManager */ \"./src/ChatStateManager.js\");\r\nconst messageSender = __webpack_require__(/*! ./MessageSender */ \"./src/MessageSender.js\");\r\nconst messageReceiver = __webpack_require__(/*! ./MessageReceiver */ \"./src/MessageReceiver.js\");\r\nconst iceManager = __webpack_require__(/*! ./IceConnectionManager */ \"./src/IceConnectionManager.js\");\r\n\r\nclass ChatUIController {\r\n    constructor() {\r\n        this.elements = {};\r\n    }\r\n\r\n    initialize() {\r\n        // Obtener referencias a elementos del DOM\r\n        this.elements = {\r\n            chatList: document.getElementById('chat-list'),\r\n            messagesContainer: document.getElementById('messages-container'),\r\n            messageInput: document.getElementById('message-input'),\r\n            btnSendMessage: document.getElementById('btn-send-message'),\r\n            chatName: document.getElementById('chat-name'),\r\n            chatType: document.getElementById('chat-type'),\r\n            currentUserName: document.getElementById('current-user-name'),\r\n            btnNewGroup: document.getElementById('btn-new-group'),\r\n            btnRefreshChats: document.getElementById('btn-refresh-chats'),\r\n            modalNewGroup: document.getElementById('modal-new-group'),\r\n            modalClose: document.getElementById('modal-close'),\r\n            btnCancelGroup: document.getElementById('btn-cancel-group'),\r\n            btnCreateGroup: document.getElementById('btn-create-group'),\r\n            groupNameInput: document.getElementById('group-name'),\r\n            usersList: document.getElementById('users-list'),\r\n            loading: document.getElementById('loading')\r\n        };\r\n\r\n        this.attachEventListeners();\r\n        this.updateUserInfo();\r\n    }\r\n\r\n    attachEventListeners() {\r\n        // Enviar mensaje\r\n        this.elements.btnSendMessage.addEventListener('click', () => this.handleSendMessage());\r\n        this.elements.messageInput.addEventListener('keypress', (e) => {\r\n            if (e.key === 'Enter') {\r\n                this.handleSendMessage();\r\n            }\r\n        });\r\n\r\n        // Actualizar chats\r\n        this.elements.btnRefreshChats.addEventListener('click', () => this.handleRefreshChats());\r\n\r\n        // Modal de nuevo grupo\r\n        this.elements.btnNewGroup.addEventListener('click', () => this.showNewGroupModal());\r\n        this.elements.modalClose.addEventListener('click', () => this.hideNewGroupModal());\r\n        this.elements.btnCancelGroup.addEventListener('click', () => this.hideNewGroupModal());\r\n        this.elements.btnCreateGroup.addEventListener('click', () => this.handleCreateGroup());\r\n\r\n        // Cerrar modal al hacer click fuera\r\n        this.elements.modalNewGroup.addEventListener('click', (e) => {\r\n            if (e.target === this.elements.modalNewGroup) {\r\n                this.hideNewGroupModal();\r\n            }\r\n        });\r\n    }\r\n\r\n    updateUserInfo() {\r\n        this.elements.currentUserName.textContent = chatState.getCurrentUserName();\r\n    }\r\n\r\n    // === Renderizado de chats ===\r\n\r\n    renderChatList() {\r\n        const chats = chatState.getChats();\r\n        \r\n        if (chats.length === 0) {\r\n            this.elements.chatList.innerHTML = `\r\n                <div style=\"padding: 20px; text-align: center; color: #667781;\">\r\n                    No tienes chats an.<br>\r\n                    Crea un grupo para empezar.\r\n                </div>\r\n            `;\r\n            return;\r\n        }\r\n\r\n        this.elements.chatList.innerHTML = '';\r\n\r\n        chats.forEach(chat => {\r\n            const chatItem = this.createChatItemElement(chat);\r\n            this.elements.chatList.appendChild(chatItem);\r\n        });\r\n    }\r\n\r\n    createChatItemElement(chat) {\r\n        const div = document.createElement('div');\r\n        div.className = 'chat-item';\r\n        \r\n        if (chatState.isChatActive(chat.chatId)) {\r\n            div.classList.add('active');\r\n        }\r\n\r\n        const time = chatState.formatTimestamp(chat.lastMessageTimestamp);\r\n        const badge = chat.isGroup ? '<span class=\"chat-item-badge\">Grupo</span>' : '';\r\n\r\n        div.innerHTML = `\r\n            <div class=\"chat-item-header\">\r\n                <span class=\"chat-item-name\">${chat.chatName}${badge}</span>\r\n                <span class=\"chat-item-time\">${time}</span>\r\n            </div>\r\n            <div class=\"chat-item-preview\">${chat.lastMessageContent}</div>\r\n        `;\r\n\r\n        div.addEventListener('click', () => this.handleChatClick(chat));\r\n\r\n        return div;\r\n    }\r\n\r\n    async handleChatClick(chat) {\r\n        try {\r\n            this.showLoading('Cargando mensajes...');\r\n            \r\n            // Establecer chat activo\r\n            chatState.setActiveChat(chat.chatId, chat.chatName, chat.isGroup);\r\n            \r\n            // Cargar mensajes\r\n            await messageReceiver.loadChatMessages(chat.chatId, chat.isGroup);\r\n            \r\n            // Actualizar UI\r\n            this.updateChatHeader();\r\n            this.renderMessages();\r\n            this.enableMessageInput();\r\n            this.renderChatList(); // Re-renderizar para actualizar seleccin\r\n            \r\n            this.hideLoading();\r\n        } catch (error) {\r\n            console.error('Error al seleccionar chat:', error);\r\n            this.hideLoading();\r\n            alert('Error al cargar el chat');\r\n        }\r\n    }\r\n\r\n    // === Renderizado de mensajes ===\r\n\r\n    renderMessages() {\r\n        const messages = chatState.getActiveMessages();\r\n        const activeChat = chatState.getActiveChat();\r\n        \r\n        if (!activeChat) {\r\n            this.showEmptyState();\r\n            return;\r\n        }\r\n\r\n        if (messages.length === 0) {\r\n            this.elements.messagesContainer.innerHTML = `\r\n                <div class=\"empty-state\">\r\n                    <p>No hay mensajes en este chat</p>\r\n                </div>\r\n            `;\r\n            return;\r\n        }\r\n\r\n        this.elements.messagesContainer.innerHTML = '';\r\n\r\n        messages.forEach(message => {\r\n            const messageElement = this.createMessageElement(message);\r\n            this.elements.messagesContainer.appendChild(messageElement);\r\n        });\r\n\r\n        // Scroll hacia abajo\r\n        this.scrollToBottom();\r\n    }\r\n\r\n    createMessageElement(message) {\r\n        const div = document.createElement('div');\r\n        const isSent = message.senderId === chatState.getCurrentUserId();\r\n        div.className = `message ${isSent ? 'sent' : 'received'}`;\r\n\r\n        const time = chatState.formatTimestamp(message.timestamp);\r\n        const showSender = !isSent && chatState.getActiveChat().isGroup;\r\n\r\n        div.innerHTML = `\r\n            <div class=\"message-bubble\">\r\n                ${showSender ? `<div class=\"message-sender\">${message.senderName}</div>` : ''}\r\n                <div class=\"message-content\">${this.escapeHtml(message.content)}</div>\r\n                <div class=\"message-time\">${time}</div>\r\n            </div>\r\n        `;\r\n\r\n        return div;\r\n    }\r\n\r\n    escapeHtml(text) {\r\n        const div = document.createElement('div');\r\n        div.textContent = text;\r\n        return div.innerHTML;\r\n    }\r\n\r\n    scrollToBottom() {\r\n        this.elements.messagesContainer.scrollTop = this.elements.messagesContainer.scrollHeight;\r\n    }\r\n\r\n    showEmptyState() {\r\n        this.elements.messagesContainer.innerHTML = `\r\n            <div class=\"empty-state\">\r\n                <p>Selecciona un chat para ver los mensajes</p>\r\n            </div>\r\n        `;\r\n    }\r\n\r\n    // === Envo de mensajes ===\r\n\r\n    async handleSendMessage() {\r\n        const content = this.elements.messageInput.value.trim();\r\n        \r\n        if (!content) return;\r\n\r\n        try {\r\n            // Enviar mensaje\r\n            await messageSender.sendMessage(content);\r\n            \r\n            // Limpiar input\r\n            this.elements.messageInput.value = '';\r\n            \r\n            // Recargar mensajes del chat activo\r\n            await messageReceiver.refreshActiveChat();\r\n            \r\n            // Re-renderizar mensajes\r\n            this.renderMessages();\r\n            \r\n            // Actualizar lista de chats\r\n            await this.handleRefreshChats();\r\n            \r\n        } catch (error) {\r\n            console.error('Error al enviar mensaje:', error);\r\n            alert('Error al enviar el mensaje');\r\n        }\r\n    }\r\n\r\n    // === Actualizacin de chats ===\r\n\r\n    async handleRefreshChats() {\r\n        try {\r\n            await messageReceiver.refreshChats();\r\n            this.renderChatList();\r\n        } catch (error) {\r\n            console.error('Error al actualizar chats:', error);\r\n        }\r\n    }\r\n\r\n    // === Modal de nuevo grupo ===\r\n\r\n    async showNewGroupModal() {\r\n        try {\r\n            // Cargar usuarios disponibles\r\n            await messageReceiver.loadAllUsers();\r\n            const users = chatState.getUsersExceptCurrent();\r\n            \r\n            // Renderizar lista de usuarios\r\n            this.elements.usersList.innerHTML = '';\r\n            users.forEach(user => {\r\n                const label = document.createElement('label');\r\n                label.className = 'user-checkbox';\r\n                label.innerHTML = `\r\n                    <input type=\"checkbox\" value=\"${user.id}\">\r\n                    <span>${user.name} (${user.id})</span>\r\n                `;\r\n                this.elements.usersList.appendChild(label);\r\n            });\r\n            \r\n            // Limpiar campo de nombre\r\n            this.elements.groupNameInput.value = '';\r\n            \r\n            // Mostrar modal\r\n            this.elements.modalNewGroup.classList.add('show');\r\n        } catch (error) {\r\n            console.error('Error al abrir modal de grupo:', error);\r\n            alert('Error al cargar usuarios');\r\n        }\r\n    }\r\n\r\n    hideNewGroupModal() {\r\n        this.elements.modalNewGroup.classList.remove('show');\r\n    }\r\n\r\n    async handleCreateGroup() {\r\n        const groupName = this.elements.groupNameInput.value.trim();\r\n        \r\n        if (!groupName) {\r\n            alert('Debes ingresar un nombre para el grupo');\r\n            return;\r\n        }\r\n\r\n        // Obtener miembros seleccionados\r\n        const checkboxes = this.elements.usersList.querySelectorAll('input[type=\"checkbox\"]:checked');\r\n        const memberIds = Array.from(checkboxes).map(cb => cb.value);\r\n\r\n        if (memberIds.length === 0) {\r\n            alert('Debes seleccionar al menos un miembro');\r\n            return;\r\n        }\r\n\r\n        try {\r\n            this.showLoading('Creando grupo...');\r\n            \r\n            const ownerId = chatState.getCurrentUserId();\r\n            await iceManager.createGroup(ownerId, groupName, memberIds);\r\n            \r\n            this.hideNewGroupModal();\r\n            \r\n            // Actualizar lista de chats\r\n            await this.handleRefreshChats();\r\n            \r\n            this.hideLoading();\r\n            \r\n            alert('Grupo creado exitosamente');\r\n        } catch (error) {\r\n            console.error('Error al crear grupo:', error);\r\n            this.hideLoading();\r\n            alert('Error al crear el grupo');\r\n        }\r\n    }\r\n\r\n    // === UI Helpers ===\r\n\r\n    updateChatHeader() {\r\n        const activeChat = chatState.getActiveChat();\r\n        \r\n        if (!activeChat) {\r\n            this.elements.chatName.textContent = 'Selecciona un chat';\r\n            this.elements.chatType.textContent = '';\r\n            return;\r\n        }\r\n\r\n        this.elements.chatName.textContent = activeChat.name;\r\n        this.elements.chatType.textContent = activeChat.isGroup ? 'Grupo' : 'Directo';\r\n    }\r\n\r\n    enableMessageInput() {\r\n        this.elements.messageInput.disabled = false;\r\n        this.elements.btnSendMessage.disabled = false;\r\n        this.elements.messageInput.focus();\r\n    }\r\n\r\n    disableMessageInput() {\r\n        this.elements.messageInput.disabled = true;\r\n        this.elements.btnSendMessage.disabled = true;\r\n    }\r\n\r\n    showLoading(message = 'Cargando...') {\r\n        this.elements.loading.querySelector('p').textContent = message;\r\n        this.elements.loading.classList.add('show');\r\n    }\r\n\r\n    hideLoading() {\r\n        this.elements.loading.classList.remove('show');\r\n    }\r\n}\r\n\r\n// Exportar instancia singleton\r\nconst uiController = new ChatUIController();\r\nmodule.exports = uiController;\n\n//# sourceURL=webpack://compunet-chat-client/./src/ChatUIController.js?\n}");

/***/ }),

/***/ "./src/IceConnectionManager.js":
/*!*************************************!*\
  !*** ./src/IceConnectionManager.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{const {compunet} = __webpack_require__(/*! ./generated/chat.js */ \"./src/generated/chat.js\");\r\nconst Ice = (__webpack_require__(/*! ice */ \"./node_modules/ice/src/index.js\").Ice);\r\n\r\n// Importar las definiciones Ice manuales (compatibles con Webpack)\r\n\r\n\r\nclass IceConnectionManager {\r\n    constructor() {\r\n        this.communicator = null;\r\n        this.chatServicePrx = null;\r\n        this.groupServicePrx = null;\r\n        this.isConnected = false;\r\n    }\r\n\r\n    async initialize() {\r\n        try {\r\n            console.log('Inicializando conexin Ice...');\r\n            \r\n            // Inicializar el comunicador Ice\r\n            this.communicator = Ice.initialize();\r\n            \r\n            // Crear proxies para los servicios\r\n            const chatBase = this.communicator.stringToProxy(\"chat:ws -h localhost -p 10000\");\r\n            this.chatServicePrx = await compunet.ChatServicePrx.checkedCast(chatBase);\r\n            \r\n            const groupBase = this.communicator.stringToProxy(\"group:ws -h localhost -p 10000\");\r\n            this.groupServicePrx = await compunet.GroupServicePrx.checkedCast(groupBase);\r\n            \r\n            if (!this.chatServicePrx || !this.groupServicePrx) {\r\n                throw new Error(\"No se pudieron crear los proxies de los servicios\");\r\n            }\r\n            \r\n            this.isConnected = true;\r\n            console.log('Conexin Ice establecida correctamente');\r\n            \r\n            return true;\r\n        } catch (error) {\r\n            console.error('Error al inicializar Ice:', error);\r\n            this.isConnected = false;\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    async shutdown() {\r\n        if (this.communicator) {\r\n            try {\r\n                await this.communicator.destroy();\r\n                this.isConnected = false;\r\n                console.log('Conexin Ice cerrada');\r\n            } catch (error) {\r\n                console.error('Error al cerrar la conexin Ice:', error);\r\n            }\r\n        }\r\n    }\r\n\r\n    // === Mtodos de ChatService ===\r\n\r\n    async registerUser(userId, userName) {\r\n        if (!this.isConnected) throw new Error('No hay conexin con el servidor');\r\n        try {\r\n            await this.chatServicePrx.registerUser(userId, userName);\r\n            console.log(`Usuario registrado: ${userId}`);\r\n        } catch (error) {\r\n            console.error('Error al registrar usuario:', error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    async getUser(userId) {\r\n        if (!this.isConnected) throw new Error('No hay conexin con el servidor');\r\n        try {\r\n            return await this.chatServicePrx.getUser(userId);\r\n        } catch (error) {\r\n            console.error('Error al obtener usuario:', error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    async getAllUsers() {\r\n        if (!this.isConnected) throw new Error('No hay conexin con el servidor');\r\n        try {\r\n            return await this.chatServicePrx.getAllUsers();\r\n        } catch (error) {\r\n            console.error('Error al obtener usuarios:', error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    async sendDirectMessage(fromUserId, toUserId, content) {\r\n        if (!this.isConnected) throw new Error('No hay conexin con el servidor');\r\n        try {\r\n            await this.chatServicePrx.sendDirectMessage(fromUserId, toUserId, content);\r\n            console.log(`Mensaje enviado de ${fromUserId} a ${toUserId}`);\r\n        } catch (error) {\r\n            console.error('Error al enviar mensaje directo:', error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    async getDirectChatMessages(userId, otherUserId) {\r\n        if (!this.isConnected) throw new Error('No hay conexin con el servidor');\r\n        try {\r\n            return await this.chatServicePrx.getDirectChatMessages(userId, otherUserId);\r\n        } catch (error) {\r\n            console.error('Error al obtener mensajes directos:', error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    async getUserDirectChats(userId) {\r\n        if (!this.isConnected) throw new Error('No hay conexin con el servidor');\r\n        try {\r\n            return await this.chatServicePrx.getUserDirectChats(userId);\r\n        } catch (error) {\r\n            console.error('Error al obtener chats directos:', error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    // === Mtodos de GroupService ===\r\n\r\n    async createGroup(ownerId, groupName, memberIds) {\r\n        if (!this.isConnected) throw new Error('No hay conexin con el servidor');\r\n        try {\r\n            const groupId = await this.groupServicePrx.createGroup(ownerId, groupName, memberIds);\r\n            console.log(`Grupo creado: ${groupId}`);\r\n            return groupId;\r\n        } catch (error) {\r\n            console.error('Error al crear grupo:', error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    async addMembersToGroup(groupId, memberIds) {\r\n        if (!this.isConnected) throw new Error('No hay conexin con el servidor');\r\n        try {\r\n            await this.groupServicePrx.addMembersToGroup(groupId, memberIds);\r\n            console.log(`Miembros agregados al grupo ${groupId}`);\r\n        } catch (error) {\r\n            console.error('Error al agregar miembros al grupo:', error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    async getGroupMembers(groupId) {\r\n        if (!this.isConnected) throw new Error('No hay conexin con el servidor');\r\n        try {\r\n            return await this.groupServicePrx.getGroupMembers(groupId);\r\n        } catch (error) {\r\n            console.error('Error al obtener miembros del grupo:', error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    async sendGroupMessage(fromUserId, groupId, content) {\r\n        if (!this.isConnected) throw new Error('No hay conexin con el servidor');\r\n        try {\r\n            await this.groupServicePrx.sendGroupMessage(fromUserId, groupId, content);\r\n            console.log(`Mensaje enviado al grupo ${groupId}`);\r\n        } catch (error) {\r\n            console.error('Error al enviar mensaje al grupo:', error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    async getGroupChatMessages(groupId) {\r\n        if (!this.isConnected) throw new Error('No hay conexin con el servidor');\r\n        try {\r\n            return await this.groupServicePrx.getGroupChatMessages(groupId);\r\n        } catch (error) {\r\n            console.error('Error al obtener mensajes del grupo:', error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    async getUserGroupChats(userId) {\r\n        if (!this.isConnected) throw new Error('No hay conexin con el servidor');\r\n        try {\r\n            return await this.groupServicePrx.getUserGroupChats(userId);\r\n        } catch (error) {\r\n            console.error('Error al obtener grupos del usuario:', error);\r\n            throw error;\r\n        }\r\n    }\r\n}\r\n\r\n// Exportar una instancia singleton\r\nconst iceManager = new IceConnectionManager();\r\nmodule.exports = iceManager;\n\n//# sourceURL=webpack://compunet-chat-client/./src/IceConnectionManager.js?\n}");

/***/ }),

/***/ "./src/MessageReceiver.js":
/*!********************************!*\
  !*** ./src/MessageReceiver.js ***!
  \********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{const iceManager = __webpack_require__(/*! ./IceConnectionManager */ \"./src/IceConnectionManager.js\");\r\nconst chatState = __webpack_require__(/*! ./ChatStateManager */ \"./src/ChatStateManager.js\");\r\n\r\nclass MessageReceiver {\r\n    async loadChatMessages(chatId, isGroup) {\r\n        const userId = chatState.getCurrentUserId();\r\n\r\n        try {\r\n            let messages;\r\n\r\n            if (isGroup) {\r\n                // Obtener mensajes del grupo\r\n                messages = await iceManager.getGroupChatMessages(chatId);\r\n            } else {\r\n                // Obtener mensajes del chat directo\r\n                messages = await iceManager.getDirectChatMessages(userId, chatId);\r\n            }\r\n\r\n            chatState.setActiveMessages(messages);\r\n            console.log(`Mensajes cargados: ${messages.length}`);\r\n            \r\n            return messages;\r\n        } catch (error) {\r\n            console.error('Error al cargar mensajes:', error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    async refreshChats() {\r\n        const userId = chatState.getCurrentUserId();\r\n\r\n        try {\r\n            // Obtener chats directos y de grupo en paralelo\r\n            const [directChats, groupChats] = await Promise.all([\r\n                iceManager.getUserDirectChats(userId),\r\n                iceManager.getUserGroupChats(userId)\r\n            ]);\r\n\r\n            // Combinar ambos tipos de chats\r\n            const allChats = [...directChats, ...groupChats];\r\n            \r\n            chatState.setChats(allChats);\r\n            console.log(`Chats actualizados: ${allChats.length} total`);\r\n            \r\n            return allChats;\r\n        } catch (error) {\r\n            console.error('Error al actualizar chats:', error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    async loadAllUsers() {\r\n        try {\r\n            const users = await iceManager.getAllUsers();\r\n            chatState.setAllUsers(users);\r\n            console.log(`Usuarios cargados: ${users.length}`);\r\n            return users;\r\n        } catch (error) {\r\n            console.error('Error al cargar usuarios:', error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    async refreshActiveChat() {\r\n        const activeChat = chatState.getActiveChat();\r\n        \r\n        if (!activeChat) {\r\n            console.log('No hay chat activo para actualizar');\r\n            return null;\r\n        }\r\n\r\n        try {\r\n            await this.loadChatMessages(activeChat.id, activeChat.isGroup);\r\n            return chatState.getActiveMessages();\r\n        } catch (error) {\r\n            console.error('Error al actualizar el chat activo:', error);\r\n            throw error;\r\n        }\r\n    }\r\n}\r\n\r\n// Exportar instancia singleton\r\nconst messageReceiver = new MessageReceiver();\r\nmodule.exports = messageReceiver;\n\n//# sourceURL=webpack://compunet-chat-client/./src/MessageReceiver.js?\n}");

/***/ }),

/***/ "./src/MessageSender.js":
/*!******************************!*\
  !*** ./src/MessageSender.js ***!
  \******************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{const iceManager = __webpack_require__(/*! ./IceConnectionManager */ \"./src/IceConnectionManager.js\");\r\nconst chatState = __webpack_require__(/*! ./ChatStateManager */ \"./src/ChatStateManager.js\");\r\n\r\nclass MessageSender {\r\n    async sendMessage(content) {\r\n        const activeChat = chatState.getActiveChat();\r\n        \r\n        if (!activeChat) {\r\n            throw new Error('No hay un chat activo');\r\n        }\r\n\r\n        if (!content || content.trim() === '') {\r\n            throw new Error('El mensaje no puede estar vaco');\r\n        }\r\n\r\n        const userId = chatState.getCurrentUserId();\r\n\r\n        try {\r\n            if (activeChat.isGroup) {\r\n                // Enviar mensaje a grupo\r\n                await iceManager.sendGroupMessage(userId, activeChat.id, content.trim());\r\n            } else {\r\n                // Enviar mensaje directo\r\n                await iceManager.sendDirectMessage(userId, activeChat.id, content.trim());\r\n            }\r\n\r\n            console.log(`Mensaje enviado exitosamente a ${activeChat.name}`);\r\n            return true;\r\n        } catch (error) {\r\n            console.error('Error al enviar mensaje:', error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    async sendDirectMessage(toUserId, content) {\r\n        if (!content || content.trim() === '') {\r\n            throw new Error('El mensaje no puede estar vaco');\r\n        }\r\n\r\n        const fromUserId = chatState.getCurrentUserId();\r\n\r\n        try {\r\n            await iceManager.sendDirectMessage(fromUserId, toUserId, content.trim());\r\n            console.log(`Mensaje directo enviado a ${toUserId}`);\r\n            return true;\r\n        } catch (error) {\r\n            console.error('Error al enviar mensaje directo:', error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    async sendGroupMessage(groupId, content) {\r\n        if (!content || content.trim() === '') {\r\n            throw new Error('El mensaje no puede estar vaco');\r\n        }\r\n\r\n        const fromUserId = chatState.getCurrentUserId();\r\n\r\n        try {\r\n            await iceManager.sendGroupMessage(fromUserId, groupId, content.trim());\r\n            console.log(`Mensaje enviado al grupo ${groupId}`);\r\n            return true;\r\n        } catch (error) {\r\n            console.error('Error al enviar mensaje al grupo:', error);\r\n            throw error;\r\n        }\r\n    }\r\n}\r\n\r\n// Exportar instancia singleton\r\nconst messageSender = new MessageSender();\r\nmodule.exports = messageSender;\n\n//# sourceURL=webpack://compunet-chat-client/./src/MessageSender.js?\n}");

/***/ }),

/***/ "./src/generated sync recursive":
/*!*****************************!*\
  !*** ./src/generated/ sync ***!
  \*****************************/
/***/ ((module) => {

eval("{function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = () => ([]);\nwebpackEmptyContext.resolve = webpackEmptyContext;\nwebpackEmptyContext.id = \"./src/generated sync recursive\";\nmodule.exports = webpackEmptyContext;\n\n//# sourceURL=webpack://compunet-chat-client/./src/generated/_sync?\n}");

/***/ }),

/***/ "./src/generated/chat.js":
/*!*******************************!*\
  !*** ./src/generated/chat.js ***!
  \*******************************/
/***/ ((module, exports, __webpack_require__) => {

eval("{/* module decorator */ module = __webpack_require__.nmd(module);\n//\r\n// Copyright (c) ZeroC, Inc. All rights reserved.\r\n//\r\n//\r\n// Ice version 3.7.10\r\n//\r\n// <auto-generated>\r\n//\r\n// Generated from file `chat.ice'\r\n//\r\n// Warning: do not edit this file.\r\n//\r\n// </auto-generated>\r\n//\r\n\r\n/* eslint-disable */\r\n/* jshint ignore: start */\r\n\r\n(function(module, require, exports)\r\n{\r\n    const Ice = require(\"ice\").Ice;\r\n    const _ModuleRegistry = Ice._ModuleRegistry;\r\n    const Slice = Ice.Slice;\r\n\r\n    let compunet = _ModuleRegistry.module(\"compunet\");\r\n\r\n    compunet.User = class\r\n    {\r\n        constructor(id = \"\", name = \"\")\r\n        {\r\n            this.id = id;\r\n            this.name = name;\r\n        }\r\n\r\n        _write(ostr)\r\n        {\r\n            ostr.writeString(this.id);\r\n            ostr.writeString(this.name);\r\n        }\r\n\r\n        _read(istr)\r\n        {\r\n            this.id = istr.readString();\r\n            this.name = istr.readString();\r\n        }\r\n\r\n        static get minWireSize()\r\n        {\r\n            return  2;\r\n        }\r\n    };\r\n\r\n    Slice.defineStruct(compunet.User, true, true);\r\n\r\n    compunet.Message = class\r\n    {\r\n        constructor(id = \"\", senderId = \"\", senderName = \"\", content = \"\", timestamp = new Ice.Long(0, 0), chatId = \"\", isGroupMessage = false)\r\n        {\r\n            this.id = id;\r\n            this.senderId = senderId;\r\n            this.senderName = senderName;\r\n            this.content = content;\r\n            this.timestamp = timestamp;\r\n            this.chatId = chatId;\r\n            this.isGroupMessage = isGroupMessage;\r\n        }\r\n\r\n        _write(ostr)\r\n        {\r\n            ostr.writeString(this.id);\r\n            ostr.writeString(this.senderId);\r\n            ostr.writeString(this.senderName);\r\n            ostr.writeString(this.content);\r\n            ostr.writeLong(this.timestamp);\r\n            ostr.writeString(this.chatId);\r\n            ostr.writeBool(this.isGroupMessage);\r\n        }\r\n\r\n        _read(istr)\r\n        {\r\n            this.id = istr.readString();\r\n            this.senderId = istr.readString();\r\n            this.senderName = istr.readString();\r\n            this.content = istr.readString();\r\n            this.timestamp = istr.readLong();\r\n            this.chatId = istr.readString();\r\n            this.isGroupMessage = istr.readBool();\r\n        }\r\n\r\n        static get minWireSize()\r\n        {\r\n            return  14;\r\n        }\r\n    };\r\n\r\n    Slice.defineStruct(compunet.Message, true, true);\r\n\r\n    compunet.ChatSummary = class\r\n    {\r\n        constructor(chatId = \"\", chatName = \"\", lastMessageContent = \"\", lastMessageTimestamp = new Ice.Long(0, 0), isGroup = false)\r\n        {\r\n            this.chatId = chatId;\r\n            this.chatName = chatName;\r\n            this.lastMessageContent = lastMessageContent;\r\n            this.lastMessageTimestamp = lastMessageTimestamp;\r\n            this.isGroup = isGroup;\r\n        }\r\n\r\n        _write(ostr)\r\n        {\r\n            ostr.writeString(this.chatId);\r\n            ostr.writeString(this.chatName);\r\n            ostr.writeString(this.lastMessageContent);\r\n            ostr.writeLong(this.lastMessageTimestamp);\r\n            ostr.writeBool(this.isGroup);\r\n        }\r\n\r\n        _read(istr)\r\n        {\r\n            this.chatId = istr.readString();\r\n            this.chatName = istr.readString();\r\n            this.lastMessageContent = istr.readString();\r\n            this.lastMessageTimestamp = istr.readLong();\r\n            this.isGroup = istr.readBool();\r\n        }\r\n\r\n        static get minWireSize()\r\n        {\r\n            return  12;\r\n        }\r\n    };\r\n\r\n    Slice.defineStruct(compunet.ChatSummary, true, true);\r\n\r\n    Slice.defineSequence(compunet, \"StringSeqHelper\", \"Ice.StringHelper\", false);\r\n\r\n    Slice.defineSequence(compunet, \"MessageSeqHelper\", \"compunet.Message\", false);\r\n\r\n    Slice.defineSequence(compunet, \"ChatSummarySeqHelper\", \"compunet.ChatSummary\", false);\r\n\r\n    Slice.defineSequence(compunet, \"UserSeqHelper\", \"compunet.User\", false);\r\n\r\n    const iceC_compunet_ChatService_ids = [\r\n        \"::Ice::Object\",\r\n        \"::compunet::ChatService\"\r\n    ];\r\n\r\n    compunet.ChatService = class extends Ice.Object\r\n    {\r\n    };\r\n\r\n    compunet.ChatServicePrx = class extends Ice.ObjectPrx\r\n    {\r\n    };\r\n\r\n    Slice.defineOperations(compunet.ChatService, compunet.ChatServicePrx, iceC_compunet_ChatService_ids, 1,\r\n    {\r\n        \"registerUser\": [, , , , , [[7], [7]], , , , ],\r\n        \"getUser\": [, , , , [compunet.User], [[7]], , , , ],\r\n        \"getAllUsers\": [, , , , [\"compunet.UserSeqHelper\"], , , , , ],\r\n        \"sendDirectMessage\": [, , , , , [[7], [7], [7]], , , , ],\r\n        \"getDirectChatMessages\": [, , , , [\"compunet.MessageSeqHelper\"], [[7], [7]], , , , ],\r\n        \"getUserDirectChats\": [, , , , [\"compunet.ChatSummarySeqHelper\"], [[7]], , , , ]\r\n    });\r\n\r\n    const iceC_compunet_GroupService_ids = [\r\n        \"::Ice::Object\",\r\n        \"::compunet::GroupService\"\r\n    ];\r\n\r\n    compunet.GroupService = class extends Ice.Object\r\n    {\r\n    };\r\n\r\n    compunet.GroupServicePrx = class extends Ice.ObjectPrx\r\n    {\r\n    };\r\n\r\n    Slice.defineOperations(compunet.GroupService, compunet.GroupServicePrx, iceC_compunet_GroupService_ids, 1,\r\n    {\r\n        \"createGroup\": [, , , , [7], [[7], [7], [\"compunet.StringSeqHelper\"]], , , , ],\r\n        \"addMembersToGroup\": [, , , , , [[7], [\"compunet.StringSeqHelper\"]], , , , ],\r\n        \"getGroupMembers\": [, , , , [\"compunet.StringSeqHelper\"], [[7]], , , , ],\r\n        \"sendGroupMessage\": [, , , , , [[7], [7], [7]], , , , ],\r\n        \"getGroupChatMessages\": [, , , , [\"compunet.MessageSeqHelper\"], [[7]], , , , ],\r\n        \"getUserGroupChats\": [, , , , [\"compunet.ChatSummarySeqHelper\"], [[7]], , , , ]\r\n    });\r\n    exports.compunet = compunet;\r\n}\r\n(typeof(__webpack_require__.g) !== \"undefined\" && typeof(__webpack_require__.g.process) !== \"undefined\" ? module : undefined,\r\n typeof(__webpack_require__.g) !== \"undefined\" && typeof(__webpack_require__.g.process) !== \"undefined\" ? __webpack_require__(\"./src/generated sync recursive\") :\r\n (typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope) ? self.Ice._require : window.Ice._require,\r\n typeof(__webpack_require__.g) !== \"undefined\" && typeof(__webpack_require__.g.process) !== \"undefined\" ? exports :\r\n (typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope) ? self : window));\r\n\n\n//# sourceURL=webpack://compunet-chat-client/./src/generated/chat.js?\n}");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _styles_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./styles.css */ \"./src/styles.css\");\n// Importar estilos\r\n\r\n\r\n// Importar mdulos\r\nconst iceManager = __webpack_require__(/*! ./IceConnectionManager */ \"./src/IceConnectionManager.js\");\r\nconst chatState = __webpack_require__(/*! ./ChatStateManager */ \"./src/ChatStateManager.js\");\r\nconst messageReceiver = __webpack_require__(/*! ./MessageReceiver */ \"./src/MessageReceiver.js\");\r\nconst uiController = __webpack_require__(/*! ./ChatUIController */ \"./src/ChatUIController.js\");\r\n\r\n// Funcin principal de inicializacin\r\nasync function initializeApp() {\r\n    try {\r\n        \r\n        // Inicializar UI primero\r\n        uiController.initialize();\r\n\r\n        // Ahora s puedes mostrar loading\r\n        uiController.showLoading('Conectando al servidor...');\r\n        \r\n        // Conectar al servidor Ice\r\n        await iceManager.initialize();\r\n        \r\n        console.log('Aplicacin inicializada correctamente');\r\n        \r\n        // Cargar datos iniciales\r\n        await loadInitialData();\r\n        \r\n        // Ocultar loading\r\n        uiController.hideLoading();\r\n        \r\n    } catch (error) {\r\n        console.error('Error al inicializar la aplicacin:', error);\r\n        uiController.hideLoading();\r\n        \r\n        // Mostrar error al usuario\r\n        alert('No se pudo conectar al servidor. Por favor, asegrate de que el servidor est ejecutndose en localhost:10000');\r\n    }\r\n}\r\n\r\nasync function loadInitialData() {\r\n    try {\r\n        console.log('Cargando datos iniciales...');\r\n        \r\n        // Cargar chats del usuario\r\n        await messageReceiver.refreshChats();\r\n        \r\n        // Renderizar lista de chats\r\n        uiController.renderChatList();\r\n        \r\n        console.log('Datos iniciales cargados');\r\n    } catch (error) {\r\n        console.error('Error al cargar datos iniciales:', error);\r\n        throw error;\r\n    }\r\n}\r\n\r\n// Manejar cierre de ventana\r\nwindow.addEventListener('beforeunload', async () => {\r\n    try {\r\n        await iceManager.shutdown();\r\n    } catch (error) {\r\n        console.error('Error al cerrar conexin:', error);\r\n    }\r\n});\r\n\r\n// Inicializar cuando el DOM est listo\r\nif (document.readyState === 'loading') {\r\n    document.addEventListener('DOMContentLoaded', initializeApp);\r\n} else {\r\n    initializeApp();\r\n}\r\n\r\n// Exportar para depuracin en consola\r\nwindow.chatDebug = {\r\n    iceManager,\r\n    chatState,\r\n    messageReceiver,\r\n    uiController\r\n};\n\n//# sourceURL=webpack://compunet-chat-client/./src/index.js?\n}");

/***/ }),

/***/ "./src/styles.css":
/*!************************!*\
  !*** ./src/styles.css ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleDomAPI.js */ \"./node_modules/style-loader/dist/runtime/styleDomAPI.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertBySelector.js */ \"./node_modules/style-loader/dist/runtime/insertBySelector.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ \"./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertStyleElement.js */ \"./node_modules/style-loader/dist/runtime/insertStyleElement.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleTagTransform.js */ \"./node_modules/style-loader/dist/runtime/styleTagTransform.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _node_modules_css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../node_modules/css-loader/dist/cjs.js!./styles.css */ \"./node_modules/css-loader/dist/cjs.js!./src/styles.css\");\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());\noptions.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());\n\n      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, \"head\");\n    \noptions.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());\noptions.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());\n\nvar update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"], options);\n\n\n\n\n       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"] && _node_modules_css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals ? _node_modules_css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals : undefined);\n\n\n//# sourceURL=webpack://compunet-chat-client/./src/styles.css?\n}");

/***/ }),

/***/ "?3c7e":
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/***/ (() => {

eval("{/* (ignored) */\n\n//# sourceURL=webpack://compunet-chat-client/fs_(ignored)?\n}");

/***/ }),

/***/ "?c885":
/*!*********************!*\
  !*** net (ignored) ***!
  \*********************/
/***/ (() => {

eval("{/* (ignored) */\n\n//# sourceURL=webpack://compunet-chat-client/net_(ignored)?\n}");

/***/ }),

/***/ "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAYAAACNMs+9AAAAGElEQVQYlWNgYGD4z0AEYBxVOKpwUBUCAEfGAgHWqMl7AAAAAElFTkSuQmCC":
/*!******************************************************************************************************************************************!*\
  !*** data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAYAAACNMs+9AAAAGElEQVQYlWNgYGD4z0AEYBxVOKpwUBUCAEfGAgHWqMl7AAAAAElFTkSuQmCC ***!
  \******************************************************************************************************************************************/
/***/ ((module) => {

"use strict";
eval("{module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAYAAACNMs+9AAAAGElEQVQYlWNgYGD4z0AEYBxVOKpwUBUCAEfGAgHWqMl7AAAAAElFTkSuQmCC\";\n\n//# sourceURL=webpack://compunet-chat-client/data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAYAAACNMs+9AAAAGElEQVQYlWNgYGD4z0AEYBxVOKpwUBUCAEfGAgHWqMl7AAAAAElFTkSuQmCC?\n}");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		__webpack_require__.b = (typeof document !== 'undefined' && document.baseURI) || self.location.href;
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"main": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// no jsonp function
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;